<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>go调度源码分析</title><link>https://zput.github.io/go-goroutine/</link><description>Recent content on go调度源码分析</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Tue, 23 Jun 2020 20:50:00 +0000</lastBuildDate><atom:link href="https://zput.github.io/go-goroutine/index.xml" rel="self" type="application/rss+xml"/><item><title>开启系统监控</title><link>https://zput.github.io/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/start_sysmon/</link><pubDate>Mon, 04 May 2020 12:35:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/start_sysmon/</guid><description>开启系统监控 # 这个是main goroutine执行的主函数，此函数之后会调用用户定义main函数,我们在初始化一章已经提过 main goroutine执行的主函数 它的里面可以看到调用了newm函数生成新M,且新M将执行sysmon函数
func main() { //... if GOARCH != &amp;#34;wasm&amp;#34; { // no threads on wasm yet, so no sysmon systemstack(func() { newm(sysmon, nil) }) } //... } sysmon # 可以看到sysmon里面是一个for循环,它会一直运行,因为这个M没有关联P，所以不允许写屏障 逻辑比较简单，延时睡眠，调用retake
// Always runs without a P, so write barriers are not allowed. // //go:nowritebarrierrec func sysmon() { lock(&amp;amp;sched.lock) sched.nmsys++ //增加记录系统线程的值的个数 checkdead() unlock(&amp;amp;sched.lock) lasttrace := int64(0) idle := 0 // how many cycles in succession we had not wokeup somebody delay := uint32(0) for { if idle == 0 { // start with 20us sleep.</description></item><item><title>主动调度</title><link>https://zput.github.io/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/active_scheduling/</link><pubDate>Thu, 02 Apr 2020 11:03:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/active_scheduling/</guid><description>goroutine主动调度 # 探寻runtime.Gosched() # goroutine主动调度就是调用runtime.Gosched()函数, 此函数会主动放弃与M的关联,并把自身(G)放入全局空闲G队列.当前的goroutine并不会退出,它进入全局G队列后可能会再次被调度运行.
src/runtime/proc.go:267
// Gosched yields the processor, allowing other goroutines to run. It does not // suspend the current goroutine, so execution resumes automatically. func Gosched() { checkTimeouts() mcall(gosched_m) } 在go1.14前,编译器不会插入抢占点,用户代码可能会陷入CPU计算循环(即使代码中有函数调用),它可能会一直霸占CPU,这时候可能需要runtime.Gosched, 在go1.14,编译器会在函数前加入自动抢占点.所以对于go1.14+，无需手动调用它。
gdb主动调度 # main.go
package main import ( &amp;#34;runtime&amp;#34; &amp;#34;sync/atomic&amp;#34; ) var existFlag int32 = 2 // the function&amp;#39;s body is empty func addAssemble(x, y int64) int64 func add(a int64){ addAssemble(a, a) atomic.AddInt32(&amp;amp;existFlag, -1) } func main() { runtime.</description></item><item><title>从全局/本P队列</title><link>https://zput.github.io/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/take_goroutine_from_globalorlocal_p/</link><pubDate>Mon, 02 Mar 2020 13:03:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/take_goroutine_from_globalorlocal_p/</guid><description>从本地队列或全局队列获取goroutine # 分析schedule函数整个流程:
src/runtime/proc.go
// One round of scheduler: find a runnable goroutine and execute it. // Never returns. func schedule() { _g_ := getg() //... top: //... var gp *g var inheritTime bool //... if gp == nil { // Check the global runnable queue once in a while to ensure fairness. // Otherwise two goroutines can completely occupy the local runqueue // by constantly respawning each other. if _g_.</description></item><item><title>GMP模型结构体</title><link>https://zput.github.io/go-goroutine/docs/runtime/golang_gmp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/golang_gmp/</guid><description>1.同步&amp;amp;异步/阻塞&amp;amp;非阻塞 # 同步/异步、阻塞/非阻塞可从字面上理解。
同步是指相同的步调，既然是相同，必然涉及比较，那至少是关于两者或以上的比较，同理异步描述的是不同的步调，所以同步、异步描述的是两个对象（模块）之间的&amp;quot;关系&amp;quot;。（最常见的比如：调用方、被调用方）。
阻塞是指卡住了，等待在那里而不能做其他事情了。也即是说，阻塞、非阻塞描述的是自身的一个运行状态。
综上所述:同步、异步描述两者的关系, 阻塞、非阻塞描述的是一者的状态，其两者讲的不同的事情。
1.2 同步异步 # 同步异步是一种涉及两着的关系。
程序处理多任务 # 并发，并行引出来的一种多个任务运行的关系，涉及的关系是任务A与任务B
并发是指在同一时间间隔内同时执行多个任务的能力，这些任务可能会交替执行或部分重叠执行。并发的重点在于在同一时间间隔内最大化完成任务的数量，它通常侧重于提高系统的吞吐量和响应 能力。 并行是指同时执行多个任务，这些任务将被同时分配给不同的计算资源，例如不同的处理器、内核或线程/进程。并行的重点在于尽可能缩短任务的执行时间，它通常侧重于提高系统的性能和效率。
并行∈并发，并发=并行+交错
这里并发包括同步（synchronous）和异步（asynchronous）两种方式: 同步是指任务按照一定的顺序依次执行，每个任务需要等待前一个任务完成后才能执行，任务之间有明显的先后顺序。同步执行的任务需要占用CPU资源，但是其执行结果是可预测的。
异步是指任务在不等待其他任务执行结果的情况下，直接进行下一步操作，任务之间不受顺序限制。异步执行的任务不会占用CPU资源，因为它们不会一直等待其他任务的完成，但是其执行结果不一定是可预测的。
程序与外部交互(可以是外部系统，也可能是操作系统) # 调用方与被调用方的关系。
web开发最多的HTTP接口同步异步。 需要说明的是接口本身不区分同步和异步。这种区分更在于客户端(调用方)如何与接口进行交互，以及服务端(被调用方)如何处理请求。
服务端接口 服务端实现：服务端处理请求的方式可以是同步的，也可以是异步的。同步实现可能在处理请求时会阻塞直到完成，而异步实现可能会利用事件驱动或多线程来提高并发性和响应速度。 对客户端的透明性：从客户端的角度来看，服务端的实现细节是透明的。客户端并不知道服务端是同步还是异步地处理请求。 提供额外的机制来支持异步操作，例如： Webhooks/mq：服务端在处理完成后主动通知客户端。 回调URL：客户端提供一个回调URL，服务端在处理完成后向该URL发送通知。 轮询（Polling）：客户端定期检查服务端的状态以获取结果。 客户端调用 同步调用：客户端发起请求并等待响应完成后再继续执行其他操作。这种方式在编写代码时表现为阻塞调用。 异步调用：客户端发起请求后可以立即继续执行其他任务，并在响应返回时通过回调、Promise或其他机制处理结果。 操作系统的io操作, 同步io，异步io。 《UNIX Network Programming》（简称UNP）中，通常总结了五种I/O模型，这些模型描述了在UNIX系统中进行网络编程时处理I/O操作的不同方式。
阻塞 I/O 模型（Blocking I/O）
描述：这是最简单的I/O模型。在发起I/O操作（如read或recv）时，调用方会阻塞，直到数据准备好并完成操作。 优点：实现简单，因为所有操作都是顺序进行的。 缺点：在等待数据时，调用方无法执行其他任务，这可能导致资源低效利用。 非阻塞 I/O 模型（Non-blocking I/O）
描述：调用方在发起I/O操作时立即返回，即使数据尚未准备好。调用方需要不断地重试操作以检查数据是否可用。 优点：调用方在等待数据时可以执行其他任务。 缺点：需要实现轮询机制（polling），这可能导致CPU资源浪费。 I/O 复用模型（I/O Multiplexing）
描述：使用select、poll或epoll等系统调用来监视多个文件描述符。当一个或多个文件描述符准备好进行I/O操作时，系统调用返回。(可以用来等很多描述符, 但需要阻塞着检查是否可读。对同一个描述符的IO操作也是有序的。) 优点：允许一个线程同时处理多个I/O操作，提高资源利用率。 缺点：在监视大量文件描述符时可能存在性能瓶颈。 信号驱动 I/O 模型（Signal-driven I/O）
描述：使用信号机制进行I/O操作。当文件描述符准备就绪时，内核向进程发送信号。(不用监视描述符，而且不用阻塞着等待数据到来，被动等待信号通知，由信号处理程序处理。但对同一个描述符的IO操作还是有序的。) 优点：减少了轮询的需要，进程可以在信号到达前执行其他任务。 缺点：信号处理相对复杂，需要处理信号的异步性。(仍由请求进程将数据从内核读入用户空间（阻塞)) 异步 I/O 模型（Asynchronous I/O）</description></item><item><title>基本用法</title><link>https://zput.github.io/go-goroutine/docs/foundation/golang_basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/foundation/golang_basic/</guid><description>数据结构 # 这些数据结构的底层是怎么实现的,比如array,它就是一个指针,指向第一个元素的地址. 然后就是一个细节,如果要实现这个数据结构的一些功能,比如chan读写,map的添加删除等,它们是怎么利用数据结构里面底层的field来实现这些功能? 引用 # 通常意义上来说，引用就是某块内存的别名, 我们常常拿指针与引用进行比较, 那么看看引用在底层是怎么实现的:
一种是c++里的引用实现，它其实是一个语法糖，经过编译器编译后，汇编代码引用就是指针，只不过是const指针，初始化的时候就需要赋值，且以后不能再更改[ c++里的引用实现;且两者地址相同。 特别说明由于引用只是指针包装, 也存在风险:
int *a = new int; int &amp;amp;b = *a; delete a; b = 12; // 对已经释放的内存解引用 另-种是用结构体来包装一层，它的里面是实际内容的指针
type slice struct { array unsafe.Pointer len int cap int } string # string类型的底层结构.它的大小是几个字节?
指针和字节大小
0xxxxxxx 110xxxxx 10xxxxxx 1110xxxx 10xxxxxx 10xxxxxx package main import ( &amp;#34;fmt&amp;#34; &amp;#34;reflect&amp;#34; &amp;#34;unicode/utf8&amp;#34; &amp;#34;unsafe&amp;#34; ) func String2Bytes(s string) []byte { sh := (*reflect.StringHeader)(unsafe.Pointer(&amp;amp;s)) bh := reflect.</description></item><item><title>测试相关函数</title><link>https://zput.github.io/go-goroutine/docs/robustness_and_performance/golang_test/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/robustness_and_performance/golang_test/</guid><description>golang测试相关函数 # test函数的种类 # func TestXxx(t *testing.T) { ... } 注意下这个Xxx需要大写 func BenchmarkXxx(b *testing.B) { ... } 注意下这个Xxx需要大写 ExampleXxx prints output to os.Stdout &amp;ldquo;Output:&amp;rdquo; &amp;ldquo;Unordered output:&amp;rdquo; go help testfunc
Expand ↕ The &amp;#39;go test&amp;#39; command expects to find test, benchmark, and example functions in the &amp;#34;*_test.go&amp;#34; files corresponding to the package under test. A test function is one named TestXxx (where Xxx does not start with a lower case letter) and should have the signature, func TestXxx(t *testing.</description></item><item><title>被动调度</title><link>https://zput.github.io/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/passive_scheduling/</link><pubDate>Wed, 15 Apr 2020 11:33:07 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/passive_scheduling/</guid><description>goroutine被动调度 # 什么是被动调度: goroutine执行某个操作因条件不满足需要等待而发生的调度
goroutine进入睡眠 比如是goroutineN发送数据到无缓冲chan上面,当没有其他Goroutine从chan上面读数据的时候,goroutineN阻塞在chan上面. 此刻睡眠含义:进入chan的缓存读取队列(goroutine链表) 重新运行schedule() 唤醒睡眠中的goroutine; 唤醒空闲的P和唤醒/创建工作线程; goroutine(被创建出来后/创建运行了一段时间后)如何放入运行队列P中 被动进入睡眠 # goroutine因某个条件而阻塞 chan waitGroup 等这些都会发生阻塞 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;runtime&amp;#34; &amp;#34;sync&amp;#34; &amp;#34;sync/atomic&amp;#34; ) func main() { var n int32 var wg sync.WaitGroup runtime.GOMAXPROCS(2) wg.Add(1) go func() { wg.Done() for{ atomic.AddInt32(&amp;amp;n, 1) } }() wg.Wait() fmt.Println(atomic.LoadInt32(&amp;amp;n)) // 1 } gdb调试前准备 # 编译程序 # 编译一下源代码: go build -gcflags &amp;quot;-N -l&amp;quot; -o test ..
准备mcall函数断点的文件 # 进入wg.Wait()
我们都知道main函数里面的wg.Wait()这个只有当wg的计数器到0后才会继续执行,来看看当wg还没有到0的时候,这里会发生什么呢?
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // src/sync/waitgroup.</description></item><item><title>从其他P队列</title><link>https://zput.github.io/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/steal_goroutine_from_other_p/</link><pubDate>Sun, 08 Mar 2020 10:05:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/steal_goroutine_from_other_p/</guid><description>从其他队列盗取goroutine # 盗取Goroutine的过程就是:如果在所有运行队列找g都找不到,M就进入睡眠状态
findrunnable函数 # // Finds a runnable goroutine to execute. // Tries to steal from other P&amp;#39;s, get g from global queue, poll network. func findrunnable() (gp *g, inheritTime bool) { _g_ := getg() // The conditions here and in handoffp must agree: if // findrunnable would return a G to run, handoffp must start // an M. top: _p_ := _g_.m.p.ptr() //... // local runq //再次看一下本地运行队列是否有需要运行的goroutine if gp, inheritTime := runqget(_p_); gp !</description></item><item><title>伪寄存器与函数栈帧</title><link>https://zput.github.io/go-goroutine/docs/runtime/schedule/ch0-preknowledge/register_functionstack/</link><pubDate>Thu, 28 Feb 2019 15:03:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/schedule/ch0-preknowledge/register_functionstack/</guid><description>伪寄存器 &amp;amp; 函数栈 # 伪寄存器 # 伪寄存器常用的一般是下面的四个:
FP: Frame pointer: arguments and locals. PC: Program counter: jumps and branches. SB: Static base pointer: global symbols. SP: Stack pointer: top of stack. 下面我们来翻译一下 官网1的对他们的解释，然后做一个总结,方便理解。
FP # FP伪寄存器是一个用于引用函数参数的虚拟帧指针。编译器维护一个虚拟帧指针，并将堆栈上的参数引用为该伪寄存器的偏移量。因此0(FP)是函数的第一个参数，8(FP)是第二个参数(在64位机器上)，以此类推。但是，当以这种方式引用一个函数参数时，有必要将名称放在开头，如first_arg+0(FP)和second_arg+8(FP)。(偏移量的含义(从帧指针出发的偏移量)与它在SB中的使用不同，在SB中，它是从符号出发的偏移量。) 汇编器强制执行这个约定，拒绝普通的0(FP)和8(FP)。实际的名称在语义上是不相关的，但应该用来记录参数的名称。值得强调的是，FP始终是一个伪寄存器，而不是硬件寄存器，即使在具有硬件帧指针的架构上也是如此。
The FP pseudo-register is a virtual frame pointer used to refer to function arguments. The compilers maintain a virtual frame pointer and refer to the arguments on the stack as offsets from that pseudo-register.</description></item><item><title>slice</title><link>https://zput.github.io/go-goroutine/docs/foundation/slice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/foundation/slice/</guid><description> 使用slice # 使用slice的时候，如果能预先确定它的大小，最好先设置好它的容量，避免后期扩容拷贝。预先大小也可能为零，所以总担心初始化能不能先申明容量为零。
func testMakeSlice() { var ( a = make([]int, 0) b = make([]int, 0, 0) ) fmt.Printf(&amp;#34;a=%+v; b=%+v&amp;#34;, a, b) fmt.Println() fmt.Printf(&amp;#34;a&amp;#39;s Length=%+v; b&amp;#39;s Length=%+v&amp;#34;, len(a), len(b)) fmt.Println() fmt.Printf(&amp;#34;a&amp;#39;s Capacity=%+v; b&amp;#39;s Capacity=%+v&amp;#34;, cap(a), cap(b)) fmt.Println() if a == nil { fmt.Println(&amp;#34;a is nil&amp;#34;) } else { fmt.Println(&amp;#34;a is not nil&amp;#34;) } if b == nil { fmt.Println(&amp;#34;b is nil&amp;#34;) } else { fmt.Println(&amp;#34;b is not nil&amp;#34;) } } func main() { testMakeSlice() } a=[]; b=[] a&amp;#39;s Length=0; b&amp;#39;s Length=0 a&amp;#39;s Capacity=0; b&amp;#39;s Capacity=0 a is not nil b is not nil</description></item><item><title>内存分配器</title><link>https://zput.github.io/go-goroutine/docs/runtime/golang_memery/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/golang_memery/</guid><description>1 前言 # 从程序的角度来看， 我们定义个变量，需要知道存储此变量所需的内存大小，以及申请一块内存，并返回内存的首地址；后续变量名与此地址就绑定起来，方便后续操作。
细化下上述所说的内容，主要包含如下：
怎么评估变量所需的内存大小? 如何申请一块内存。是每次申请时都向操作系统直接申请吗？还是先向操作系统申请一大块内存，在程序内部进行管理，当都用完时，才继续向操作系统进行申请呢？ 如果第二点都使用后者的方式，那么如何进行管理？ 2 评估内存大小 # 2.1 内存对齐 # what 什么是内存对齐呢？官方解释是：xxxx
why 为什么需要进行内存对齐呢? 主要是当前的内存限制的原因。 3 分配内存 # 没有内存管理，每次申请都直接向操作系统申请
通过程序级别的内存管理
因程序运行起来所需要分配的内存块有大有小，而分散的、大小不一的碎片化内存，一方面会降低内存的使用率，另一方面要找到大小合适的内存块的代价会因碎片化而增加，为降低碎片化内存给程序性能造成的不良影响，
3.1 Tcmalloc # golang采用了类似谷歌的Tcmalloc算法来解决碎片化问题：
Tcmalloc：
按照一组预置的大小规格把内存页划分成块，相同的块串联在一个空闲链表中。 程序申请内存时，会先根据要申请的内存大小，找到最匹配的规格，然后从对应空闲链表中分配一个空闲块。 4 golang内存管理 # 4.1 内存结构 # golang把内存大小分为四种级别，分别为:Arena, Page, Span，内存块。
注：下文讨论的都是在amd64架构的Linux环境下.
Arena：golang将堆地址空间划分为一个个arena区，arena区域起始地址定义在arenaBaseOffset，每个arena的大小是64MB，起始地址也对齐到64MB
Page：每个arena包含8192个page，所以每个page大小为8KB。
Span：包含一个或多个页大小的内存。golang给出了67种预置的大小规格，最小8Byte，最大32KB，所以在划分整整齐齐的arena中，又会按需划分出不同的Span,每个Span包含一组连续的Page，
类别(class) 内存块对象大小(bytes/obj) Span大小(bytes/span) Span中内存块对象个数(objects) 尾部浪费(tail waste) 最大浪费百分比(max waste) 1 8 8192 1024 0 87.50% 2 16 8192 512 0 43.75% 3 24 8192 341 8 29.</description></item><item><title>类汇编</title><link>https://zput.github.io/go-goroutine/docs/runtime/schedule/ch0-preknowledge/similar_assemble/</link><pubDate>Thu, 28 Feb 2019 15:03:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/schedule/ch0-preknowledge/similar_assemble/</guid><description>golang类汇编指令 # 寻址模式 # (DI)(BX2): The location at address DI plus BX2. 64(DI)(BX2): The location at address DI plus BX2 plus 64. These modes accept only 1, 2, 4, and 8 as scale factors. 结构体+寄存器 # 类似这种:
# (m_morebuf+gobuf_pc)(REGISTER) MOVQ 8(SP), AX # f&amp;#39;s caller&amp;#39;s PC MOVQ AX, (m_morebuf+gobuf_pc)(BX) type m struct { g0 *g // goroutine with scheduling stack morebuf gobuf // gobuf arg to morestack //-----------morebuf-------------// divmod uint32 // div/mod denominator for arm - known to liblink //.</description></item><item><title>map</title><link>https://zput.github.io/go-goroutine/docs/foundation/map/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/foundation/map/</guid><description>并发map # 设计一个并发的map,最简单的就是使用锁加普通map来实现。
type simpleConcurrentMap struct{ mu sync.Mutex m map[interface{}]interface{} } 上面情形，不管是读还是写都需要先加锁，性能太低，假设我们要设计一个高并发的map呢？我们按读写操作来分一下类：
读多写少 读少写多 读写平衡 可以分为上述三类。 读多写少场景 # 可以让它们读写分离,分成两个map（readMap与writeMap）, 类似mysql的读写分离吗? 那么插入/更新(删除)的时候怎么从writeMap同步到readMap呢？不可能实时同步，否则readMap也转变为了writeMap,也需要加锁!!! 这么看读写分离就没有必要了，徒增复杂度。
那么可以设计成类似缓存的cacheMap(不加锁，原子锁)与持久化的persistentMap(加锁)？且把真实的value保存在第三方，自己保留的是第三方的句柄(handle), 类似下图的结构:
cacheMap: nil key---&amp;gt;ValuePtr(第三方句柄) / \ / \ / ---&amp;gt;valuePtr/-----&amp;gt;value(真实的值) / 可理解为第三方的唯一键 persistentMap: / key---&amp;gt;valuePtr(第三方句柄) 当删除的时候，如果在cacheMap中存在，就把对应的ValuePtr设置为nil(代表删除) 当更新的的时候，如果在cacheMap中存在，就把对应的ValuePtr所指向的value改为newValue(这样persistentMap也更新了) 当查询的时候，先去cacheMap查(如果key存在，valuePtr为nil则说明删除了，但是没有同步到persistentMap)，再去persistentMap查 当插入新的key时候，操作persistentMap。但是这也会遇到什么时候同步到cacheMap中去的问题，因为如果一直不同步，会导致查询的时候都会到persistentMap中去，也是要加锁的。
一个补偿措施是: 加一个计数器misses，在查询的时候，如果只有在persistentMap中才查到则misses++，到了一定条件，我们把persistentMap安全地同步到cacheMap中，并且清空persistentMap。
cacheMap是 persistentMap的一个只读拷贝，禁止自行增加新key，只能读或者改。
golang中的sync.Map就是一种适合读多写少的并发map; 把我们的 persistentMap 叫做了 dirtyMap，把persistentMap 同步到 cacheMap 叫做了promote（升级）。
读取 Map.Load
if is exist readMap[key] 读取返回 ret lock() if is exist readMap[key] // double-checking 读取返回 else if is exist dirtyMap[key] 读到了，在dirtyMap存在，但是在readMap中不存在 misses++ // 未命中自增 if misses &amp;gt;= len(dirtyMap) // 判断是否需要把dirtyMap提升级为readMap readMap = dirtyMap dirtyMap = nil // dirtyMap置空 else key is not exist unlock() 写入 Map.</description></item><item><title>垃圾回收</title><link>https://zput.github.io/go-goroutine/docs/runtime/golang_gc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/golang_gc/</guid><description>1 前言：变量的存放区 # 通常情况下，变量的分配位置一般是下列三个区：
全局数据区 栈区 堆区 全局数据区:主要用于全局变量的分配，也即包级别的变量,其生命周期和进程相同。
栈区:主要存储函数内部定义的本地变量,当函数执行完毕，变量即可释放。函数执行时通过栈帧加偏移来访问这些数据。
堆区:主要用于程序运行阶段的动态分配。
内存中的对象存在着相互的引用关系。全局数据区与栈区可能指同堆上的数据,这两个地方的指针是堆内存访问的起点，也就是堆内存访问的根节点(root)。
2 定义 # 垃圾回收（garbage collect）简称gc,主要是释放那些不再需要的分配在堆（heap）上的数据, 以便再次用来进行内存分配。垃圾回收一般分为两个步骤：垃圾识别和垃圾清理。
golang支持垃圾自动回收，主要是降低人的心智负担，从堆（heap）中申请的内存，不需要手动的释放。其采用三色标记法来识别垃圾对象，并使用清除算法进行垃圾清理。
2.1 垃圾识别 # 2.1.1 双色标记法 # 根节点一般为全局变量、栈中的变量，维护根节点集合是可达性分析的前提。可达性分析是指从根对象开始，遍历其引用的子节点对象，直至遍历完毕。凡是能够触达的对象，都视作有效对象，而无法触达的，则视作垃圾对象。
双色标标记法采用可达性分析来标记对象状态;通过对象的可达性近视的认为存活性。
双色标记法看上去简单易用，但却存在着一个比较大的缺点，即整个标记过程必须一次性完成，中间不能有任何停顿。也就是说，在执行过程中，不能让出CPU时间片给其他线程。对于应用程序来说，可能会出现用户线程完全停顿，直至标记过程结束。
双色标记法只能描述对象节点自身是否扫描，而不能描述子节点是否完成。这导致重启标记开始后，很难抉择该如何继续，如果再次从根节点开始，那就意味着上次所做的工作完全被浪费掉了。因此，双色标记在停顿、再次重启过程中，无法完成状态的自描述。
由于新增对象无法确定置为黑色还是白色，因此导致扫描过程不能停顿。对双色标记而言可将新增对象直接标记为黑色，然后到下轮垃圾回收才将本轮新增对象中的垃圾对象（往往是生命周期很短的对象）清除。
2.1.2 三色标记法 # 全局数据区与栈区的指针是堆内存访问的起点, 所以把它们放入一个待扫描队列（工作队列）,通过它们可以发现堆上第一批可达数据,发现的可达数据中有指针的加入待扫描队列（灰色节点）扫描完的标为黑色，离开队列,通过扫描灰色节点会发现更多灰色节点，也会产生更多黑色点节点,直到没有待扫描的灰色节点,我们就找到了所有可达数据（黑色节点）,剩下的白色节点就是不可达数据不可达自然用不到,也即是可以进行释放。
黑色：当基于当前节点的追踪任务完成后，表示为存活数据，后续无需再追踪。 灰色：基于当前节点展开的追踪还未完成。 白色：当追踪完成后，代表可回收的对象。 问题：黑色对象如果指向白色对象,会导致白色对象被错误回收。
原因： 并发执行,如果将白色对象写入黑色对象,同时没有其它未扫描的路径,可抵达该白色对象,它就不会被扫描携程发现,继而被误判为垃圾。
当gc使用三色标记法与用户程序并发执行的时候，可能让黑色对象重新引用了白色对象，且无其他灰色对象引用了这个白色对象。导致白色对象错误回收。(用户程序和垃圾收集器可以在交替工作的)
处理措施：
有两种方法来避免:
强三色：黑色对象只能引用灰色对象。 弱三色：所有被黑色对象引用的白色对象都处于灰色保护状态. 引入写屏障：就是在执行写操作时，额外做些标记工作(把数据对象的修改通知到垃圾回收器)，避免垃圾误判。
分为两种，一种是插入写屏障，一种是删除写屏障。
插入写屏障 writePointer(slot, ptr): // ⚠️:slot现在指向的还是旧对象 shade(ptr) //shade函数尝试改变指针的颜色--&amp;gt;改变ptr的颜色 *slot = ptr 删除写屏障： 会在老对象的引用被删除时，将白色的老对象涂成灰色。 writePointer(slot, ptr) // ⚠️:slot现在指向的还是旧对象 shade(*slot) //shade函数尝试改变指针的颜色--&amp;gt;改变(*slot)的颜色---&amp;gt;注意这个是*slot(旧对象),slot保存着它原先的保存的地址。 *slot = ptr 引入新问题：只有插入写屏障，但是这需要对所有堆、栈的写操作都开启写屏障，程序性能会受到影响，代价太大。为了改善这个问题，改为忽略协程栈上的写屏障，只在标记结束阶段重新扫描那些被激活的栈帧。但是Go语言通常会有大量活跃的协程，这就导致第二次STW时重新扫描协程栈的时间太长。</description></item><item><title>sort</title><link>https://zput.github.io/go-goroutine/docs/foundation/sort/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/foundation/sort/</guid><description>在实际开发中，我们如何利用sort包，进行快速排序呢。
首先我们来看一下sort中最重要的一个接口:
sort # type Interface interface { // Len is the number of elements in the collection. Len() int // Less reports whether the element with // index i should sort before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) } // 内部实现的四种排序算法 // 插入排序 func insertionSort(data Interface, a, b int) // 堆排序 func heapSort(data Interface, a, b int) // 快速排序 func quickSort(data Interface, a, b, maxDepth int) // 归并排序 func symMerge(data Interface, a, m, b int) 一般我们利用下面三种方式进行排序:</description></item><item><title>代码执行过久</title><link>https://zput.github.io/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/user_code_preemption/</link><pubDate>Mon, 04 May 2020 12:35:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/user_code_preemption/</guid><description>执行太久需要抢占 # preemptone设置抢占 # 继续上文看下preemptone函数，它设置了g.preempt(抢占标示)为true和g.stackguard0为很大的数((1&amp;lt;&amp;lt;(8*sys.PtrSize) - 1) &amp;amp; -1314 ---&amp;gt; 0xfffffffffffffade)，使被抢占的goroutine在进行函数调用会去检查栈溢出,然后处理抢占请求
// Tell the goroutine running on processor P to stop. // This function is purely best-effort. It can incorrectly fail to inform the // goroutine. It can send inform the wrong goroutine. Even if it informs the // correct goroutine, that goroutine might ignore the request if it is // simultaneously executing newstack. // No lock needs to be held.</description></item><item><title>初始化</title><link>https://zput.github.io/go-goroutine/docs/runtime/schedule/2_init_before_enter_main_function/</link><pubDate>Mon, 20 Jan 2020 10:03:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/schedule/2_init_before_enter_main_function/</guid><description>进入main函数前的初始化 # 我们首先来gdb调试一下这个程序
// main.go package main import &amp;#34;fmt&amp;#34; // the function&amp;#39;s body is empty func add(x, y int64) int64 func main() { gg:=add(2, 3) fmt.Println(gg) } // add_amd.s TEXT ·add(SB),$0-24 MOVQ x+0(FP), BX MOVQ y+8(FP), BP ADDQ BP, BX MOVQ BX, ret+16(FP) RET 编译一下源代码: go build -gcflags &amp;quot;-N -l&amp;quot; -o test ..
程序加载到内存入口 # Expand ↕ (gdb) info files Symbols from &amp;#34;/tmp/kubernets/test&amp;#34;. Local exec file: `/tmp/kubernets/test&amp;#39;, file type elf64-x86-64.</description></item><item><title>底层重要结构</title><link>https://zput.github.io/go-goroutine/docs/runtime/schedule/ch0-preknowledge/go_underlying_struct/</link><pubDate>Sun, 20 Jan 2019 09:03:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/schedule/ch0-preknowledge/go_underlying_struct/</guid><description>https://blog.tianfeiyu.com/source-code-reading-notes/go/golang_gpm.html
g结构 # type g struct { // 栈相关的两个字段 stack stack stackguard0 uintptr stackguard1 uintptr // offset known to liblink // defer 和 panic _panic *_panic // 最内侧的 panic 结构体 _defer *_defer // 最内侧的延迟函数结构体 // m *m sched gobuf atomicstatus uint32 goid int64 // 抢占 preempt bool // 抢占信号 preemptStop bool // 抢占时将状态修改成 `_Gpreempted` preemptShrink bool // 在同步安全点收缩栈 } type gobuf struct { sp uintptr pc uintptr g guintptr ctxt unsafe.</description></item><item><title>退出</title><link>https://zput.github.io/go-goroutine/docs/runtime/schedule/3_exit_goroutine/</link><pubDate>Mon, 10 Feb 2020 10:09:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/schedule/3_exit_goroutine/</guid><description>goroutine退出过程 # goroutine退出,即执行完callee代码后，返回到caller中去，前面一节我们看到，编译器自己把goexit()的地址设置为了caller的pc保存到栈上方,所以退出后，会执行goexit()函数,但是main goroutine比较特殊，这个groutine运行的代码 main函数直接调用了操作系统exit()这个API退出,没有机会返回到caller层.
main goroutine的退出 # 在上节中我们看到程序执行到了 mian函数
// The main goroutine. func main() { g := getg() //... //main包 init函数，递归的调用import包中定义的init函数 fn := main_init // make an indirect call, as the linker doesn&amp;#39;t know the address of the main package when laying down the runtime fn() //... //调用main.main函数(用户定义的main函数):进行间接调用是因为链接器在放置运行时不知道主包的地址 fn = main_main // make an indirect call, as the linker doesn&amp;#39;t know the address of the main package when laying down the runtime fn() //.</description></item><item><title>陷入系统调用</title><link>https://zput.github.io/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/system_call_preemption/</link><pubDate>Tue, 23 Jun 2020 20:50:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/system_call_preemption/</guid><description>执行系统调用抢占 # handoffp # handoffp函数:判断是否需要启动工作线程来接管_p_，如果不需要则把_p_放入P的全局空闲队列.
如果当前P的运行队列有任务/全局队列有任务，有gc任务，大概率整个系统有任务待做，或者当前P是最后一个P要用作轮询网络
其中大概率整个系统有任务待做: 由第24行 atomic.Load(&amp;amp;sched.nmspinning)+atomic.Load(&amp;amp;sched.npidle) == 0 决定:
如果没有P空闲，而且这些没空闲的P连接的M不是处在自旋状态(没有自旋的M)，证明其他P都在工作(而不是假装工作实际是在伺机从其他队列偷任务那种),是不是说明整个系统除了当前P外都在做事，所以大概率某些P的运行队列上有任务积压，所以我们应该启动M,让它跟当前P连接，去别的P中偷任务)
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 // Hands off P from syscall or locked M.</description></item><item><title>概述</title><link>https://zput.github.io/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/1_summarize/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/1_summarize/</guid><description>分配一个对象，mutator -&amp;gt; Allocator -&amp;gt; heap分类，从横向来看，可分为线性与链表形式;其中链表又可以分为：首次适应，循环首次适应，最优适应和预先隔离适应。 从纵向来看，可以分为单级与多级。
而golang混合纵向的多级,而各级横向结构有线性形式，也有链表的形式。分配某一对象，按照其大小涉及到的层级不同，可分为微小对象，小对象，大对象三类。
当需要分配这三类对象时，从下面的对应的结构中开始分配
tiny --&amp;gt; 微小对象 mcache ---&amp;gt; 小对象 mcentralList heapArenasList ---&amp;gt; 大对象 sequential allocation 的实现方式非常简单，只需要把维护的空间直接分配出去就好，每次分配以后挪动指针，指向剩余空闲的位置的首地址，runtime off-heap object allocator一节中介绍的persistent allocator采用的就是sequential allocation这个方式。sequential allocation这种分配方式的缺点是不能直接回收，得配合特定的垃圾回收算法，比如semispace copying collection，这种垃圾回收算法把堆划分成两份，当一份分配完以后，把仍然有用的对象拷贝到另外半个堆中，这样没有用的对象的空间就被回收了，分配空间继续在另外半个堆进行，当满了以后再拷贝有用的对象回到原来的半个堆中。
free list allocation 这种分配方式相对sequential allocation这种方式没能更好的利用上缓存的空间局部性原理，并且分配的时候速度慢，虽然有first fit 、next fit、best fit三种寻找空闲块的策略 ，但是多少还是会造成外部碎片。但是free list allocation 可以支持立马把释放的空间放到list中用于后续的分配。
segregated-fix allocation 是属于fee list allocation的一种细分
func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer { //... if size &amp;lt;= maxSmallSize { if noscan &amp;amp;&amp;amp; size &amp;lt; maxTinySize { // 微对象分配 } else { // 小对象分配 } } else { // 大对象分配 largeAlloc } //.</description></item><item><title>分配大对象</title><link>https://zput.github.io/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_big_object/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_big_object/</guid><description>分配大对象会涉及到的三个部分：栈/块/区</description></item><item><title>概述</title><link>https://zput.github.io/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_middle_object/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_middle_object/</guid><description>看下这个调用图
digraph cacheSpan { rankdir=TB; node[shape=box]; start[label=&amp;#34;开始&amp;#34;]; end[label=&amp;#34;结束&amp;#34;]; sg[label=&amp;#34;获取当前 sweepgen 值&amp;#34;]; nonempty[label=&amp;#34;遍历非空 span 列表&amp;#34;]; sweepgen[label=&amp;#34;如果内存单元的 sweepgen 等于 mheap.sweepgen - 2， 那么意味着当前单元需要清理 \n如果等于 mheap.sweepgen - 1，那么当前管理单元就正在清理&amp;#34;;shape=plain; ] empty[label=&amp;#34;遍历空 span 列表&amp;#34;]; sweep[label=&amp;#34;清理 span 并将其添加到空 span 列表&amp;#34;]; free[label=&amp;#34;释放部分空间&amp;#34;]; grow[label=&amp;#34;创建新的 span 并添加到空 span 列表&amp;#34;]; cache[label=&amp;#34;重新填充 span 的分配缓存&amp;#34;]; have[label=&amp;#34;返回 span 指针&amp;#34;]; // 处理mspan subgraph cluster_span { style = dotted margin = 10 &amp;#34;块(span)&amp;#34; [shape = plaintext;fontsize = 24] &amp;#34;mheap.alloc_m&amp;#34; &amp;#34;notice1&amp;#34; [shape=plain;label=&amp;#34;在这里才设置mspan中的spanclass&amp;#34;] {rank=same; &amp;#34;notice1&amp;#34; -&amp;gt; &amp;#34;mheap.alloc_m&amp;#34;[dir=none]; } } start -&amp;gt; sg; {rank=same; sweepgen -&amp;gt; nonempty[style=invis];} sg -&amp;gt; nonempty -&amp;gt; sweep -&amp;gt; empty -&amp;gt; free -&amp;gt; have; nonempty -&amp;gt; empty; empty -&amp;gt; grow -&amp;gt; cache -&amp;gt; have; have-&amp;gt;end; } mcentral中有六个mspan列表，分别是:</description></item><item><title>概述</title><link>https://zput.github.io/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_small_object/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_small_object/</guid><description>off是tiny Allocator的偏移指针，根据将要分配的内存大小，需调整off。如果size是8的倍数，则调用round(off,8)函数将off向上舍入到8的倍数。否则，如果size是4的倍数，则调用round(off,4)函数将off向上舍入到4的倍数。最后，如果size是2的倍数，则调用round(off,2)函数将off舍入到2的倍数。
off := c.tinyoffset // Align tiny pointer for required (conservative) alignment. if size&amp;amp;7 == 0 { off = round(off, 8) } else if size&amp;amp;3 == 0 { off = round(off, 4) } else if size&amp;amp;1 == 0 { off = round(off, 2) } 验证如下，需要调整的都会打印出来
===&amp;gt;原始: off:1, size:2 | 调整后: off:2, size:2 &amp;lt;===2倍数 // https://go.dev/play/p/1fl_cnJNwD- package main import ( &amp;#34;fmt&amp;#34; ) func main() { for i := 0; i &amp;lt; 16; i++ { for j := 1; j &amp;lt; 16; j++ { tmpOff, tmpSize := Size(i, j) if i !</description></item><item><title>概述</title><link>https://zput.github.io/go-goroutine/docs/runtime/heap/ch1_prespective_of_system_buttom/off_heap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/heap/ch1_prespective_of_system_buttom/off_heap/</guid><description/></item><item><title>概述</title><link>https://zput.github.io/go-goroutine/docs/runtime/heap/ch1_prespective_of_system_buttom/on_heap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/heap/ch1_prespective_of_system_buttom/on_heap/</guid><description/></item><item><title/><link>https://zput.github.io/go-goroutine/docs/foundation/directory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/foundation/directory/</guid><description>func executeDir() string { ex, err := os.Executable() if err != nil { panic(err) } exPath := filepath.Dir(ex) fmt.Println(exPath) return exPath } func getwd() string { // using the function mydir, err := os.Getwd() if err != nil { fmt.Println(err) } fmt.Println(mydir) return mydir }</description></item></channel></rss>