---
title: part1:进入main函数之前的初始化
date: 2020-01-20 10:03:00
tags:
  - golang
  - goroutine
categories:
    - golang调度
toc: true
---

## 例子

我们首先来gdb调试一下这个程序

> main.go

```go
package main

import "fmt"

// the function's body is empty
func add(x, y int64) int64

func main() {
    gg:=add(2, 3)
    fmt.Println(gg)
}
```

> add_amd.s

```go
TEXT ·add(SB),$0-24
	MOVQ x+0(FP), BX
	MOVQ y+8(FP), BP
	ADDQ BP, BX
	MOVQ BX, ret+16(FP)
	RET
```

编译一下源代码: ```go build  -gcflags "-N -l" -o test .```.


### 程序加载到内存入口

![20200907142246](https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20200907142246.png)

```sh
(gdb) info files
Symbols from "/tmp/kubernets/test".
Local exec file:
	`/tmp/kubernets/test', file type elf64-x86-64.
	Entry point: 0x454e00
	0x0000000000401000 - 0x000000000048cfd3 is .text
	0x000000000048d000 - 0x00000000004dc550 is .rodata
	0x00000000004dc720 - 0x00000000004dd38c is .typelink
	0x00000000004dd390 - 0x00000000004dd3e0 is .itablink
	0x00000000004dd3e0 - 0x00000000004dd3e0 is .gosymtab
	0x00000000004dd3e0 - 0x0000000000548adf is .gopclntab
	0x0000000000549000 - 0x0000000000549020 is .go.buildinfo
	0x0000000000549020 - 0x0000000000556118 is .noptrdata
	0x0000000000556120 - 0x000000000055d110 is .data
	0x000000000055d120 - 0x0000000000578990 is .bss
	0x00000000005789a0 - 0x000000000057b108 is .noptrbss
	0x0000000000400f9c - 0x0000000000401000 is .note.go.buildid
```

```sh
(gdb) b *0x454e00
Breakpoint 1 at 0x454e00: file /usr/lib/golang/src/runtime/rt0_linux_amd64.s, line 8. //跳到这个文件来了
(gdb) list /usr/lib/golang/src/runtime/rt0_linux_amd64.s:1
1	// Copyright 2009 The Go Authors. All rights reserved.
2	// Use of this source code is governed by a BSD-style
3	// license that can be found in the LICENSE file.
4
5	#include "textflag.h"
6
7	TEXT _rt0_amd64_linux(SB),NOSPLIT,$-8
8		JMP	_rt0_amd64(SB)
```

```sh
(gdb) run
Starting program: /tmp/kubernets/test

Breakpoint 1, _rt0_amd64_linux () at /usr/lib/golang/src/runtime/rt0_linux_amd64.s:8 //跳到这个文件来了
8		JMP	_rt0_amd64(SB)

(gdb) info registers bp
bp             0x0	0
(gdb) info registers sp
sp             0x7fffffffe4d0	0x7fffffffe4d0
```

```sh
(gdb) next
16		LEAQ	8(SP), SI	// argv
(gdb) list
11	// internal linking. This is the entry point for the program from the
12	// kernel for an ordinary -buildmode=exe program. The stack holds the
13	// number of arguments and the C-style argv.
14	TEXT _rt0_amd64(SB),NOSPLIT,$-8
15		MOVQ	0(SP), DI	// argc
16		LEAQ	8(SP), SI	// argv
17		JMP	runtime·rt0_go(SB)
(gdb) next
runtime.rt0_go () at /usr/lib/golang/src/runtime/asm_amd64.s:89 //跳到这个文件来了
89		MOVQ	DI, AX		// argc
(gdb) list
84	DATA _rt0_amd64_lib_argv<>(SB)/8, $0
85	GLOBL _rt0_amd64_lib_argv<>(SB),NOPTR, $8
86
87	TEXT runtime·rt0_go(SB),NOSPLIT,$0
88		// copy arguments forward on an even stack
89		MOVQ	DI, AX		// argc
90		MOVQ	SI, BX		// argv
91		SUBQ	$(4*8+7), SP		// 2args 2auto
92		ANDQ	$~15, SP
93		MOVQ	AX, 16(SP)
```

> 从上面的调试来看,最终到到达了```src/runtime/asm_amd64.s:89```的[runtime.rt0_go](https://github.com/golang/go/blob/93810ac1f4574e1e2a79ea156781bafaf8b8ebe0/src/runtime/asm_amd64.s#L87)函数.

```sh
file /usr/lib/golang/src/runtime/rt0_linux_amd64.s, line 8. //跳到这个文件来
_rt0_amd64_linux () at /usr/lib/golang/src/runtime/rt0_linux_amd64.s:8 //跳到这个文件来
runtime.rt0_go () at /usr/lib/golang/src/runtime/asm_amd64.s:89 //跳到这个文件来
```



### 进行初始化全局变量

主要是```rt0_go()```函数

#### 初始化全局变量g0

```go
TEXT runtime·rt0_go(SB),NOSPLIT,$0
	// copy arguments forward on an even stack
	MOVQ	DI, AX		// argc
	MOVQ	SI, BX		// argv
	SUBQ	$(4*8+7), SP		// 2args 2auto
	ANDQ	$~15, SP
	MOVQ	AX, 16(SP)
    MOVQ	BX, 24(SP)
    
    //TODO zxc 调整栈顶寄存器使其按16字节对齐; argc放在SP + 16字节处; argv放在SP + 24字节处

	// create istack out of the given (operating system) stack.
	// _cgo_init may update stackguard.
	MOVQ	$runtime·g0(SB), DI     //全局的变量g0的地址放入DI寄存器
	LEAQ	(-64*1024+104)(SP), BX
	MOVQ	BX, g_stackguard0(DI)
	MOVQ	BX, g_stackguard1(DI)
	MOVQ	BX, (g_stack+stack_lo)(DI)
	MOVQ	SP, (g_stack+stack_hi)(DI)
    
    // TODO zxc 始初始化全局变量g0, g0的栈大约有64K，地址范围为 SP - 64*1024 + 104 ～ SP

    /*
    ...省略一些CPU相关的汇编
    */

	LEAQ	runtime·m0+m_tls(SB), DI  // //DI = &m0.tls，取m0的tls成员的地址到DI寄存器
	CALL	runtime·settls(SB)        // 调用settls设置线程本地存储，settls函数的参数在DI寄存器中
	// store through it, to make sure it works // 可以看做是单元测试
	get_tls(BX)
	MOVQ	$0x123, g(BX)
	MOVQ	runtime·m0+m_tls(SB), AX
	CMPQ	AX, $0x123
	JEQ 2(PC)
	CALL	runtime·abort(SB)
```

分析下这个```runtime·settls()```函数,因为这个ELF需要-8,所以提前+8,那么最终执行完这个函数,它是设置在全局的m0的tls[0]里面,还是tls[1]里面呢?
观察下这个```MOVQ	runtime·m0+m_tls(SB), AX```,可以知道就是m0中的tls[0]的地址





```go
// set tls base to DI
TEXT runtime·settls(SB),NOSPLIT,$32
	ADDQ	$8, DI	// ELF wants to use -8(FS) //因为后面要-8,所以先加+8
	MOVQ	DI, SI  // is SI parameter?
	MOVQ	$0x1002, DI	// ARCH_SET_FS
	MOVQ	$SYS_arch_prctl, AX
	SYSCALL
	CMPQ	AX, $0xfffffffffffff001
	JLS	2(PC)
	MOVL	$0xf1, 0xf1  // crash
	RET
```

> 只是一个宏定义```src/runtime/go_tls.h```,```get_tls(BX)```把TLS地址放入BX寄存器.

```go
#ifdef GOARCH_amd64
#define	get_tls(r)	MOVQ TLS, r
#define	g(r)	0(r)(TLS*1)
#endif
```

```go
	// Thread-local storage references use the TLS pseudo-register.
	// As a register, TLS refers to the thread-local storage base, and it
	// can only be loaded into another register:
	//
	//         MOVQ TLS, AX
	//
	// An offset from the thread-local storage base is written off(reg)(TLS*1).
	// Semantically it is off(reg), but the (TLS*1) annotation marks this as
	// indexing from the loaded TLS base. This emits a relocation so that
	// if the linker needs to adjust the offset, it can. For example:
	//
	//         MOVQ TLS, AX
	//         MOVQ 0(AX)(TLS*1), CX // load g into CX
	//
	// On systems that support direct access to the TLS memory, this
	// pair of instructions can be reduced to a direct TLS memory reference:
	//
	//         MOVQ 0(TLS), CX // load g into CX
	//
	// The 2-instruction and 1-instruction forms correspond to the two code
	// sequences for loading a TLS variable in the local exec model given in "ELF
	// Handling For Thread-Local Storage".



			// When building for inclusion into a shared library, an instruction of the form
			//     MOV off(CX)(TLS*1), AX
			// becomes
			//     mov %fs:off(%rcx), %rax
			// which assumes that the correct TLS offset has been loaded into %rcx (today
			// there is only one TLS variable -- g -- so this is OK). When not building for
			// a shared library the instruction does not require a prefix.
```

#### m0和g0绑定在一起

我们继续下面的```runtime·rt0_go```函数.

```go
ok:
	// set the per-goroutine and per-mach "registers"
	get_tls(BX)
	LEAQ	runtime·g0(SB), CX //取的g0的在堆上的地址放入CX-->CX = g0的地址
	MOVQ	CX, g(BX)          //把g0的地址保存在线程本地存储里面，也就是*TLS=&g0 --> m0.tls[0]=&g0
	LEAQ	runtime·m0(SB), AX //AX=&m0

	// save m->g0 = g0
	MOVQ	CX, m_g0(AX)
	// save m0 to g0->m
    MOVQ	AX, g_m(CX)
```

m0和g0绑定在一起，这样，之后在主线程中通过get_tls可以获取到g0，通过g0的m成员又可以找到m0，于是这里就实现了m0和g0与主线程之间的关联。
从这里还可以看到，保存在主线程本地存储中的值是g0的地址，也就是说工作线程的私有全局变量其实是一个指向g的指针而不是指向m的指针

![20200907151844](https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20200907151844.png)



#### 设置一些ncpu(CPU核数), M,P的个数, 初始化m0

我们继续下面的```runtime·rt0_go```函数.

```go
  	CLD				// convention is D is always left cleared 不需要关心
	CALL	runtime·check(SB) //不需要关心

	MOVL	16(SP), AX		// copy argc;  AX = argc
	MOVL	AX, 0(SP)       // argc放在栈顶
	MOVQ	24(SP), AX		// copy argv;  AX = argv
	MOVQ	AX, 8(SP)       // argv放在SP + 8的位置
	CALL	runtime·args(SB)
	CALL	runtime·osinit(SB) //全局变量 ncpu = CPU核数
    CALL	runtime·schedinit(SB)
```

##### schedinit

schedinit主要是进行一些初始化工作, 必过设置M的最大个数,P的个数,还有初始化这m0,另外这个getg()也很有趣,分为our G, system G

> [sr/runtime/proc.go](https://github.com/golang/go/blob/5c2c6d3fbf4f0a1299b5e41463847d242eae19ca/src/runtime/proc.go#L535)

```go
// The bootstrap sequence is:
//
//	call osinit
//	call schedinit
//	make & queue new G
//	call runtime·mstart
//
// The new G calls runtime·main.
func schedinit() {
	// raceinit must be the first call to race detector.
	// In particular, it must be done before mallocinit below calls racemapshadow.
    _g_ := getg()
    /*
    getg函数在源代码中没有对应的定义，由编译器插入类似下面两行代码
    get_tls(CX) // CX=TLS
    MOVQ g(CX), BX; BX存器里面现在放的是当前g结构体对象的地址
    可以参考这个,根据https://github.com/golang/go/blob/d029058b5912312963225c40ae4bf44e3cb4be76/src/runtime/HACKING.md
    */

    //...
	sched.maxmcount = 10000 // 最多启动10000个操作系统线程，也是最多10000个M
    //...

    mcommoninit(_g_.m) //初始化m0，因为从前面的代码我们知道g0->m = &m0
    //...
	procs := ncpu  //系统中有多少核，就创建和初始化多少个p结构体对象
	if n, ok := atoi32(gogetenv("GOMAXPROCS")); ok && n > 0 {
		procs = n  //如果指定了GOMAXPROCS大于0，则创建指定数量的p
	}
	if procresize(procs) != nil {
		throw("unknown runnable goroutine during bootstrap")
    }
    //...
}
```

###### mcommoninit

> mcommoninit主要是判断m是否超过个数,然后放入全局m链表,防止垃圾回收

```go
m0.p = allp[0]
allp[0].m = &m0
```

> [sr/runtime/proc.go](https://github.com/golang/go/blob/5c2c6d3fbf4f0a1299b5e41463847d242eae19ca/src/runtime/proc.go#L641)

```go
func mcommoninit(mp *m) {
	_g_ := getg()

	// g0 stack won't make sense for user (and is not necessary unwindable).
	if _g_ != _g_.m.g0 {
		callers(1, mp.createstack[:])
	}

	lock(&sched.lock)
	if sched.mnext+1 < sched.mnext {
		throw("runtime: thread ID overflow")
	}
	mp.id = sched.mnext
	sched.mnext++
	checkmcount() //检查m的个数是否超过sched.maxmcoun

    //...

	// Add to allm so garbage collector doesn't free g->m
	// when it is just in a register or thread-local storage.
	mp.alllink = allm //m放入全局链表allm, 防止垃圾回收

	// NumCgoCall() iterates over allm w/o schedlock,
	// so we need to publish it safely.
	atomicstorep(unsafe.Pointer(&allm), unsafe.Pointer(mp))
	unlock(&sched.lock)
    //...
}
```

###### 初始化allp, m0和allp[0]绑定

> procresize函数，我们先看下初始化时会执行的代码路径.
>> 考虑到初始化完成之后, 用户代码还可以通过```GOMAXPROCS()```函数调用它重新创建和初始化p结构体对象，我们首先只考虑初始化.

- 使用```make([]*p, nprocs)```初始化全局变量```allp```，把旧的allp拷贝到新的nallp里面,然后```allp = make([]*p, nprocs)```
- 循环```allp```中的每个p,如果是nill的就进行创建, 然后每个都初始化,不管是新的还是旧的.
- 把```m0```和```allp[0]```绑定在一起，即```m0.p = allp[0], allp[0].m = m0```
- 把除了```allp[0]```之外的所有```p```放入到全局变量```sched```的```pidle```空闲队列之中

> [src/runtime/proc.go](https://github.com/golang/go/blob/5c2c6d3fbf4f0a1299b5e41463847d242eae19ca/src/runtime/proc.go#L4319)

```go
func procresize(nprocs int32) *p {
    old := gomaxprocs //系统初始化时 gomaxprocs = 0
	if old < 0 || nprocs <= 0 {
		throw("procresize: invalid arg")
	}
    //...

    // Grow allp if necessary.
    if nprocs > int32(len(allp)) { //初始化时 len(allp) == 0
        // Synchronize with retake, which could be running
        // concurrently since it doesn't run on a P.
        lock(&allpLock)
        if nprocs <= int32(cap(allp)) {
            allp = allp[:nprocs]
        } else { //初始化时进入此分支，创建allp 切片
            nallp := make([]*p, nprocs)
            // Copy everything up to allp's cap so we
            // never lose old allocated Ps.
            copy(nallp, allp[:cap(allp)]) //把旧的allp拷贝到新的nallp里面
            allp = nallp
        }
        unlock(&allpLock)
    }

	// initialize new P's
	for i := old; i < nprocs; i++ {
		pp := allp[i]
		if pp == nil {
			pp = new(p)
		}
		pp.init(i) //每个p然后进行初始化 旧的也需要重新进行初始化
		atomicstorep(unsafe.Pointer(&allp[i]), unsafe.Pointer(pp))
	}
    //...

    _g_ := getg()  // _g_ = g0
    if _g_.m.p != 0 && _g_.m.p.ptr().id < nprocs {//初始化时m0->p还未初始化，所以不会执行这个分支
        // continue to use the current P
        _g_.m.p.ptr().status = _Prunning
        _g_.m.p.ptr().mcache.prepareForSweep()
    } else {//初始化时执行这个分支
        // release the current P and acquire allp[0]
        if _g_.m.p != 0 {//初始化时这里不执行
            _g_.m.p.ptr().m = 0
        }
        _g_.m.p = 0
        _g_.m.mcache = nil
        p := allp[0]
        p.m = 0
        p.status = _Pidle
        acquirep(p) // --> Associate p and the current m; 在初始化的时候就是把p和m0关联起来,其实是这两个strct的成员相互赋值
        if trace.enabled {
            traceGoStart()
        }
	}
	
	// release resources from unused P's --> zxc 就是释放多余的P
	for i := nprocs; i < old; i++ {
		p := allp[i]
		p.destroy()
		// TODO zxc can't free P itself because it can be referenced by an M in syscall
	}

    //下面这个for 循环把所有空闲的p放入空闲链表
    var runnablePs *p
    for i := nprocs - 1; i >= 0; i-- {
        p := allp[i]
        if _g_.m.p.ptr() == p {//不放allp[0],因为它跟m0在上面已经关联了
            continue
        }
        p.status = _Pidle
        if runqempty(p) {//初始化时除了allp[0]其它p全部执行这个分支，放入空闲链表
            pidleput(p)
        } else {
            //...
        }
    }
    //...
    return runnablePs
}
```

![内存关系图](https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20200907153347.png)


#### 创造一个将要运行```runtime·mainPC```的goroutine

我们继续下面的[runtime·rt0_go](https://github.com/golang/go/blob/93810ac1f4574e1e2a79ea156781bafaf8b8ebe0/src/runtime/asm_amd64.s#L87)函数.

```go
	// create a new goroutine to start program
	MOVQ	$runtime·mainPC(SB), AX// entry
	PUSHQ	AX
	PUSHQ	$0// arg size
	CALL	runtime·newproc(SB)
	POPQ	AX
```

![main goroutine,第一条指令](https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20200909112003.png)

##### newproc

> [src/runtime/proc.go](https://github.com/golang/go/blob/93810ac1f4574e1e2a79ea156781bafaf8b8ebe0/src/runtime/proc.go#L3528)

```go
// Create a new g running fn with siz bytes of arguments.
// Put it on the queue of g's waiting to run.
// The compiler turns a go statement into a call to this.
// Cannot split the stack because it assumes that the arguments
// are available sequentially after &fn; they would not be
// copied if a stack split occurred.
//go:nosplit
func newproc(siz int32, fn *funcval) {
	argp := add(unsafe.Pointer(&fn), sys.PtrSize)
	gp := getg()
	pc := getcallerpc() //getcallerpc:返回其调用者的程序计数器（PC）---getcallersp返回其调用者的堆栈指针（SP）
	systemstack(func() {  // systemstack 切到g0的栈和CPU寄存器去执行, 执行完了, 再切换原来的栈和CPU寄存器
		newproc1(fn, (*uint8)(argp), siz, gp, pc) 
		 /*

		 创建一个新的g运行的fn，参数的字节数从argp开始; 
		 siz: 参数的大小
		 callergp: 调用者的goroutine pointer[caller-callee]
		 callerpc: 调用者的程序计数器
		 */ 
	})
}

// Create a new g running fn with narg bytes of arguments starting
// at argp. callerpc is the address of the go statement that created
// this. The new g is put on the queue of g's waiting to run.
func newproc1(fn *funcval, argp *uint8, narg int32, callergp *g, callerpc uintptr) {
	_g_ := getg()

	if fn == nil {
		_g_.m.throwing = -1 // do not dump full stacks
		throw("go of nil func value")
	}
	acquirem() // disable preemption because it can be holding p in a local var // TODO zxc 禁止抢占
	siz := narg
	siz = (siz + 7) &^ 7

	// We could allocate a larger initial stack if necessary.
	// Not worth it: this is almost always an error.
	// 4*sizeof(uintreg): extra space added below
	// sizeof(uintreg): caller's LR (arm) or return address (x86, in gostartcall).
	if siz >= _StackMin-4*sys.RegSize-sys.RegSize {
		throw("newproc: function arguments too large for new goroutine")
	}

	_p_ := _g_.m.p.ptr() // 的到m上的p,在这里就是allp[0]
	newg := gfget(_p_) // 从本地或者全局队列尝试获取g
	if newg == nil {// 如果获取失败就构造一个g
		newg = malg(_StackMin) // 跳转到g0的栈,然后再堆上分配,
		casgstatus(newg, _Gidle, _Gdead) //_Gidle=iota //0 新创建的默认是0,所以就是idle;修改状态为Gdead,这样gc就是扫描newg上面的栈,来尝试要不要回收.
		allgadd(newg) // publishes with a g->status of Gdead so GC scanner doesn't look at uninitialized stack. 这里的把生成的g放入全局allgs []*g//保存所有的g
	}
```

![为main函数创建一个新的goroutine](https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20200907161241.png)



```go
	if newg.stack.hi == 0 {
		throw("newproc1: newg missing stack")
	}

	if readgstatus(newg) != _Gdead { //不是Gdead就panic
		throw("newproc1: new g is not Gdead")
	}

	totalSize := 4*sys.RegSize + uintptr(siz) + sys.MinFrameSize // extra space in case of reads slightly beyond frame
	totalSize += -totalSize & (sys.SpAlign - 1)                  // align to spAlign
	sp := newg.stack.hi - totalSize
	spArg := sp
	if usesLR {
		// caller's LR
		*(*uintptr)(unsafe.Pointer(sp)) = 0
		prepGoExitFrame(sp)
		spArg += sys.MinFrameSize
	}
	if narg > 0 {
		//memmove copies n bytes from "from" to "to",把在调用者的栈上的,callee
		memmove(unsafe.Pointer(spArg), unsafe.Pointer(argp), uintptr(narg))
		// This is a stack-to-stack copy. If write barriers
		// are enabled and the source stack is grey (the
		// destination is always black), then perform a
		// barrier copy. We do this *after* the memmove
		// because the destination stack may have garbage on
		// it.
		if writeBarrier.needed && !_g_.m.curg.gcscandone {
			f := findfunc(fn.fn)
			stkmap := (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps))
			if stkmap.nbit > 0 {
				// We're in the prologue, so it's always stack map index 0.
				bv := stackmapdata(stkmap, 0)
				bulkBarrierBitmap(spArg, spArg, uintptr(bv.n)*sys.PtrSize, 0, bv.bytedata)
			}
		}
	}

	memclrNoHeapPointers(unsafe.Pointer(&newg.sched), unsafe.Sizeof(newg.sched)) //newg.sched 空间置零
	newg.sched.sp = sp
	newg.stktopsp = sp
	newg.sched.pc = funcPC(goexit) + sys.PCQuantum // +PCQuantum=1 so that previous instruction is in same function
	newg.sched.g = guintptr(unsafe.Pointer(newg))
    gostartcallfn(&newg.sched, fn)
    /*      这个函数
			    1. 调整newg的栈空间，把goexit函数的第二条指令的地址入栈，伪造成goexit函数调用了fn，
			        从而使fn执行完成后执行ret指令时返回到goexit继续执行完成最后的清理工作；
			    2. 重新设置newg.buf.pc 为需要执行的函数的地址，即fn，我们这个场景为runtime.main函数的地址。

			// adjust Gobuf as if it executed a call to fn
			// and then did an immediate gosave.
			func gostartcallfn(gobuf *gobuf, fv *funcval) {
				var fn unsafe.Pointer
				if fv != nil {
					fn = unsafe.Pointer(fv.fn)
				} else {
					fn = unsafe.Pointer(funcPC(nilfunc))
				}
				gostartcall(gobuf, fn, unsafe.Pointer(fv))
			}

			// adjust Gobuf as if it executed a call to fn with context ctxt
			// and then did an immediate gosave.
			func gostartcall(buf *gobuf, fn, ctxt unsafe.Pointer) {
				sp := buf.sp
				if sys.RegSize > sys.PtrSize {
					sp -= sys.PtrSize
					*(*uintptr)(unsafe.Pointer(sp)) = 0
				}
				sp -= sys.PtrSize
				*(*uintptr)(unsafe.Pointer(sp)) = buf.pc
				buf.sp = sp
				buf.pc = uintptr(fn)
				buf.ctxt = ctxt
			}
    */
	newg.gopc = callerpc
	newg.ancestors = saveAncestors(callergp)
	newg.startpc = fn.fn

    //...
	casgstatus(newg, _Gdead, _Grunnable) //修改goroutine状态

	if _p_.goidcache == _p_.goidcacheend {
		// Sched.goidgen is the last allocated id,
		// this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].
		// At startup sched.goidgen=0, so main goroutine receives goid=1.
		_p_.goidcache = atomic.Xadd64(&sched.goidgen, _GoidCacheBatch)
		_p_.goidcache -= _GoidCacheBatch - 1
		_p_.goidcacheend = _p_.goidcache + _GoidCacheBatch
	}
	newg.goid = int64(_p_.goidcache)
	_p_.goidcache++
	if raceenabled {
		newg.racectx = racegostart(callerpc)
	}
	if trace.enabled {
		traceGoCreate(newg, newg.startpc)
	}
	runqput(_p_, newg, true) //放入本地队列， 或者全局队列  

	if atomic.Load(&sched.npidle) != 0 && atomic.Load(&sched.nmspinning) == 0 && mainStarted {
		wakep()
	}
	releasem(_g_.m)
} //end newproc1 function
```

![20200907185424](https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20200907185424.png)

![20200907194223](https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20200907194223.png)


###### rbp这个寄存器的值还有用?

> rbp这个寄存器的值,会保存到新创建的goroutine里的```sched.bp```字段?

```go
type g struct {
	stack       stack   // offset known to runtime/cgo
	stackguard0 uintptr // offset known to liblink
	stackguard1 uintptr // offset known to liblink

	_panic         *_panic // innermost panic - offset known to liblink
	_defer         *_defer // innermost defer
	m              *m      // current m; offset known to arm liblink
	sched          gobuf
	//...
}

type gobuf struct {
	sp   uintptr
	pc   uintptr
	g    guintptr
	ctxt unsafe.Pointer
	ret  sys.Uintreg
	lr   uintptr
	bp   uintptr // for GOEXPERIMENT=framepointer   ------------------------here
}
```

- 没有保存,当重新调度这个goroutine,```重新观察BP寄存器```这一章中我们会看到里面是空的
- ```进入main函数```里面有rpb是否会入栈


#### mstart

我们继续下面的[runtime·rt0_go](https://github.com/golang/go/blob/93810ac1f4574e1e2a79ea156781bafaf8b8ebe0/src/runtime/asm_amd64.s#L87)函数.


```go
	// start this M
	CALL	runtime·mstart(SB)

	CALL	runtime·abort(SB)	// mstart should never return
	RET

	// Prevent dead-code elimination of debugCallV1, which is
	// intended to be called by debuggers.
	MOVQ	$runtime·debugCallV1(SB), AX
    RET
```

```go
// mstart is the entry-point for new Ms.
//
// This must not split the stack because we may not even have stack
// bounds set up yet.
//
// May run during STW (because it doesn't have a P yet), so write
// barriers are not allowed.
//
//go:nosplit
//go:nowritebarrierrec
func mstart() {
	_g_ := getg()  // g0

	osStack := _g_.stack.lo == 0
	/*  ? linux的话， 从runtime·rt0_go我们知道，g0的stack.lo,不是为0的.
		// create istack out of the given (operating system) stack.
		// _cgo_init may update stackguard.
		MOVQ	$runtime·g0(SB), DI
		LEAQ	(-64*1024+104)(SP), BX
		MOVQ	BX, g_stackguard0(DI)
		MOVQ	BX, g_stackguard1(DI)
		MOVQ	BX, (g_stack+stack_lo)(DI)
		MOVQ	SP, (g_stack+stack_hi)(DI)
	*/
	if osStack {
		// Initialize stack bounds from system stack.
		// Cgo may have left stack size in stack.hi.
		// minit may update the stack bounds.
		size := _g_.stack.hi
		if size == 0 {
			size = 8192 * sys.StackGuardMultiplier
		}
		_g_.stack.hi = uintptr(noescape(unsafe.Pointer(&size)))
		_g_.stack.lo = _g_.stack.hi - size + 1024
	}
	// Initialize stack guard so that we can start calling regular
	// Go code.
	_g_.stackguard0 = _g_.stack.lo + _StackGuard  //这个stackguard0比stack.lo大，防止越界
	// This is the g0, so we can also call go:systemstack
	// functions, which check stackguard1.
	_g_.stackguard1 = _g_.stackguard0 //stackguard1的作用是栈溢出检查，如果是stackguard0与stackguard1相等，那么是不能放数据到g0栈中了吗
	mstart1()

	// Exit this thread.
	if GOOS == "windows" || GOOS == "solaris" || GOOS == "illumos" || GOOS == "plan9" || GOOS == "darwin" || GOOS == "aix" {
		// Windows, Solaris, illumos, Darwin, AIX and Plan 9 always system-allocate
		// the stack, but put it in _g_.stack before mstart,
		// so the logic above hasn't set osStack yet.
		osStack = true
	}
	mexit(osStack)
}

func mstart1() {
	_g_ := getg()   //g0

	if _g_ != _g_.m.g0 {
		throw("bad runtime·mstart")
	}

	// Record the caller for use as the top of stack in mcall and
	// for terminating the thread.
	// We're never coming back to mstart1 after we call schedule,
	// so other calls can reuse the current frame.
	save(getcallerpc(), getcallersp()) //就是把pc, sp保存到自己的sched里面， 但是bp寄存器没有保存，因为会重新使用这个栈？
	/*
	TODO zxc 这里为什么不是当前的, gdb查看下.
		getcallerpc()返回的是mstart调用mstart1时被call指令压栈的返回地址， bp+1 ?
		getcallersp()函数返回的是调用mstart1函数之前mstart函数的栈顶地址    bp ?
	*/
	asminit()
	minit() //初始化信号

	// Install signal handlers; after minit so that minit can
	// prepare the thread to be able to handle the signals.
	// 安装信号处理程序;所以minit可以准备线程以便能够处理信号, 在minit之后执行
	if _g_.m == &m0 {
		mstartm0()
	}

	if fn := _g_.m.mstartfn; fn != nil {   //如果m的mstartfn不是空的，先执行它
		fn()
	}

	if _g_.m != &m0 { // 如果m不等于m0  就是m0的话,前面m0和allp[0]已经绑定了
		acquirep(_g_.m.nextp.ptr()) //TODO zxc 这个acquirep函数是把m和m.nextp进行绑定,如果到这里的时候,nextp已经状态不是空闲的状态,
		                            //那么会抛出错误?
		_g_.m.nextp = 0
	}
	schedule() //进入调度
}
```


##### save函数保存pc,sp到g0,方便下次再度调度运行g0

```sh
list /usr/lib/golang/src/runtime/proc.go:1167
list /usr/lib/golang/src/runtime/proc.go:1179
list /usr/lib/golang/src/runtime/proc.go:1190
```

```asm
[root@gitlab kubernets]# gdb test
GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-119.el7
Copyright (C) 2013 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-redhat-linux-gnu".
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>...
Reading symbols from /tmp/kubernets/test...done.
Loading Go Runtime support.
(gdb) list /usr/lib/golang/src/runtime/proc.go:1167
1162		// Go code.
1163		_g_.stackguard0 = _g_.stack.lo + _StackGuard
1164		// This is the g0, so we can also call go:systemstack
1165		// functions, which check stackguard1.
1166		_g_.stackguard1 = _g_.stackguard0
1167		mstart1()
1168
1169		// Exit this thread.
1170		if GOOS == "windows" || GOOS == "solaris" || GOOS == "illumos" || GOOS == "plan9" || GOOS == "darwin" || GOOS == "aix" {
1171			// Windows, Solaris, illumos, Darwin, AIX and Plan 9 always system-allocate
(gdb) b 1167
Breakpoint 1 at 0x42dd09: file /usr/lib/golang/src/runtime/proc.go, line 1167.
(gdb) list /usr/lib/golang/src/runtime/proc.go:1179
1174			osStack = true
1175		}
1176		mexit(osStack)
1177	}
1178
1179	func mstart1() {
1180		_g_ := getg()
1181
1182		if _g_ != _g_.m.g0 {
1183			throw("bad runtime·mstart")
(gdb) b 1179
Breakpoint 2 at 0x42dd30: file /usr/lib/golang/src/runtime/proc.go, line 1179.
(gdb) list /usr/lib/golang/src/runtime/proc.go:1190
1185
1186		// Record the caller for use as the top of stack in mcall and
1187		// for terminating the thread.
1188		// We're never coming back to mstart1 after we call schedule,
1189		// so other calls can reuse the current frame.
1190		save(getcallerpc(), getcallersp())
1191		asminit()
1192		minit()
1193
1194		// Install signal handlers; after minit so that minit can
(gdb) b 1190
Breakpoint 3 at 0x42dd7f: file /usr/lib/golang/src/runtime/proc.go, line 1190.
(gdb) info breakpoint
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x000000000042dd09 in runtime.mstart at /usr/lib/golang/src/runtime/proc.go:1167
2       breakpoint     keep y   0x000000000042dd30 in runtime.mstart1 at /usr/lib/golang/src/runtime/proc.go:1179
3       breakpoint     keep y   0x000000000042dd7f in runtime.mstart1 at /usr/lib/golang/src/runtime/proc.go:1190
(gdb) run
Starting program: /tmp/kubernets/test

Breakpoint 1, runtime.mstart () at /usr/lib/golang/src/runtime/proc.go:1167
1167		mstart1()
(gdb) list
1162		// Go code.
1163		_g_.stackguard0 = _g_.stack.lo + _StackGuard
1164		// This is the g0, so we can also call go:systemstack
1165		// functions, which check stackguard1.
1166		_g_.stackguard1 = _g_.stackguard0
1167		mstart1()
1168
1169		// Exit this thread.
1170		if GOOS == "windows" || GOOS == "solaris" || GOOS == "illumos" || GOOS == "plan9" || GOOS == "darwin" || GOOS == "aix" {
1171			// Windows, Solaris, illumos, Darwin, AIX and Plan 9 always system-allocate
(gdb) info register rbp rsp pc
rbp            0x7fffffffe490	0x7fffffffe490
rsp            0x7fffffffe478	0x7fffffffe478
pc             0x42dd09	0x42dd09 <runtime.mstart+105>
(gdb) continue
Continuing.

Breakpoint 2, runtime.mstart1 () at /usr/lib/golang/src/runtime/proc.go:1179
1179	func mstart1() {
(gdb) info register rbp rsp pc
rbp            0x7fffffffe490	0x7fffffffe490
rsp            0x7fffffffe470	0x7fffffffe470
pc             0x42dd30	0x42dd30 <runtime.mstart1>
(gdb) x/8xb 0x7fffffffe470
0x7fffffffe470:	0x0e	0xdd	0x42	0x00	0x00	0x00	0x00	0x00
(gdb) info frame 0
Stack frame at 0x7fffffffe478:
 rip = 0x42dd30 in runtime.mstart1 (/usr/lib/golang/src/runtime/proc.go:1179); saved rip 0x42dd0e
 called by frame at 0x7fffffffe4a0
 source language unknown.
 Arglist at 0x7fffffffe468, args:
 Locals at 0x7fffffffe468, Previous frame's sp is 0x7fffffffe478
 Saved registers:
  rip at 0x7fffffffe470
(gdb)
```

###### 反汇编看下mstart1到save函数的汇编代码

```asm
(gdb) disass
Dump of assembler code for function runtime.mstart1:
=> 0x000000000042dd30 <+0>:	mov    %fs:0xfffffffffffffff8,%rcx // rcx = &g0
   0x000000000042dd39 <+9>:	cmp    0x10(%rcx),%rsp             // g0.stackguard0与rsp(0x7fffffffe470)判断是否达到栈顶部
   0x000000000042dd3d <+13>:	jbe    0x42de2e <runtime.mstart1+254>  // jump below equal <=, 就panic
   0x000000000042dd43 <+19>:	sub    $0x20,%rsp // rsp=0x7fffffffe470-0x20=0x7fffffffe450
   0x000000000042dd47 <+23>:	mov    %rbp,0x18(%rsp) //rsp(0x7fffffffe450)+0x18 = rbp ==> caller's栈底(rbp)入callee的栈
   /*
		 (gdb) x/8xb 0x7fffffffe468
		0x7fffffffe468:	0x90	0xe4	0xff	0xff	0xff	0x7f	0x00	0x00 
		从前面 info register rbp rsp pc返回可以看到,就是rbp的值
   */
   0x000000000042dd4c <+28>:	lea    0x18(%rsp),%rbp //取地址不取引用,得到rbp=0x7fffffffe468; 所以callee[mstart1函数]新的栈底rbp就指向这
   /*
		 (gdb) info register rbp
		rbp            0x7fffffffe468	0x7fffffffe468
   */
   0x000000000042dd51 <+33>:	mov    %fs:0xfffffffffffffff8,%rax // rax = &g0
   0x000000000042dd5a <+42>:	mov    0x30(%rax),%rcx //rcx = g0.m.g0
   0x000000000042dd5e <+46>:	cmp    %rax,(%rcx)     // g0是否与g0.m.g0相等
   0x000000000042dd61 <+49>:	jne    0x42de14 <runtime.mstart1+228> //跳转到...如果不等于
   0x000000000042dd67 <+55>:	mov    %rax,0x10(%rsp) // rsp(0x7fffffffe450)+0x10 = 0x7fffffffe460的地方保存g0的地址

   0x000000000042dd6c <+60>:	mov    0x20(%rsp),%rax //rsp(0x7fffffffe450)+0x20 = 0x7fffffffe470的地址内容放到rax //这里就是caller's pc
   0x000000000042dd71 <+65>:	mov    %rax,(%rsp) //所以从下面可以看出0x7fffffffe470与0x7fffffffe450内容是一样的都是caller's pc
   0x000000000042dd75 <+69>:	lea    0x28(%rsp),%rax //rsp(0x7fffffffe450)+0x28 = 0x7fffffffe478这个值,不是里面的值放到rax
   0x000000000042dd7a <+74>:	mov    %rax,0x8(%rsp) //rsp(0x7fffffffe450)+0x8 = 0x7fffffffe458 ==>所以这个go语言里面的sp是从自调用返回后,sp里的值,它不包括caller调用callee的时候,call指令临时保存的pc,所以地址是0x7fffffffe478而不是0x7fffffffe470
   /*
		 (gdb) info register rsp
		rsp            0x7fffffffe450	0x7fffffffe450
		(gdb) x/64xb 0x7fffffffe450
		0x7fffffffe450:	0x0e	0xdd	0x42	0x00	0x00	0x00	0x00	0x00 //caller's pc
		0x7fffffffe458:	0x78	0xe4	0xff	0xff	0xff	0x7f	0x00	0x00 //caller's sp
		0x7fffffffe460:	0xc0	0xda	0x55	0x00	0x00	0x00	0x00	0x00 //局部变量_g_也就是全局变量g0的地址
		0x7fffffffe468:	0x90	0xe4	0xff	0xff	0xff	0x7f	0x00	0x00 // caller's rbp
		0x7fffffffe470:	0x0e	0xdd	0x42	0x00	0x00	0x00	0x00	0x00 // caller's pc
		0x7fffffffe478:	0x74	0x15	0x45	0x00	0x00	0x00	0x00	0x00
		0x7fffffffe480:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
		0x7fffffffe488:	0x08	0xe5	0xfe	0xff	0xff	0x7f	0x00	0x00 
   */
   0x000000000042dd7f <+79>:	callq  0x431bd0 <runtime.save> // save(getcallerpc(), getcallersp())
```

![gdb调试的时候发现,info frame中sp没有包括pc](https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20200908170921.png)

![20200908193623](https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20200908193623.png)

![mstart1函数,到保存pc,sp到g0](https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20200908200455.png)


#####  schedule

```go

// One round of scheduler: find a runnable goroutine and execute it.
// Never returns.
func schedule() {
	_g_ := getg() // get g0

	//....

top:
	//...

	var gp *g
	var inheritTime bool

	// Normal goroutines will check for need to wakeP in ready,
	// but GCworkers and tracereaders will not, so the check must
	// be done here instead.
	tryWakeP := false //一般的goroutines会在准备好的时候检查是否需要wakeP。gcworker, tracereaders需要现在唤醒P.
	if trace.enabled || trace.shutdown {
		gp = traceReader()
		if gp != nil {
			casgstatus(gp, _Gwaiting, _Grunnable)
			traceGoUnpark(gp, 0)
			tryWakeP = true
		}
	}
	if gp == nil && gcBlackenEnabled != 0 {
		gp = gcController.findRunnableGCWorker(_g_.m.p.ptr())
		tryWakeP = tryWakeP || gp != nil
	}
	if gp == nil {
		// Check the global runnable queue once in a while to ensure fairness.
		// Otherwise two goroutines can completely occupy the local runqueue
		// by constantly respawning each other.
		if _g_.m.p.ptr().schedtick%61 == 0 && sched.runqsize > 0 {
			lock(&sched.lock)
			gp = globrunqget(_g_.m.p.ptr(), 1)
			unlock(&sched.lock)
		}
	}
	if gp == nil {
		gp, inheritTime = runqget(_g_.m.p.ptr())
		if gp != nil && _g_.m.spinning {
			throw("schedule: spinning with local work")
		}
	}
	if gp == nil {
		gp, inheritTime = findrunnable() // blocks until work is available
	}

	// This thread is going to run a goroutine and is not spinning anymore,
	// so if it was marked as spinning we need to reset it now and potentially
	// start a new spinning M.
	if _g_.m.spinning {
		resetspinning()
	}

	if sched.disable.user && !schedEnabled(gp) {
		// Scheduling of this goroutine is disabled. Put it on
		// the list of pending runnable goroutines for when we
		// re-enable user scheduling and look again.
		lock(&sched.lock)
		if schedEnabled(gp) {
			// Something re-enabled scheduling while we
			// were acquiring the lock.
			unlock(&sched.lock)
		} else {
			sched.disable.runnable.pushBack(gp)
			sched.disable.n++
			unlock(&sched.lock)
			goto top
		}
	}

	// If about to schedule a not-normal goroutine (a GCworker or tracereader),
	// wake a P if there is one.
	if tryWakeP { //a GCworker or tracereader,需要唤醒P
		if atomic.Load(&sched.npidle) != 0 && atomic.Load(&sched.nmspinning) == 0 {
			wakep()
		}
	}
	//...

	execute(gp, inheritTime) // 执行G
}
```

- schedule()函数主要是获取一个Goroutine.
  - schedule函数通过调用```globrunqget()```和```runqget()```函数分别从全局运行队列和当前工作线程的本地运行队列中选取下一个需要运行的goroutine;
  - 如果这两个队列都没有需要运行的goroutine则通过```findrunnable()```函数从其它p的运行队列中盗取goroutine.

- 一旦找到下一个需要运行的goroutine，则调用excute函数从g0切换到该goroutine去运行.
  - 否则```gp, inheritTime = findrunnable() // blocks until work is available```,一直阻塞在findrunnable()上面


###### execute函数

```go
// Schedules gp to run on the current M.
// If inheritTime is true, gp inherits the remaining time in the
// current time slice. Otherwise, it starts a new time slice.
// Never returns.
//
// Write barriers are allowed because this is called immediately after
// acquiring a P in several places.
//
//go:yeswritebarrierrec

func execute(gp *g, inheritTime bool) {
	_g_ := getg() // g0

	casgstatus(gp, _Grunnable, _Grunning) //修改将要运行的gp的状态.
	gp.waitsince = 0
	gp.preempt = false //抢占标志位
	gp.stackguard0 = gp.stack.lo + _StackGuard //设置栈顶的保护,比栈地址的最低位高点,防止栈越界
	if !inheritTime {
		_g_.m.p.ptr().schedtick++
	}
	_g_.m.curg = gp //这里就开始设置M的curg为gp,而不是g0了
	gp.m = _g_.m  // m.curg = gp and gp.m = m

	//...
	gogo(&gp.sched)
}
```

execute函数主要为将要被调度运行的gp设置状态,与M相互关联


###### gogo

寻找在那个文件里面:```list /usr/lib/golang/src/runtime/proc.go:2165```

> gdb查看发现又到了asm_amd64.s文件
```asm
(gdb) step
runtime.gogo () at /usr/lib/golang/src/runtime/asm_amd64.s:272
272	TEXT runtime·gogo(SB), NOSPLIT, $16-8
(gdb) list
```

```go
// func gogo(buf *gobuf)
// restore state from Gobuf; longjmp
TEXT runtime·gogo(SB), NOSPLIT, $16-8
	MOVQ	buf+0(FP), BX		// gobuf
	MOVQ	gobuf_g(BX), DX
	MOVQ	0(DX), CX		// make sure g != nil //防止g.gobuf.g里面的值是空的,空的取地址会panic
	get_tls(CX)
	MOVQ	DX, g(CX)
	MOVQ	gobuf_sp(BX), SP	// restore SP
	MOVQ	gobuf_ret(BX), AX
	MOVQ	gobuf_ctxt(BX), DX
	MOVQ	gobuf_bp(BX), BP
	MOVQ	$0, gobuf_sp(BX)	// clear to help garbage collector
	MOVQ	$0, gobuf_ret(BX)
	MOVQ	$0, gobuf_ctxt(BX)
	MOVQ	$0, gobuf_bp(BX)
	MOVQ	gobuf_pc(BX), BX
	JMP	BX
```

gogo把将要运行的main函数的goroutine从gobuf中取出到寄存器中,同时清0,有助于垃圾回收.

###### 重新观察BP寄存器

> 当调度这个main函数的goroutine,从g.sched中恢复的寄存器的值,其中恢复后BP寄存器的值就是0

```asm
(gdb) info breakpoints
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x000000000042fe3e in runtime.execute at /usr/lib/golang/src/runtime/proc.go:2171
	breakpoint already hit 1 time
2       breakpoint     keep y   0x00000000004515ce in runtime.gogo at /usr/lib/golang/src/runtime/asm_amd64.s:281
3       breakpoint     keep y   0x00000000004515d2 in runtime.gogo at /usr/lib/golang/src/runtime/asm_amd64.s:282
(gdb) run
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /tmp/kubernets/./test

Breakpoint 1, runtime.execute (gp=0xc000000300, inheritTime=true) at /usr/lib/golang/src/runtime/proc.go:2171
2171		gogo(&gp.sched)
(gdb) continue
Continuing.

Breakpoint 2, runtime.gogo () at /usr/lib/golang/src/runtime/asm_amd64.s:281
281		MOVQ	gobuf_bp(BX), BP //这里打了断点,观察下
(gdb) list
276		get_tls(CX)
277		MOVQ	DX, g(CX)
278		MOVQ	gobuf_sp(BX), SP	// restore SP
279		MOVQ	gobuf_ret(BX), AX
280		MOVQ	gobuf_ctxt(BX), DX
281		MOVQ	gobuf_bp(BX), BP     //这里打了断点,观察下  ------------------here
282		MOVQ	$0, gobuf_sp(BX)	 //这里打了断点,观察下  ------------------here
283		MOVQ	$0, gobuf_ret(BX)
284		MOVQ	$0, gobuf_ctxt(BX)
285		MOVQ	$0, gobuf_bp(BX)
(gdb) info register rbp rsp pc bp sp
rbp            0x7fffffffe3c8	0x7fffffffe3c8
rsp            0xc0000307d8	0xc0000307d8
pc             0x4515ce	0x4515ce <runtime.gogo+46>
bp             0xe3c8	-7224 //其值开始不是0  ------------------here
sp             0xc0000307d8	0xc0000307d8
(gdb) step

Breakpoint 3, runtime.gogo () at /usr/lib/golang/src/runtime/asm_amd64.s:282
282		MOVQ	$0, gobuf_sp(BX)	//这里打了断点,观察下
(gdb) info register rbp rsp pc bp sp
rbp            0x0	0x0
rsp            0xc0000307d8	0xc0000307d8
pc             0x4515d2	0x4515d2 <runtime.gogo+50>
bp             0x0	0//其值的确是为0  ------------------here
sp             0xc0000307d8	0xc0000307d8
(gdb)
```


 

### 进入main函数

> 文件里面```func main() {```:```list /usr/lib/golang/src/runtime/proc.go:113```
>> 我们打下断点到这个函数,然后查看它前几个汇编代码

```sh
(gdb) list /usr/lib/golang/src/runtime/proc.go:113
108
109	// Value to use for signal mask for newly created M's.
110	var initSigmask sigset
111
112	// The main goroutine.
113	func main() {
114		g := getg()
115
116		// Racectx of m0->g0 is used only as the parent of the main goroutine.
117		// It must not be used for anything else.
(gdb) b 113
Breakpoint 4 at 0x42aea0: file /usr/lib/golang/src/runtime/proc.go, line 113.
(gdb) c
Continuing.

Breakpoint 4, runtime.main () at /usr/lib/golang/src/runtime/proc.go:113
113	func main() {
(gdb) list
108
109	// Value to use for signal mask for newly created M's.
110	var initSigmask sigset
111
112	// The main goroutine.
113	func main() {
114		g := getg()
115
116		// Racectx of m0->g0 is used only as the parent of the main goroutine.
117		// It must not be used for anything else.
(gdb) info register rbp rsp pc bp sp
rbp            0x0	0x0
rsp            0xc0000307d8	0xc0000307d8
pc             0x42aea0	0x42aea0 <runtime.main>
bp             0x0	0
sp             0xc0000307d8	0xc0000307d8
(gdb) disas
Dump of assembler code for function runtime.main:
=> 0x000000000042aea0 <+0>:	    mov    %fs:0xfffffffffffffff8,%rcx
   0x000000000042aea9 <+9>:	    cmp    0x10(%rcx),%rsp
   0x000000000042aead <+13>:	jbe    0x42b1ea <runtime.main+842>
   0x000000000042aeb3 <+19>:	sub    $0x78,%rsp
   0x000000000042aeb7 <+23>:	mov    %rbp,0x70(%rsp)
   0x000000000042aebc <+28>:	lea    0x70(%rsp),%rbp
   0x000000000042aec1 <+33>:	mov    %fs:0xfffffffffffffff8,%rax
   0x000000000042aeca <+42>:	mov    %rax,0x68(%rsp)
   0x000000000042aecf <+47>:	mov    0x30(%rax),%rcx
   0x000000000042aed3 <+51>:	mov    (%rcx),%rcx
   0x000000000042aed6 <+54>:	movq   $0x0,0x130(%rcx)
   0x000000000042aee1 <+65>:	movq   $0x3b9aca00,0x11e234(%rip)        # 0x549120 <runtime.maxstacksize>
   0x000000000042aeec <+76>:	movb   $0x1,0x14dabc(%rip)        # 0x5789af <runtime.mainStarted>
```

- 前面三条我们前面详细解释过.
```
Dump of assembler code for function runtime.main:
=> 0x000000000042aea0 <+0>:	    mov    %fs:0xfffffffffffffff8,%rcx
   0x000000000042aea9 <+9>:	    cmp    0x10(%rcx),%rsp
   0x000000000042aead <+13>:	jbe    0x42b1ea <runtime.main+842>
```
- 虽然这个rbp是0,是空的,但是还是保存到栈里面去了.
```
   0x000000000042aeb3 <+19>:	sub    $0x78,%rsp
   0x000000000042aeb7 <+23>:	mov    %rbp,0x70(%rsp)
   0x000000000042aebc <+28>:	lea    0x70(%rsp),%rbp
```

















TODO systemstack

http://www.mit.edu/afs.new/sipb/project/golang/doc/asm.html























// ------------------- need deleted ----------------



// -------------------------------------------------------------
  // 获取课堂、作业完成情况
  rpc GetStudyReport (GetStudyReportRequest) returns (GetStudyReportResponse);
  // 获取课堂、作业完成情况Json
  rpc GetStudyReportJson (GetStudyReportRequest) returns (GetStudyReportResponse);
  // 通过分享ID, 获取课程报告情况
  rpc GetStudyReportByShare (GetStudyReportByShareRequest) returns (GetStudyReportResponse);
  // 通过分享ID, 获取课程报告情况Json
  rpc GetStudyReportByShareJson (GetStudyReportByShareRequest) returns (GetStudyReportResponse);

  //获取老师点评信息
  rpc GetCourseEvaluate (GetCourseEvaluateRequest) returns (GetCourseEvaluateResponse);
  //获取老师点评信息json
  rpc GetCourseEvaluateJson (GetCourseEvaluateRequest) returns (GetCourseEvaluateResponse);

project

//-------------------------------------------------------------

  //提交AI课任务中的工程  todo 9.2 zxc
  rpc SubmitAIMission (SubmitMissionProjectRequest) returns (SubmitMissionProjectResponse);

// -------------------------------------------------------------

  //获取工程信息
  rpc GetProjectInfo (GetProjectInfoRequest) returns (GetProjectInfoResponse);

  //获取工程信息by分享ID, 不需要token校验
  rpc GetTaskInClassByShare (GetTaskInClassByShareRequest) returns (GetTaskInClassByShareResponse);

  //获取工程信息by userID, serialID, courseID, missionID
  rpc GetProjectInfoByUnique (GetProjectInfoByUniqueRequest) returns (GetProjectInfoByUniqueResponse);


message GetCourseEvaluateResponse {
  Project project = 1; //工程信息
  repeated Comment comments = 2; //所有点评信息
  string shareUUID = 3; //如果分享课程报告出去,通过这个ID来获取工程详细信息.
}






//获取工程信息
func (p *AIProjectModel) GetProject(author uint32, seriesID uint32, courseID uint32) (define.RetCode, *worker.Project) {





// Array returns the optimal driver.Valuer and sql.Scanner for an array or
// slice of any dimension.
//
// For example:
//  db.Query(`SELECT * FROM t WHERE id = ANY($1)`, pq.Array([]int{235, 401}))
//
//  var x []sql.NullInt64
//  db.QueryRow('SELECT ARRAY[235, 401]').Scan(pq.Array(&x))
//
// Scanning multi-dimensional arrays is not supported.  Arrays where the lower
// bound is not one (such as `[0:0]={1}') are not supported.


	aiCommentProject := define.AICommentProject{
		ResourceID: resourceID,
		CoverURL:   coverUrl,
		ResourceIDs: resourceIDs,
	}







alter table ai_course_project
	add resource_ids integer[] default array[]::integer[]

alter table ai_course_project
	add read_aloud_time int default 0 not null;


alter table share_action_record
	add resource_ids integer[] default array[]::integer[]

alter table share_action_record
	add read_aloud_time int default 0 not null;












