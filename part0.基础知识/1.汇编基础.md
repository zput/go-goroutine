---
title: golang小工具函数
date: 2019-02-28 15:03:00
tags:
  - golang
  - goroutine
categories:
    - golang调度
toc: true
---

# go汇编



## 伪寄存器

[A Quick Guide to Go's Assembler](https://golang.org/doc/asm#symbols)

```go
FP: Frame pointer: arguments and locals.
PC: Program counter: jumps and branches.
SB: Static base pointer: global symbols.
SP: Stack pointer: top of stack.
```

- FP伪寄存器
  - FP伪寄存器： 用来标识函数参数、返回值
- SP有伪SP和硬件SP的区分：
  - 伪SP： 本地变量最高起始地址
  - 硬件SP： 函数栈真实栈顶地址
- SP与FP的关系
  - FP是访问入参、出参的基址，一般用**正向偏移**来寻址.
  - SP是访问本地变量的起始基址，一般用**负向偏移**来寻址.
  - 修改硬件SP，会引起伪SP、FP同步变化```SUBQ $16, SP // 这里golang解引用时，伪SP/FP都会-16```
- 参数/本地变量访问
  - 通过symbol+/-offset(FP/SP)的方式进行使用: ```例如arg0+0(FP)表示第函数第一个参数其实的位置，arg1+8(FP)表示函数参数偏移8byte的另一个参数。arg0/arg1用于助记，但是必须存在，否则无法通过编译（golang会识别并做处理）。```
  - 其中对于SP来说，还有一种访问方式： ```+/-offset(FP) 这里SP前面没有symbol修饰，代表这硬件SP```



#### FP

> FP伪寄存器是一个用于引用函数参数的虚拟帧指针。编译器维护一个虚拟帧指针，并将堆栈上的参数引用为该伪寄存器的偏移量。因此0(FP)是函数的第一个参数，8(FP)是第二个参数(在64位机器上)，以此类推。但是，当以这种方式引用一个函数参数时，有必要将名称放在开头，如first_arg+0(FP)和second_arg+8(FP)。(偏移量的含义--从帧指针出发的偏移量--与它在SB中的使用不同，在SB中，它是从符号出发的偏移量。) 汇编器强制执行这个约定，拒绝普通的0(FP)和8(FP)。实际的名称在语义上是不相关的，但应该用来记录参数的名称。值得强调的是，FP始终是一个伪寄存器，而不是硬件寄存器，即使在具有硬件帧指针的架构上也是如此。

> The FP pseudo-register is a virtual frame pointer used to refer to function arguments. The compilers maintain a virtual frame pointer and refer to the arguments on the stack as offsets from that pseudo-register. Thus 0(FP) is the first argument to the function, 8(FP) is the second (on a 64-bit machine), and so on. However, when referring to a function argument this way, it is necessary to place a name at the beginning, as in first_arg+0(FP) and second_arg+8(FP). (The meaning of the offset—offset from the frame pointer—distinct from its use with SB, where it is an offset from the symbol.) The assembler enforces this convention, rejecting plain 0(FP) and 8(FP). The actual name is semantically irrelevant but should be used to document the argument's name. It is worth stressing that FP is always a pseudo-register, not a hardware register, even on architectures with a hardware frame pointer.


> 对于带有Go原型的汇编函数，go vet会检查参数名和偏移量是否匹配。在32位系统上，64位值的低位和高位32位是通过在名称中添加一个_lo或_hi后缀来区分的，如arg_lo+0(FP)或arg_hi+4(FP)。如果一个Go原型没有给它的结果命名，那么预期的汇编名是ret。

> For assembly functions with Go prototypes, go vet will check that the argument names and offsets match. On 32-bit systems, the low and high 32 bits of a 64-bit value are distinguished by adding a _lo or _hi suffix to the name, as in arg_lo+0(FP) or arg_hi+4(FP). If a Go prototype does not name its result, the expected assembly name is ret.


#### SP

> SP伪寄存器是一个虚拟栈指针，用于引用帧本地变量和为函数调用准备的参数。它指向本地栈帧的顶部，所以引用时应使用负偏移量，范围为[-framesize，0)：x-8(SP)，y-4(SP)，以此类推。

> The SP pseudo-register is a virtual stack pointer used to refer to frame-local variables and the arguments being prepared for function calls. It points to the top of the local stack frame, so references should use negative offsets in the range [−framesize, 0): x-8(SP), y-4(SP), and so on.

> 在具有名为SP的硬件寄存器的架构上，名称前缀可以区分对虚拟栈指针的引用和对架构SP寄存器的引用，即x-8(SP)，y-4(SP)，以此类推。也就是说，x-8(SP)和-8(SP)是不同的内存位置：第一个是指虚拟栈指针伪寄存器，而第二个是指硬件的SP寄存器。

> On architectures with a hardware register named SP, the name prefix distinguishes references to the virtual stack pointer from references to the architectural SP register. That is, x-8(SP) and -8(SP) are different memory locations: the first refers to the virtual stack pointer pseudo-register, while the second refers to the hardware's SP register.


- 总结下：
  - 如何理解伪寄存器FP和SP呢？其实伪寄存器FP和SP相当于plan9伪汇编中的一个助记符，他们是根据当前函数栈空间计算出来的一个相对于物理寄存器SP的一个偏移量坐标。
  - 伪SP和FP的相对位置是会变的，所以不应该尝试用伪SP寄存器去找那些用FP+offset来引用的值，例如函数的入参和返回值。
  - 官方文档中说的伪SP指向stack的top，是有问题的。其指向的局部变量位置实际上是整个栈的栈底（除caller BP 之外），所以说bottom更合适一些。
  - ```MOVQ	0(SP), AX // f's PC```,这种前面没有flags的，它相当于实际的寄存器的值，不是伪寄存器了。



## 编译/反编译命令

```sh
//编译
go build -gcflags="-S"
go tool compile -S hello.go
go tool compile -N -S hello.go // 禁止优化,防止函数被优化。
//反编译
go tool objdump <binary>
```

### 一些汇编需要的常见的指令

```sh
go build  -gcflags "-N -l" -o test .

info files 
info registers sp bp
info breakpoint

x/10x
help x

x/16xb 0x7fffffffe470
[https://visualgdb.com/gdbreference/commands/x]

info register rbp rsp pc

display /20i $pc
```

https://blog.csdn.net/counsellor/article/details/100034080

## 函数

### 各语言函数调用堆栈

#### c语言


> main.c
```c
int sub(int first, int second)
{
    return first-second;
}
int main()
{
    int result = sub(2,1);
}
```

使用```gcc -S main.c```

```
	.file	"main.c"
	.text
	.globl	sub
	.type	sub, @function
sub:
.LFB0:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, -4(%rbp)
	movl	%esi, -8(%rbp)
	movl	-4(%rbp), %eax
	subl	-8(%rbp), %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE0:
	.size	sub, .-sub
	.globl	main
	.type	main, @function
main:
.LFB1:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	subq	$16, %rsp
	movl	$1, %esi
	movl	$2, %edi
	call	sub
	movl	%eax, -4(%rbp)
	movl	$0, %eax
	leave
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE1:
	.size	main, .-main
	.ident	"GCC: (GNU) 8.3.1 20191121 (Red Hat 8.3.1-5)"
	.section	.note.GNU-stack,"",@progbits
```

函数调用过程中，参数的传递以及返回值是通过寄存器传递的，比如第一个参数是%edi，第二个参数是%esi，返回值是%eax。


#### go语言

```go
package main

func sub(first, second int) (int){
    return first-second
}

func main() {
    sub(2,1)
}
```

- ```go tool compile -S -N -l main.go```

```
"".sub STEXT nosplit size=25 args=0x18 locals=0x0
	0x0000 00000 (main.go:3)	TEXT	"".sub(SB), NOSPLIT|ABIInternal, $0-24
	0x0000 00000 (main.go:3)	FUNCDATA	$0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
	0x0000 00000 (main.go:3)	FUNCDATA	$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
	0x0000 00000 (main.go:3)	FUNCDATA	$2, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
	0x0000 00000 (main.go:3)	PCDATA	$0, $0
	0x0000 00000 (main.go:3)	PCDATA	$1, $0
	0x0000 00000 (main.go:3)	MOVQ	$0, "".~r2+24(SP)
	0x0009 00009 (main.go:4)	MOVQ	"".first+8(SP), AX
	0x000e 00014 (main.go:4)	SUBQ	"".second+16(SP), AX
	0x0013 00019 (main.go:4)	MOVQ	AX, "".~r2+24(SP)
	0x0018 00024 (main.go:4)	RET
...	
"".main STEXT size=68 args=0x0 locals=0x20
	0x0000 00000 (main.go:7)	TEXT	"".main(SB), ABIInternal, $32-0
	0x0000 00000 (main.go:7)	MOVQ	(TLS), CX
	0x0009 00009 (main.go:7)	CMPQ	SP, 16(CX)
	0x000d 00013 (main.go:7)	JLS	61
	0x000f 00015 (main.go:7)	SUBQ	$32, SP
	0x0013 00019 (main.go:7)	MOVQ	BP, 24(SP)
	0x0018 00024 (main.go:7)	LEAQ	24(SP), BP
	0x001d 00029 (main.go:7)	FUNCDATA	$0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
	0x001d 00029 (main.go:7)	FUNCDATA	$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
	0x001d 00029 (main.go:7)	FUNCDATA	$2, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
	0x001d 00029 (main.go:8)	PCDATA	$0, $0
	0x001d 00029 (main.go:8)	PCDATA	$1, $0
	0x001d 00029 (main.go:8)	MOVQ	$2, (SP)
	0x0025 00037 (main.go:8)	MOVQ	$1, 8(SP)
	0x002e 00046 (main.go:8)	CALL	"".sub(SB)
	0x0033 00051 (main.go:9)	MOVQ	24(SP), BP
	0x0038 00056 (main.go:9)	ADDQ	$32, SP
	0x003c 00060 (main.go:9)	RET
	0x003d 00061 (main.go:9)	NOP
	0x003d 00061 (main.go:7)	PCDATA	$1, $-1
	0x003d 00061 (main.go:7)	PCDATA	$0, $-1
	0x003d 00061 (main.go:7)	CALL	runtime.morestack_noctxt(SB)
	0x0042 00066 (main.go:7)	JMP	0
...
```


### go的函数调用堆栈

- 总的来说，
  - FP就是指向的函数参数和返回值的地方，如果要指代具体的某个值，```xx+正数(FP)```
  - 伪SP,就是为了方便指向callee's locall variable,```xx+负数(SP)```
    - 如果某个函数内部没有定义局部变量，那么这个值其实就没用，跟真实SP指向的内容一致。

```go
package main

func main(){
	forTestFunctionNotExistLocalVariable(1, 2)
	forTestFunctionAttachingLocalVariable(1, 2)
}

func forTestFunctionNotExistLocalVariable(v1, v2 int) (r1, r2 int) {
	r1, r2 = v1, v2
	return
}

func forTestFunctionAttachingLocalVariable(v1, v2 int) [2]int{
	var d [2]int //arrary
	d[0], d[1] = v1, v2
	return d
}
```

- ```go tool compile -S -N -l main.go```

可以看到下面使用汇编工具呈现出来的都是使用的```SP```这个寄存器，没有使用FP。

```
"".main STEXT size=90 args=0x0 locals=0x28
	0x0000 00000 (main.go:3)	TEXT	"".main(SB), ABIInternal, $40-0
	0x0000 00000 (main.go:3)	MOVQ	(TLS), CX
	0x0009 00009 (main.go:3)	CMPQ	SP, 16(CX)
	0x000d 00013 (main.go:3)	JLS	83
	0x000f 00015 (main.go:3)	SUBQ	$40, SP
	0x0013 00019 (main.go:3)	MOVQ	BP, 32(SP)
	0x0018 00024 (main.go:3)	LEAQ	32(SP), BP
	0x001d 00029 (main.go:4)	PCDATA	$0, $0
	0x001d 00029 (main.go:4)	PCDATA	$1, $0
	0x001d 00029 (main.go:4)	MOVQ	$1, (SP)
	0x0025 00037 (main.go:4)	MOVQ	$2, 8(SP)
	0x002e 00046 (main.go:4)	CALL	"".forTestFunctionNotExistLocalVariable(SB)
	0x0033 00051 (main.go:5)	MOVQ	$1, (SP)
	0x003b 00059 (main.go:5)	MOVQ	$2, 8(SP)
	0x0044 00068 (main.go:5)	CALL	"".forTestFunctionAttachingLocalVariable(SB)
	0x0049 00073 (main.go:6)	MOVQ	32(SP), BP
	0x004e 00078 (main.go:6)	ADDQ	$40, SP
	0x0052 00082 (main.go:6)	RET
	0x0053 00083 (main.go:6)	NOP
	0x0053 00083 (main.go:3)	PCDATA	$1, $-1
	0x0053 00083 (main.go:3)	PCDATA	$0, $-1
	0x0053 00083 (main.go:3)	CALL	runtime.morestack_noctxt(SB)
	0x0058 00088 (main.go:3)	JMP	0


"".forTestFunctionNotExistLocalVariable STEXT nosplit size=39 args=0x20 locals=0x0
	0x0000 00000 (main.go:8)	TEXT	"".forTestFunctionNotExistLocalVariable(SB), NOSPLIT|ABIInternal, $0-32
	//...
	0x0000 00000 (main.go:8)	MOVQ	$0, "".r1+24(SP)
	0x0009 00009 (main.go:8)	MOVQ	$0, "".r2+32(SP)
	0x0012 00018 (main.go:9)	MOVQ	"".v1+8(SP), AX
	0x0017 00023 (main.go:9)	MOVQ	AX, "".r1+24(SP)
	0x001c 00028 (main.go:9)	MOVQ	"".v2+16(SP), AX
	0x0021 00033 (main.go:9)	MOVQ	AX, "".r2+32(SP)
	0x0026 00038 (main.go:10)	RET


"".forTestFunctionAttachingLocalVariable STEXT nosplit size=68 args=0x20 locals=0x18
	0x0000 00000 (main.go:13)	TEXT	"".forTestFunctionAttachingLocalVariable(SB), NOSPLIT|ABIInternal, $24-32
	0x0000 00000 (main.go:13)	SUBQ	$24, SP
	0x0004 00004 (main.go:13)	MOVQ	BP, 16(SP)
	0x0009 00009 (main.go:13)	LEAQ	16(SP), BP
	//...
	0x0011 00017 (main.go:13)	MOVUPS	X0, "".~r2+48(SP)
	0x0016 00022 (main.go:14)	XORPS	X0, X0
	0x0019 00025 (main.go:14)	MOVUPS	X0, "".d(SP)
	0x001d 00029 (main.go:15)	MOVQ	"".v1+32(SP), AX
	0x0022 00034 (main.go:15)	MOVQ	AX, "".d(SP)
	0x0026 00038 (main.go:15)	MOVQ	"".v2+40(SP), CX
	0x002b 00043 (main.go:15)	MOVQ	CX, "".d+8(SP)
	0x0030 00048 (main.go:16)	MOVQ	AX, "".~r2+48(SP)
	0x0035 00053 (main.go:16)	MOVQ	CX, "".~r2+56(SP)
	0x003a 00058 (main.go:16)	MOVQ	16(SP), BP
	0x003f 00063 (main.go:16)	ADDQ	$24, SP
	0x0043 00067 (main.go:16)	RET
```


我们自己写一个汇编。

- main.go文件

```go
package main

func forTestFunctionNotExistLocalVariable(v1, v2 int) (r1, r2 int)
func forTestFunctionAttachingLocalVariable(v1, v2 int) [2]int

func main(){
	forTestFunctionNotExistLocalVariable(1, 2)
	forTestFunctionAttachingLocalVariable(1, 2)
}

// func forTestFunctionNotExistLocalVariable(v1, v2 int) (r1, r2 int) {
// 	r1, r2 = v1, v2
// 	return
// }

// func forTestFunctionAttachingLocalVariable(v1, v2 int) [2]int{
// 	var d [2]int //arrary
// 	d[0], d[1] = v1, v2
// 	return d
// }
```

- forTestFunction.s文件

```go
#include "textflag.h"

TEXT ·forTestFunctionNotExistLocalVariable(SB),NOSPLIT,$0-32
   MOVQ v1+0(FP), AX          // FP+0  为参数v1，将其值拷贝到寄存器AX中
   MOVQ AX, r1+24(FP)         // FP+24 为返回值r1，将寄存器AX赋值给返回值r1
   MOVQ v2+8(FP), AX          // FP+8  为参数v2
   MOVQ AX, f+32(FP)          // FP+24 为返回值r2
   RET                        // return

TEXT ·forTestFunctionAttachingLocalVariable(SB),NOSPLIT,$16-32    // $16值栈空间16byte(编译器会自动，栈空间会被+8用于存储caller's BP寄存器,所以最终是24byte)，- 后面的32是caller的参数与返回值大小
                                // 
   MOVQ    $0, d-16(SP)         // 初始化d[0]
   MOVQ    $0, d-8(SP)          // 初始化d[1]

   MOVQ    v1+0(FP), AX          // d[0] = v1
   MOVQ    AX, d-16(SP)         //
   MOVQ    v2+8(FP), AX          // d[1] = v2
   MOVQ    AX, d-8(SP)          //

   MOVQ    d-16(SP), AX         // return[0] = d[0]
   MOVQ    AX, r+16(FP)         //
   MOVQ    d-8(SP), AX          // return[1] = d[1]
   MOVQ    AX, r+24(FP)         //

   RET                          // return

```



- 被调用的函数无局部变量

```
------
r2 (8 bytes)
r1 (8 bytes)
------
v2 (8 bytes)
v1 (8 bytes)
------ --------------> [pseudo FP]
ret addr (8 bytes)
------ --------------> [pseudo SP][hardware SP]
```

- 被调用的函数有局部变量

```
------
d[1] (8 bytes)
d[0] (8 bytes)
------
v2 (8 bytes)
v1 (8 bytes)
------ --------------> [pseudo FP]
ret addr (8 bytes)
------
caller BP (8 bytes)--> [编译器自动插入]
------ --------------> [pseudo SP]
d[1] (8 bytes)
d[0] (8 bytes)
------ --------------> [hardware SP]
```


列出反编译```go tool objdump <binary>```的对比，展示了编译器会自动帮我们加上```caller's BP```到```callee's栈中```。

- ```go tool objdump <binary>```

```sh
TEXT main.forTestFunctionNotExistLocalVariable(SB) /root/code/go_lanage/testAssemble/asm.s
  asm.s:4		0x452600		488b442408		MOVQ 0x8(SP), AX
  asm.s:5		0x452605		4889442420		MOVQ AX, 0x20(SP)
  asm.s:6		0x45260a		488b442410		MOVQ 0x10(SP), AX
  asm.s:7		0x45260f		4889442428		MOVQ AX, 0x28(SP)
  asm.s:8		0x452614		c3			RET
TEXT main.forTestFunctionAttachingLocalVariable(SB) /root/code/go_lanage/testAssemble/asm.s
  asm.s:10		0x452620		4883ec18		SUBQ $0x18, SP
  asm.s:10		0x452624		48896c2410		MOVQ BP, 0x10(SP)
  asm.s:10		0x452629		488d6c2410		LEAQ 0x10(SP), BP
  asm.s:12		0x45262e		48c7042400000000	MOVQ $0x0, 0(SP)
  asm.s:13		0x452636		48c744240800000000	MOVQ $0x0, 0x8(SP)
  asm.s:15		0x45263f		488b442420		MOVQ 0x20(SP), AX
  asm.s:16		0x452644		48890424		MOVQ AX, 0(SP)
  asm.s:17		0x452648		488b442428		MOVQ 0x28(SP), AX
  asm.s:18		0x45264d		4889442408		MOVQ AX, 0x8(SP)
  asm.s:20		0x452652		488b0424		MOVQ 0(SP), AX
  asm.s:21		0x452656		4889442430		MOVQ AX, 0x30(SP)
  asm.s:22		0x45265b		488b442408		MOVQ 0x8(SP), AX
  asm.s:23		0x452660		4889442438		MOVQ AX, 0x38(SP)
  asm.s:25		0x452665		488b6c2410		MOVQ 0x10(SP), BP
  asm.s:25		0x45266a		4883c418		ADDQ $0x18, SP
  asm.s:25		0x45266e		c3			RET
```






### 例子

- 下面来做下实验。
  - 确认FP， SP相对于real register的位置点在那里。
  - 我们 presudo FP应该在caller's next pc + 8byte
  - presudo SP应该在caller's BP

> main.go

```go
package main

func test_FP_SP(a, b int64)(first uintptr, second uintptr)

func main(){
	first, second := test_FP_SP(1, 2)
	first -= second
	_ = first
}
```



> test_FP_SP.s

```go
// func test_FP_SP(a, b int64)(first uintptr, second uintptr)
TEXT ·test_FP_SP(SB),$4112-16
        LEAQ x-0(SP), DI         // 
        MOVQ DI, first+16(FP)    // 将原伪寄存器SP偏移量存入返回值first

        MOVQ    SP, BP           // 存储物理SP偏移量到BP寄存器
        ADDQ    $4096, SP        // 将物理SP偏移增加4K

        LEAQ x-0(SP), SI         // 在上面中只改变了一个值就是SP这个寄存器，然后再次一模一样的把x-0(SP)给到了SI.

        /* 第一个 MOVQ    BP, SP */
        MOVQ    BP, SP           // 恢复物理SP，因为修改物理SP后，伪寄存器FP/SP随之改变，
                                 // 为了正确访问FP，先恢复物理SP
        MOVQ SI, second+24(FP)   // 将偏移后的伪寄存器SP偏移量存入返回值second

        /* 第二个 MOVQ    BP, SP */
        //MOVQ    BP, SP         

        RET					    // 从输出的second-first来看，正好相差4K
```

编译一下源代码：```go build -gcflags "-N -l" -o test .``` OR ```go build -gcflags "all=-N -l" -o test .``` OR ```GOOS=linux GOARCH=amd64 go tool compile -S .```

```sh
[root@iZf8z14idfp0rwhiicngwqZ FP_SP]# tree .
.
├── main.go
├── main.o
├── test
└── test_FP_SP.s
```


我们用到的gdb命令:

```sh

gdb ./test
list
b 6
display /25i $pc-8
si
si
si
```

![20210129195940](https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210129195940.png)
从上面的图中可以看出，go assemble中的```x-0(SP)```与```first+16(FP)```,其实都是与SP寄存器关联的，
其中SP，伪FP，与伪SP的位置，在下图中已经标识出来了;



```sh
+------------------------+                                  
|                        |                                  
|                        |                                  
|         second         |                                  
|                        |                                  
|-------------------------                                  
|                        |                                  
|                        |                                  
|         first          |                                  
|                        |                                  
|------------------------|                                  
|                        |                                  
|                        |                                  
|         b              |                                  
|                        |                                  
|------------------------|                                  
|                        |                                  
|                        |                                  
|         a              |                                  
|                        |                                  
+------------------------+ <-------- 伪FP!!!                      
|                        |                                  
|                        |                                  
|     caller's pc        |                                  
|                        |                                  
+------------------------+                                  
|                        |                                  
|                        |                                  
|     caller's BP        |                                  
|                        |                                  
|------------------------| <-------- callee's BP <===> 伪SP!!!
|                        |                                  
|                        |                                  
|        ...             |                                  
|                        |                                  
|                        |                                  
+------------------------+ <-------- 真实寄存器SP[它等于caller's SP - caller's next CP(8) - callee's stack size;上图已经标识了]                     
```


![MOVQ	0(SP), AX // f's PC](https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210129211423.png)


### 扩展

当我们把```/* 第一个 MOVQ    BP, SP */```下面的注释掉，执行的话会panic，是因为PC寄存器读取错误，而不是注释掉的下一行导致的。

可以实验下:我们把```/* 第二个 MOVQ    BP, SP */```取消注释，它就正常执行，只是返回值不对而已。


## 从函数中扩展出来的周边知识

### 函数的定义

![20210323105508](https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210323105508.png)

- 函数的声明以TEXT标识开头，
- 以```${package}·${function}```为函数名。
  - 当函数属于本package时，通常可以不写${package}，只留·${function}即可。
  - ·在mac上可以用shift+option+9 打出。
- $0表示该函数栈大小为0byte，计算栈大小时，需要考虑局部变量和本函数内调用其他函数时，需要传参的空间，不含函数返回地址和CALLER BP（这2个后面会讲到）。
- $16表示该函数入参和返回值一共有16byte。当有NOSPLIT标识时，可以不写输入参数、返回值占用的大小。


![20210323110847](https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210323110847.png)

- NOSPLIT: don’t insert a stack check
  - Reduces function call overhead
  - Limits size of stack
  - Use on leaf functions (unless a large stack is needed)
- NOFRAME: don’t allocate a stack frame
  - Function must be a leaf
  - Function must be declared with a stack size of 0 (i.e. TEXT ...,NOFRAME,$0-...)
  - No frame pointer (or return address on link register architectures) saved

### 变量声明

go里面已初始化过的全局的const、var变量, 它在汇编里，一般是存储在```.rodata```或者```.data```段中.
在汇编中表示如下：

- DATA 结合 GLOBL 来定义一个变量
  - 全局变量的**数据部分**采用```DATA symbol+offset(SB)/width, value```格式进行声明。
    - 想在全局变量中定义数组，或字符串，这时候就需要用上```非0的offset```
    - 判断是否是一个私有全局变量的声明，<>表示该变量只在该文件内全局可见。
  - GLOBL 指令将变量声明为 global，额外接收两个参数，一个是 flag，另一个是变量的总大小: ```GLOBL divtab(SB), RODATA, $64```

例子:

```go
// 在全局变量中定义字符串，用上非0的offset 
DATA bio<>+0(SB)/8, $"oh yes i"
DATA bio<>+8(SB)/8, $"am here "
GLOBL bio<>(SB), RODATA, $16
```



- 类似RODATA/NOPTR的特殊声明还有：
  - NOPROF = 1 (For TEXT items.) Don’t profile the marked function. This flag is deprecated.
  - DUPOK = 2 It is legal to have multiple instances of this symbol in a single binary. The linker will choose one of the duplicates to use.
  - NOSPLIT = 4 (For TEXT items.) Don’t insert the preamble to check if the stack must be split. The frame for the routine, plus anything it calls, must fit in the spare space at the top of the stack segment. Used to protect routines such as the stack splitting code itself.
  - RODATA = 8 (For DATA and GLOBL items.) Put this data in a read-only section.
  - NOPTR = 16 (For DATA and GLOBL items.) This data contains no pointers and therefore does not need to be scanned by the garbage collector.
  - WRAPPER = 32 (For TEXT items.) This is a wrapper function and should not count as disabling recover.
  - NEEDCTXT = 64 (For TEXT items.) This function is a closure so it uses its incoming context register.

### 指令汇总

使用汇编，对每个平台，有不同的指令，可以参考[GoFunctionsInAssembly](https://lrita.github.io/images/posts/go/GoFunctionsInAssembly.pdf)其中有各个平台汇编指令速览和对照。

### 宏

与C语言类似：
- ```#define get_tls(r)  MOVQ TLS, r```来定义一个宏；
- ```#include "textflag.h"```来引用一个**外部宏定义文件**。


go编译器为了方便汇编中访问struct的指定字段，会在编译过程中自动生成一个go_asm.h文件，可以通过#include "go_asm.h"语言来引用，该文件中会生成该包内全部struct的每个字段的偏移量宏定义与结构体大小的宏定义，比如：

```go
package main

type testiMacio struct {
	begin string
	v1 uint32
	v2 uint32
	v3 int32
}
```

- ```go tool compile -S -asmhdr dump.h *.go```

- 生成dump.h文件

```go
// generated by compile -asmhdr from package main

#define testiMacio__size 32
#define testiMacio_begin 0
#define testiMacio_v1 16
#define testiMacio_v2 20
#define testiMacio_v3 24
```

#### (m_morebuf+gobuf_pc)(REGISTER)

```go
	MOVQ	8(SP), AX	// f's caller's PC
	MOVQ	AX, (m_morebuf+gobuf_pc)(BX)
```


[runtime.m](https://github.com/zput/go/blob/5622128a77b4af5e5dc02edf53ecac545e3af730/src/runtime/runtime2.go#L452)
[runtime.gobuf](https://github.com/zput/go/blob/5622128a77b4af5e5dc02edf53ecac545e3af730/src/runtime/runtime2.go#L302)

```go
type m struct {
	g0      *g     // goroutine with scheduling stack
	morebuf gobuf  // gobuf arg to morestack   //-----------morebuf-------------//
	divmod  uint32 // div/mod denominator for arm - known to liblink
	//...
}

type gobuf struct {
	// The offsets of sp, pc, and g are known to (hard-coded in) libmach.
	//
	// ctxt is unusual with respect to GC: it may be a
	// heap-allocated funcval, so GC needs to track it, but it
	// needs to be set and cleared from assembly, where it's
	// difficult to have write barriers. However, ctxt is really a
	// saved, live register, and we only ever exchange it between
	// the real register and the gobuf. Hence, we treat it as a
	// root during stack scanning, which means assembly that saves
	// and restores it doesn't need write barriers. It's still
	// typed as a pointer so that any other writes from Go get
	// write barriers.
	sp   uintptr
	pc   uintptr   // <<<--- 
	g    guintptr
	ctxt unsafe.Pointer
	ret  sys.Uintreg
	lr   uintptr
	bp   uintptr // for GOEXPERIMENT=framepointer
}
```

我们从这个```m_morebuf+gobuf_pc```就知道指的是这个m结构体中的morebuf结构体字段中的pc值。


[runtime.g](https://github.com/zput/go/blob/5622128a77b4af5e5dc02edf53ecac545e3af730/src/runtime/runtime2.go#L387)





## buildin类型


### string

```go
package main

//go:noinline
func exploreStringStruct(s string) {}

func main() {
    var x = "abcd-efg"
    exploreStringStruct(x)
}
```

- ```go tool compile -N -S main.go```

```sh
	0x001d 00029 (main.go:7)	LEAQ	go.string."abcd-efg-中"(SB), AX
	0x0024 00036 (main.go:7)	MOVQ	AX, "".x+16(SP)
	0x0029 00041 (main.go:7)	MOVQ	$12, "".x+24(SP)
	0x0032 00050 (main.go:8)	PCDATA	$0, $0
	0x0032 00050 (main.go:8)	MOVQ	AX, (SP)
	0x0036 00054 (main.go:8)	MOVQ	$12, 8(SP)
	0x003f 00063 (main.go:8)	CALL	"".exploreStringStruct(SB)
```

- ```go build main.go```
- ```go tool objdump main  |grep main.go```

```sh
  main.go:8		0x4525cd		488d0581190200		LEAQ 0x21981(IP), AX
  main.go:8		0x4525d4		48890424		MOVQ AX, 0(SP)
  main.go:8		0x4525d8		48c74424080c000000	MOVQ $0xc, 0x8(SP)
  main.go:8		0x4525e1		e8baffffff		CALL main.exploreStringStruct(SB)

```

go里面字符串是:一个指针，一个表示字节大小的字段;

## 附录

[1]:https://lrita.github.io/2017/12/12/golang-asm

[2]:https://github.com/buptbill220/gotls



https://xargin.com/plan9-assembly/
https://github.com/cch123/golang-notes/blob/master/assembly.md
https://lrita.github.io/images/posts/go/GoFunctionsInAssembly.pdf

函数声明,跳转;


