


## 例子

### main goroutine得不到执行

```go
package main
import (
    "fmt"
    "runtime"
)
func g2() {
    sum := 0
    for {
        sum++
    }
}
func main() {
    runtime.GOMAXPROCS(1)
    go g2()
    for {
        runtime.Gosched()
        fmt.Println("main is scheduled!")
    }
}
```

- 将不会打印["main is scheduled!"]



## go编译器加的函数头的部分

```
=> 0x459240 <main.test_FP_SP>:	mov    %fs:0xfffffffffffffff8,%rcx
   0x459249 <main.test_FP_SP+9>:	mov    0x10(%rcx),%rsi
   0x45924d <main.test_FP_SP+13>:	cmp    $0xfffffffffffffade,%rsi
   0x459254 <main.test_FP_SP+20>:	je     0x4592bd <main.test_FP_SP+125>
   0x459256 <main.test_FP_SP+22>:	lea    0x370(%rsp),%rax
   0x45925e <main.test_FP_SP+30>:	sub    %rsi,%rax
   0x459261 <main.test_FP_SP+33>:	cmp    $0x1308,%rax
   0x459267 <main.test_FP_SP+39>:	jbe    0x4592bd <main.test_FP_SP+125>
   0x459269 <main.test_FP_SP+41>:	sub    $0x1018,%rsp
   0x459270 <main.test_FP_SP+48>:	mov    %rbp,0x1010(%rsp)
   0x459278 <main.test_FP_SP+56>:	lea    0x1010(%rsp),%rbp
   0x459280 <main.test_FP_SP+64>:	lea    0x1010(%rsp),%rdi
   0x459288 <main.test_FP_SP+72>:	mov    %rdi,0x1030(%rsp)
   0x459290 <main.test_FP_SP+80>:	mov    %rsp,%rbp
   0x459293 <main.test_FP_SP+83>:	add    $0x1000,%rsp
   0x45929a <main.test_FP_SP+90>:	lea    0x1010(%rsp),%rsi
   0x4592a2 <main.test_FP_SP+98>:	mov    %rbp,%rsp
   0x4592a5 <main.test_FP_SP+101>:	mov    %rsi,0x1038(%rsp)
   0x4592ad <main.test_FP_SP+109>:	mov    0x1010(%rsp),%rbp
   0x4592b5 <main.test_FP_SP+117>:	add    $0x1018,%rsp
   0x4592bc <main.test_FP_SP+124>:	retq
   0x4592bd <main.test_FP_SP+125>:	callq  0x450c70 <runtime.morestack_noctxt>
   0x4592c2 <main.test_FP_SP+130>:	jmpq   0x459240 <main.test_FP_SP>
   0x4592c7:	add    %al,(%rax)
   0x4592c9:	add    %al,(%rax)
```

![以上面的例子来看](https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210201140600.png)

- 在头和尾部加上了其他跳转代码。
  - ```0x10(%rcx)```
  - ```$0xfffffffffffffade```

```go

type stack struct {
	lo uintptr
	hi uintptr
}

type g struct {
	// Stack parameters.
	// stack describes the actual stack memory: [stack.lo, stack.hi).
	// stackguard0 is the stack pointer compared in the Go stack growth prologue.
	// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.
	// stackguard1 is the stack pointer compared in the C stack growth prologue.
	// It is stack.lo+StackGuard on g0 and gsignal stacks.
	// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).
	stack       stack   // offset known to runtime/cgo
	stackguard0 uintptr // offset known to liblink
	stackguard1 uintptr // offset known to liblink
	//...
```
其中rcx是g的地址，所以```0x10(%rcx)```是就是跳过stack得到stackguard0(它是go栈增长的序章，开始的地方,值是：stack.lo+StackGuard)
[var StackGuard = 928*stackGuardMultiplier() + StackSystem](https://github.com/golang/go/blob/0e85fd7561de869add933801c531bf25dee9561c/src/cmd/internal/objabi/stack.go#L21)

当被抢占的时候，它是:[StackPreempt = -1314 // 0xfff...fade](https://github.com/golang/go/blob/0e85fd7561de869add933801c531bf25dee9561c/src/cmd/internal/objabi/stack.go#L17)


| order | explainment |
| --- | --- |
|je | Jumps if equal |
|jbe | Jumps if below or equal|






### wait to do 

gdb golang assamble
non-split;    sp bp 会更新吗?


main function enter BP is useful? schedule.



### dropg()函数

- dropg()  //解除g和m之间的关系; 

```go
func dropg() {
	_g_ := getg()

	setMNoWB(&_g_.m.curg.m, nil)
	setGNoWB(&_g_.m.curg, nil)
}
```

### park_m函数

通过mcall从gN转到g0; stack转移了, jmp跳转到park_m(*g)函数,
----
gN-->m ---> gN 
mcall怎么保证g0的m指向了m的?


```go
// park continuation on g0.
func park_m(gp *g) {
    _g_ := getg()

    if trace.enabled {
        traceGoPark(_g_.m.waittraceev, _g_.m.waittraceskip)
    }

    casgstatus(gp, _Grunning, _Gwaiting)
    dropg()  //解除g和m之间的关系

    ......
   
    schedule()
}
```

## get_tls函数

```go
TEXT runtime·rt0_go(SB),NOSPLIT,$0
    //...

	LEAQ	runtime·m0+m_tls(SB), DI  // //DI = &m0.tls，取m0的tls成员的地址到DI寄存器
	CALL	runtime·settls(SB)        // 调用settls设置线程本地存储，settls函数的参数在DI寄存器中
	// store through it, to make sure it works // 可以看做是测试;测试刚刚那个绑定是否成功。
	get_tls(BX)    // 把TLS地址放入BX寄存器
	MOVQ	$0x123, g(BX)
	MOVQ	runtime·m0+m_tls(SB), AX
	CMPQ	AX, $0x123
	JEQ 2(PC)
	CALL	runtime·abort(SB)
```

#### settls

```go
// set tls base to DI
TEXT runtime·settls(SB),NOSPLIT,$32
	ADDQ	$8, DI	// ELF wants to use -8(FS) //因为后面要-8,所以先加+8
	MOVQ	DI, SI  // is SI parameter?
	MOVQ	$0x1002, DI	// ARCH_SET_FS
	MOVQ	$SYS_arch_prctl, AX
	SYSCALL
	CMPQ	AX, $0xfffffffffffff001
	JLS	2(PC)
	MOVL	$0xf1, 0xf1  // crash
	RET
```

[arch_prctl](https://www.man7.org/linux/man-pages/man2/arch_prctl.2.html)
```c
int arch_prctl(int code, unsigned long addr);
// arch_prctl() sets architecture-specific process or thread state. code selects a subfunction and passes argument addr to it;
```
其中：```ARCH_SET_FS```: Set the 64-bit base for the FS register to addr.

> 现在知道就是把m0.tls[0]传给FS寄存器

#### get_tls(BX)与g(BX)

这个```get_tls(BX)```与```g()```其实都是宏定义：

```go
#ifdef GOARCH_amd64
#define	get_tls(r)	MOVQ TLS, r
#define	g(r)	0(r)(TLS*1)
#endif
```

可以得到
```go
MOVQ TLS, BX
0(BX)(TLS*1)
```

有两个疑问，
第一个是TLS是代表什么?
第二个是0(BX)(TLS*1)是能转换为什么地址？


```
	// Thread-local storage references use the TLS pseudo-register.
	// As a register, TLS refers to the thread-local storage base, and it
	// can only be loaded into another register:
	//
	//         MOVQ TLS, AX
	//
	// An offset from the thread-local storage base is written off(reg)(TLS*1).
	// Semantically it is off(reg), but the (TLS*1) annotation marks this as
	// indexing from the loaded TLS base. This emits a relocation so that
	// if the linker needs to adjust the offset, it can. For example:
	//
	//         MOVQ TLS, AX
	//         MOVQ 0(AX)(TLS*1), CX // load g into CX
	//
	// On systems that support direct access to the TLS memory, this
	// pair of instructions can be reduced to a direct TLS memory reference:
	//
	//         MOVQ 0(TLS), CX // load g into CX
	//
	// The 2-instruction and 1-instruction forms correspond to the two code
	// sequences for loading a TLS variable in the local exec model given in "ELF
	// Handling For Thread-Local Storage".
```

> 这里总结就是:
>> TLS代表的是伪寄存器，是线程本地存储的基地址。
>> 语义上```off(reg)(TLS*1)== off(reg)```. 而这个```(TLS*1)```说明是从线程本地存储的基地址上进行索引。


### 参考

https://www.zhihu.com/question/284288720
https://segmentfault.com/a/1190000038626134
https://www.altoros.com/blog/golang-internals-part-5-the-runtime-bootstrap-process/

[gid](https://segmentfault.com/a/1190000010984538)

- Addressing modes:
  - (DI)(BX*2): The location at address DI plus BX*2.
  - 64(DI)(BX*2): The location at address DI plus BX*2 plus 64. These modes accept only 1, 2, 4, and 8 as scale factors.

https://golang.org/doc/asm#directives

https://lrita.github.io/2017/12/12/golang-asm/#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E

https://github.com/go-internals-cn/go-internals


```go

    // When building for inclusion into a shared library, an instruction of the form
    //     MOV off(CX)(TLS*1), AX
    // becomes
    //     mov %fs:off(%rcx), %rax
    // which assumes that the correct TLS offset has been loaded into %rcx (today
    // there is only one TLS variable -- g -- so this is OK). When not building for
    // a shared library the instruction does not require a prefix.
```


