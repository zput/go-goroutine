<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>剥夺调度 on go调度源码分析</title><link>https://zput.github.io/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/</link><description>Recent content in 剥夺调度 on go调度源码分析</description><generator>Hugo 0.125.0</generator><language>zh</language><lastBuildDate>Tue, 23 Jun 2020 20:50:00 +0000</lastBuildDate><atom:link href="https://zput.github.io/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/index.xml" rel="self" type="application/rss+xml"/><item><title>开启系统监控</title><link>https://zput.github.io/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/start_sysmon/</link><pubDate>Mon, 04 May 2020 12:35:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/start_sysmon/</guid><description>开启系统监控 # 这个是main goroutine执行的主函数，此函数之后会调用用户定义main函数,我们在初始化一章已经提过 main goroutine执行的主函数 它的里面可以看到调用了newm函数生成新M,且新M将执行sysmon函数
func main() { //... if GOARCH != &amp;#34;wasm&amp;#34; { // no threads on wasm yet, so no sysmon systemstack(func() { newm(sysmon, nil) }) } //... } sysmon # 可以看到sysmon里面是一个for循环,它会一直运行,因为这个M没有关联P，所以不允许写屏障 逻辑比较简单，延时睡眠，调用retake
// Always runs without a P, so write barriers are not allowed. // //go:nowritebarrierrec func sysmon() { lock(&amp;amp;sched.lock) sched.nmsys++ //增加记录系统线程的值的个数 checkdead() unlock(&amp;amp;sched.lock) lasttrace := int64(0) idle := 0 // how many cycles in succession we had not wokeup somebody delay := uint32(0) for { if idle == 0 { // start with 20us sleep.</description></item><item><title>代码执行过久</title><link>https://zput.github.io/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/user_code_preemption/</link><pubDate>Mon, 04 May 2020 12:35:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/user_code_preemption/</guid><description>执行太久需要抢占 # preemptone设置抢占 # 继续上文看下preemptone函数，它设置了g.preempt(抢占标示)为true和g.stackguard0为很大的数((1&amp;lt;&amp;lt;(8*sys.PtrSize) - 1) &amp;amp; -1314 ---&amp;gt; 0xfffffffffffffade)，使被抢占的goroutine在进行函数调用会去检查栈溢出,然后处理抢占请求
// Tell the goroutine running on processor P to stop. // This function is purely best-effort. It can incorrectly fail to inform the // goroutine. It can send inform the wrong goroutine. Even if it informs the // correct goroutine, that goroutine might ignore the request if it is // simultaneously executing newstack. // No lock needs to be held.</description></item><item><title>陷入系统调用</title><link>https://zput.github.io/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/system_call_preemption/</link><pubDate>Tue, 23 Jun 2020 20:50:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/system_call_preemption/</guid><description>执行系统调用抢占 # handoffp # handoffp函数:判断是否需要启动工作线程来接管_p_，如果不需要则把_p_放入P的全局空闲队列.
如果当前P的运行队列有任务/全局队列有任务，有gc任务，大概率整个系统有任务待做，或者当前P是最后一个P要用作轮询网络
其中大概率整个系统有任务待做: 由第24行 atomic.Load(&amp;amp;sched.nmspinning)+atomic.Load(&amp;amp;sched.npidle) == 0 决定:
如果没有P空闲，而且这些没空闲的P连接的M不是处在自旋状态(没有自旋的M)，证明其他P都在工作(而不是假装工作实际是在伺机从其他队列偷任务那种),是不是说明整个系统除了当前P外都在做事，所以大概率某些P的运行队列上有任务积压，所以我们应该启动M,让它跟当前P连接，去别的P中偷任务)
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 // Hands off P from syscall or locked M.</description></item></channel></rss>