<!doctype html><html lang=zh dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="执行系统调用抢占 # handoffp # handoffp函数:判断是否需要启动工作线程来接管_p_，如果不需要则把_p_放入P的全局空闲队列.
如果当前P的运行队列有任务/全局队列有任务，有gc任务，大概率整个系统有任务待做，或者当前P是最后一个P要用作轮询网络
其中大概率整个系统有任务待做: 由第24行 atomic.Load(&amp;sched.nmspinning)+atomic.Load(&amp;sched.npidle) == 0 决定:
如果没有P空闲，而且这些没空闲的P连接的M不是处在自旋状态(没有自旋的M)，证明其他P都在工作(而不是假装工作实际是在伺机从其他队列偷任务那种),是不是说明整个系统除了当前P外都在做事，所以大概率某些P的运行队列上有任务积压，所以我们应该启动M,让它跟当前P连接，去别的P中偷任务)
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 // Hands off P from syscall or locked M."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://zput.github.io/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/system_call_preemption/"><meta property="og:site_name" content="go调度源码分析"><meta property="og:title" content="陷入系统调用"><meta property="og:description" content="执行系统调用抢占 # handoffp # handoffp函数:判断是否需要启动工作线程来接管_p_，如果不需要则把_p_放入P的全局空闲队列.
如果当前P的运行队列有任务/全局队列有任务，有gc任务，大概率整个系统有任务待做，或者当前P是最后一个P要用作轮询网络
其中大概率整个系统有任务待做: 由第24行 atomic.Load(&amp;sched.nmspinning)+atomic.Load(&amp;sched.npidle) == 0 决定:
如果没有P空闲，而且这些没空闲的P连接的M不是处在自旋状态(没有自旋的M)，证明其他P都在工作(而不是假装工作实际是在伺机从其他队列偷任务那种),是不是说明整个系统除了当前P外都在做事，所以大概率某些P的运行队列上有任务积压，所以我们应该启动M,让它跟当前P连接，去别的P中偷任务)
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 // Hands off P from syscall or locked M."><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:published_time" content="2020-06-23T20:50:00+00:00"><meta property="article:modified_time" content="2020-06-23T20:50:00+00:00"><meta property="article:tag" content="Golang"><meta property="article:tag" content="Goroutine"><title>陷入系统调用 | go调度源码分析</title>
<link rel=manifest href=/go-goroutine/manifest.json><link rel=icon href=/go-goroutine/favicon.png><link rel=stylesheet href=/go-goroutine/book.min.a7d3a43391e1f7eb43ae94bcae6354b739c49cba56473620924ec707afe0864d.css integrity="sha256-p9OkM5Hh9+tDrpS8rmNUtznEnLpWRzYgkk7HB6/ghk0=" crossorigin=anonymous><script defer src=/go-goroutine/flexsearch.min.js></script><script defer src=/go-goroutine/en.search.min.4af95582c2d89e848e6592890d92006aee754b8d4472c5ed71a0c6e01fa4ac97.js integrity="sha256-SvlVgsLYnoSOZZKJDZIAau51S41EcsXtcaDG4B+krJc=" crossorigin=anonymous></script><script defer src=/go-goroutine/sw.min.ec96d6e09af3075a94dd4de723a2edddf2ef138381c7e1e5b5a1f2c0578ee8bd.js integrity="sha256-7JbW4JrzB1qU3U3nI6Lt3fLvE4OBx+HltaHywFeO6L0=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/go-goroutine/><span>go调度源码分析</span></a></h2><div class=magic><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><div class=book-switch><label class=switch><input id=dark-mode-checkbox type=checkbox onchange=darkmode()>
<span class=slider></span></label></div></div><ul><li><a href=https://zput.github.io target=_blank rel=noopener>Zput博客</a></li><li><a href=https://github.com/zput target=_blank rel=noopener>GitHub</a></li></ul><hr><ul><li><span>基础知识</span><ul><li><a href=/go-goroutine/docs/foundation/golang_basic/>基本用法</a></li><li><a href=/go-goroutine/docs/foundation/slice/>slice</a></li><li><a href=/go-goroutine/docs/foundation/map/>map</a></li><li><a href=/go-goroutine/docs/foundation/sort/>sort</a></li><li><a href=/go-goroutine/docs/foundation/directory/>Directory</a></li></ul></li><li><span>鲁棒和性能</span><ul><li><a href=/go-goroutine/docs/robustness_and_performance/golang_test/>测试相关函数</a></li></ul></li><li><span>运行时</span><ul><li><a href=/go-goroutine/docs/runtime/golang_gmp/>GMP</a></li><li><span>堆分配原理</span><ul><li><a href=/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/1_summarize/>概述</a></li><li><a href=/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_big_object/>分配大对象</a></li><li><a href=/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_middle_object/>概述</a></li><li><a href=/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_small_object/>概述</a></li></ul></li><li><a href=/go-goroutine/docs/runtime/complement-source-reverse/>源码-反码-补码</a></li><li><a href=/go-goroutine/docs/runtime/golang_memery/>内存分配器</a></li><li><a href=/go-goroutine/docs/runtime/golang_gc/>垃圾回收</a></li><li><a href=/go-goroutine/docs/runtime/schedule/>调度</a><ul><li><span>前置知识</span><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/memory/>内存大小端</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/register_functionstack/>伪寄存器与函数栈帧</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/similar_assemble/>类汇编</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/go_underlying_struct/>底层重要结构</a></li></ul></li><li><a href=/go-goroutine/docs/runtime/schedule/2_init_before_enter_main_function/>初始化</a></li><li><a href=/go-goroutine/docs/runtime/schedule/3_exit_goroutine/>退出</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/>调度挑选策略</a><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/take_goroutine_from_globalorlocal_p/>从全局/本P队列</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/steal_goroutine_from_other_p/>从其他P队列</a></li></ul></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/>调度到达时机</a><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/active_scheduling/>主动调度</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/passive_scheduling/>被动调度</a></li><li><input type=checkbox id=section-740657f38f0c4de9a986bda642ff0388 class=toggle checked>
<label for=section-740657f38f0c4de9a986bda642ff0388 class="flex justify-between"><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/>剥夺调度</a></label><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/start_sysmon/>开启系统监控</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/user_code_preemption/>代码执行过久</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/system_call_preemption/ class=active>陷入系统调用</a></li></ul></li></ul></li></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script><script src=/go-goroutine/magic.js></script><script src=/go-goroutine/dark.js></script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/go-goroutine/svg/menu.svg class=book-icon alt=Menu>
</label><strong>陷入系统调用</strong>
<label for=toc-control><img src=/go-goroutine/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#执行系统调用抢占>执行系统调用抢占</a><ul><li><a href=#handoffp>handoffp</a></li></ul></li><li><a href=#系统调用收尾如从系统调用返回如何重新得到p>系统调用收尾,如从系统调用返回,如何重新得到P</a><ul><li><a href=#定义程序>定义程序</a></li><li><a href=#gdb调试前准备>gdb调试前准备</a><ul><li><a href=#编译程序>编译程序</a></li><li><a href=#准备mcall函数断点的文件>准备mcall函数断点的文件</a></li></ul></li><li><a href=#gdb>gdb</a><ul><li><a href=#entersyscall>entersyscall</a><ul><li><a href=#reentersyscall>reentersyscall</a></li></ul></li><li><a href=#exitsyscall>exitsyscall</a><ul><li></li><li><a href=#mcallexitsyscall0>mcall(exitsyscall0)</a></li></ul></li></ul></li><li><a href=#syscalltick>syscalltick</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=执行系统调用抢占>执行系统调用抢占
<a class=anchor href=#%e6%89%a7%e8%a1%8c%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e6%8a%a2%e5%8d%a0>#</a></h1><h2 id=handoffp>handoffp
<a class=anchor href=#handoffp>#</a></h2><blockquote><p>handoffp函数:判断是否需要启动工作线程来接管_p_，如果不需要则把_p_放入P的全局空闲队列.</p></blockquote><p>如果<strong>当前P的运行队列有任务/全局队列有任务</strong>，<strong>有gc任务</strong>，<strong>大概率整个系统有任务待做</strong>，或者<strong>当前P是最后一个P要用作轮询网络</strong></p><blockquote><p>其中大概率整个系统有任务待做: 由第24行 <code>atomic.Load(&amp;sched.nmspinning)+atomic.Load(&amp;sched.npidle) == 0</code> 决定:</p><blockquote><p>如果没有P空闲，而且这些没空闲的P连接的M不是处在自旋状态(没有自旋的M)，证明其他P都在工作(<strong>而不是假装工作实际是在伺机从其他队列偷任务那种</strong>),是不是说明整个系统除了当前P外都在做事，所以大概率某些P的运行队列上有任务积压，所以我们应该启动M,让它跟当前P连接，去别的P中偷任务)</p></blockquote></blockquote><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style=background-color:#3c3d38><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span></span><span style=background-color:#3c3d38><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span></span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style=background-color:#3c3d38><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span></span><span style=background-color:#3c3d38><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span></span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style=background-color:#3c3d38><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span></span><span style=background-color:#3c3d38><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span></span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">42
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">43
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">44
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">45
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">46
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">47
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">48
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">49
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">50
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">51
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">52
</span><span style=background-color:#3c3d38><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">53
</span></span><span style=background-color:#3c3d38><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">54
</span></span><span style=background-color:#3c3d38><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">55
</span></span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">56
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">57
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">58
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">59
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">60
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Hands off P from syscall or locked M.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Always runs without a P, so write barriers are not allowed.
</span></span></span><span style=display:flex><span><span style=color:#75715e>//go:nowritebarrierrec
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>handoffp</span>(<span style=color:#a6e22e>_p_</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>p</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// handoffp must start an M in any situation where
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// findrunnable would return a G to run on _p_.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// if it has local work, start it straight away
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 如果本地P中运行队列不为空/全局运行队列不为空就调用startm函数
</span></span></span><span style=display:flex;background-color:#3c3d38><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>runqempty</span>(<span style=color:#a6e22e>_p_</span>) <span style=color:#f92672>||</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>runqsize</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex;background-color:#3c3d38><span>		<span style=color:#a6e22e>startm</span>(<span style=color:#a6e22e>_p_</span>, <span style=color:#66d9ef>false</span>) <span style=color:#75715e>// 这个我们前面讨论过,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// if it has GC work, start it straight away 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 如果有GC任务，就调用startm函数
</span></span></span><span style=display:flex;background-color:#3c3d38><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gcBlackenEnabled</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>gcMarkWorkAvailable</span>(<span style=color:#a6e22e>_p_</span>) {
</span></span><span style=display:flex;background-color:#3c3d38><span>		<span style=color:#a6e22e>startm</span>(<span style=color:#a6e22e>_p_</span>, <span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// no local work, check that there are no spinning/idle M&#39;s,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// otherwise our help is not required
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 没有自旋状态的M,且没有空闲的P(所有其它p都在运行goroutine,所有的M都在运行/睡眠)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 只能说明系统比较忙， ??? 需要启动m ???
</span></span></span><span style=display:flex;background-color:#3c3d38><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>nmspinning</span>)<span style=color:#f92672>+</span><span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>npidle</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Cas</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>nmspinning</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>) { <span style=color:#75715e>// TODO: fast atomic
</span></span></span><span style=display:flex;background-color:#3c3d38><span><span style=color:#75715e></span>		<span style=color:#a6e22e>startm</span>(<span style=color:#a6e22e>_p_</span>, <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>gcwaiting</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>status</span> = <span style=color:#a6e22e>_Pgcstop</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>stopwait</span><span style=color:#f92672>--</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>stopwait</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>notewakeup</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>stopnote</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runSafePointFn</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Cas</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runSafePointFn</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>safePointFn</span>(<span style=color:#a6e22e>_p_</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>safePointWait</span><span style=color:#f92672>--</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>safePointWait</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>notewakeup</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>safePointNote</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>runqsize</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> { <span style=color:#75715e>// 全局运行队列大小不是0; 说明Goroutine需要运行,有工作要做.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>startm</span>(<span style=color:#a6e22e>_p_</span>, <span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// If this is the last running P and nobody is polling network,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// need to wakeup another M to poll network.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 如果只有当前P还在运行;需要唤醒别的M来轮询网络
</span></span></span><span style=display:flex;background-color:#3c3d38><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>npidle</span> <span style=color:#f92672>==</span> uint32(<span style=color:#a6e22e>gomaxprocs</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load64</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lastpoll</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex;background-color:#3c3d38><span>		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex;background-color:#3c3d38><span>		<span style=color:#a6e22e>startm</span>(<span style=color:#a6e22e>_p_</span>, <span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pidleput</span>(<span style=color:#a6e22e>_p_</span>)  <span style=color:#75715e>// 无事可做，把p放入全局空闲队列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>}</span></span></code></pre></td></tr></table></div></div><p>其中startm函数我们前面介绍过
<a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/passive_scheduling/#startm class="book-btn ...">startm
</a>：</p><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220629170524.png alt=20220629170524></p><h1 id=系统调用收尾如从系统调用返回如何重新得到p>系统调用收尾,如从系统调用返回,如何重新得到P
<a class=anchor href=#%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e6%94%b6%e5%b0%be%e5%a6%82%e4%bb%8e%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e8%bf%94%e5%9b%9e%e5%a6%82%e4%bd%95%e9%87%8d%e6%96%b0%e5%be%97%e5%88%b0p>#</a></h1><h2 id=定义程序>定义程序
<a class=anchor href=#%e5%ae%9a%e4%b9%89%e7%a8%8b%e5%ba%8f>#</a></h2><blockquote><p>main.go</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;os&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>path</span> = <span style=color:#e6db74>&#34;appss.txt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>isError</span>(<span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>Error</span>())
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (<span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>file</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>OpenFile</span>(<span style=color:#a6e22e>path</span>, <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>O_RDWR</span>, <span style=color:#ae81ff>0644</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>isError</span>(<span style=color:#a6e22e>err</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>file</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=gdb调试前准备>gdb调试前准备
<a class=anchor href=#gdb%e8%b0%83%e8%af%95%e5%89%8d%e5%87%86%e5%a4%87>#</a></h2><h3 id=编译程序>编译程序
<a class=anchor href=#%e7%bc%96%e8%af%91%e7%a8%8b%e5%ba%8f>#</a></h3><p>编译一下源代码: <code>go build -gcflags "-N -l" -o test .</code>.</p><h3 id=准备mcall函数断点的文件>准备mcall函数断点的文件
<a class=anchor href=#%e5%87%86%e5%a4%87mcall%e5%87%bd%e6%95%b0%e6%96%ad%e7%82%b9%e7%9a%84%e6%96%87%e4%bb%b6>#</a></h3><ul><li>gdb<ul><li><code>list /usr/lib/golang/src/syscall/zsyscall_linux_amd64.go:62</code></li><li><code>list /usr/lib/golang/src/syscall/asm_linux_amd64.s:44</code></li></ul></li></ul><h2 id=gdb>gdb
<a class=anchor href=#gdb>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>TEXT</span> <span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>Syscall6</span>(<span style=color:#a6e22e>SB</span>),<span style=color:#a6e22e>NOSPLIT</span>,<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span><span style=color:#f92672>-</span><span style=color:#ae81ff>80</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>CALL</span>	<span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>entersyscall</span>(<span style=color:#a6e22e>SB</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>a1</span><span style=color:#f92672>+</span><span style=color:#ae81ff>8</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>DI</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>a2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>16</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>SI</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>a3</span><span style=color:#f92672>+</span><span style=color:#ae81ff>24</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>DX</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>a4</span><span style=color:#f92672>+</span><span style=color:#ae81ff>32</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>R10</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>a5</span><span style=color:#f92672>+</span><span style=color:#ae81ff>40</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>R8</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>a6</span><span style=color:#f92672>+</span><span style=color:#ae81ff>48</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>R9</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>SYSCALL</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>CMPQ</span>	<span style=color:#a6e22e>AX</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0xfffffffffffff001</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>JLS</span>	<span style=color:#a6e22e>ok6</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>r1</span><span style=color:#f92672>+</span><span style=color:#ae81ff>56</span>(<span style=color:#a6e22e>FP</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>r2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>64</span>(<span style=color:#a6e22e>FP</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>NEGQ</span>	<span style=color:#a6e22e>AX</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>AX</span>, <span style=color:#a6e22e>err</span><span style=color:#f92672>+</span><span style=color:#ae81ff>72</span>(<span style=color:#a6e22e>FP</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>CALL</span>	<span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>exitsyscall</span>(<span style=color:#a6e22e>SB</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>RET</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ok6</span>:
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>AX</span>, <span style=color:#a6e22e>r1</span><span style=color:#f92672>+</span><span style=color:#ae81ff>56</span>(<span style=color:#a6e22e>FP</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>DX</span>, <span style=color:#a6e22e>r2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>64</span>(<span style=color:#a6e22e>FP</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>err</span><span style=color:#f92672>+</span><span style=color:#ae81ff>72</span>(<span style=color:#a6e22e>FP</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>CALL</span>	<span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>exitsyscall</span>(<span style=color:#a6e22e>SB</span>)
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>RET</span>
</span></span></code></pre></div><h3 id=entersyscall>entersyscall
<a class=anchor href=#entersyscall>#</a></h3><blockquote><p><code>src/runtime/proc.go</code></p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>entersyscall</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>reentersyscall</span>(<span style=color:#a6e22e>getcallerpc</span>(), <span style=color:#a6e22e>getcallersp</span>()) <span style=color:#75715e>// 这个是Goroutine的pc, sp,不是g0的，因为还没有切换栈。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h4 id=reentersyscall>reentersyscall
<a class=anchor href=#reentersyscall>#</a></h4><ul><li>reentersyscall主要是做三件事:<ul><li>把PC,SP保存到当前Goroutine.sched里面;</li><li>解除M与P两者之间的关系;</li><li>设置P的状态为_Psyscall</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>- 把PC,SP保存到当前Goroutine.sched里面;
</span></span></span><span style=display:flex><span><span style=color:#75715e>- 解除M与P两者之间的关系;
</span></span></span><span style=display:flex><span><span style=color:#75715e>- 设置P的状态为_Psyscall
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>reentersyscall</span>(<span style=color:#a6e22e>pc</span>, <span style=color:#a6e22e>sp</span> <span style=color:#66d9ef>uintptr</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_g_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>() <span style=color:#75715e>// get Goroutine的g
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Disable preemption because during this function g is in Gsyscall status,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// but can have inconsistent g-&gt;sched, do not let GC observe it.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>locks</span><span style=color:#f92672>++</span> <span style=color:#75715e>// ++就能让GC不能观察到？TODO zxc:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Entersyscall must not call any function that might split/grow the stack.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// (See details in comment above.)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Catch calls that might, by replacing the stack guard with something that
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// will trip any stack check and leaving a flag to tell newstack to die.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>stackguard0</span> = <span style=color:#a6e22e>stackPreempt</span> <span style=color:#75715e>//进入系统调用前就设置了抢占标志。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>throwsplit</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Leave SP around for GC and traceback.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>save</span>(<span style=color:#a6e22e>pc</span>, <span style=color:#a6e22e>sp</span>) <span style=color:#75715e>//保存寄存器的值到当前Goroutine的sched结构体。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>syscallsp</span> = <span style=color:#a6e22e>sp</span> <span style=color:#75715e>//gc使用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>syscallpc</span> = <span style=color:#a6e22e>pc</span> <span style=color:#75715e>//gc使用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>casgstatus</span>(<span style=color:#a6e22e>_g_</span>, <span style=color:#a6e22e>_Grunning</span>, <span style=color:#a6e22e>_Gsyscall</span>) <span style=color:#75715e>// 修改状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>syscallsp</span> &lt; <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>lo</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>hi</span> &lt; <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>syscallsp</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>systemstack</span>(<span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>			print(<span style=color:#e6db74>&#34;entersyscall inconsistent &#34;</span>, <span style=color:#a6e22e>hex</span>(<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>syscallsp</span>), <span style=color:#e6db74>&#34; [&#34;</span>, <span style=color:#a6e22e>hex</span>(<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>lo</span>), <span style=color:#e6db74>&#34;,&#34;</span>, <span style=color:#a6e22e>hex</span>(<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>hi</span>), <span style=color:#e6db74>&#34;]\n&#34;</span>)
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;entersyscall&#34;</span>)
</span></span><span style=display:flex><span>		})
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>trace</span>.<span style=color:#a6e22e>enabled</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>systemstack</span>(<span style=color:#a6e22e>traceGoSysCall</span>)
</span></span><span style=display:flex><span>		<span style=color:#75715e>// systemstack itself clobbers g.sched.{pc,sp} and we might
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// need them later when the G is genuinely blocked in a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// syscall
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>save</span>(<span style=color:#a6e22e>pc</span>, <span style=color:#a6e22e>sp</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>sysmonwait</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>systemstack</span>(<span style=color:#a6e22e>entersyscall_sysmon</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>save</span>(<span style=color:#a6e22e>pc</span>, <span style=color:#a6e22e>sp</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>().<span style=color:#a6e22e>runSafePointFn</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// runSafePointFn may stack split if run on this stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>systemstack</span>(<span style=color:#a6e22e>runSafePointFn</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>save</span>(<span style=color:#a6e22e>pc</span>, <span style=color:#a6e22e>sp</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>syscalltick</span> = <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>().<span style=color:#a6e22e>syscalltick</span> <span style=color:#75715e>//把P的syscalltick,放到m中。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>sysblocktraced</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>mcache</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>m</span> = <span style=color:#ae81ff>0</span> <span style=color:#75715e>// 解除P与M的关系。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>oldp</span>.<span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>pp</span>) <span style=color:#75715e>// 把现在的P放到M中的oldp中。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span> = <span style=color:#ae81ff>0</span> <span style=color:#75715e>// 解除M与P的关系。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Store</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>status</span>, <span style=color:#a6e22e>_Psyscall</span>) <span style=color:#75715e>// 修改P的状态为系统调用。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>gcwaiting</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>systemstack</span>(<span style=color:#a6e22e>entersyscall_gcwait</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>save</span>(<span style=color:#a6e22e>pc</span>, <span style=color:#a6e22e>sp</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>locks</span><span style=color:#f92672>--</span> <span style=color:#75715e>// --解除锁定。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><ul><li><blockquote><p>这里需要注意的是：在进入系统调用的时候，它是没有进行自增的，它是在<code>exitsyscall()</code>函数才开始进行自增的；</p></blockquote></li><li><blockquote><p>这个就是为了判断P，在当前Goroutine进入系统调用，到返回的那一段时间，这个P有可能又被其他M关联，然后又进入_Psyscall状态，<code>_g_.m.syscalltick = _g_.m.p.ptr().syscalltick //把P的syscalltick,放到m中。</code></p></blockquote></li></ul><h3 id=exitsyscall>exitsyscall
<a class=anchor href=#exitsyscall>#</a></h3><ul><li>这个退出系统调用：<ul><li>尝试重新绑定oldp,如果没有成功，从全局空闲P队列获得一个P。</li><li>如果还是失败，mcall&ndash;>exitsyscall0()，<ul><li>在这个里面再次从全局空闲P队列中尝试下，如果失败就把Goroutine放入全局空闲G队列;</li><li>M放入全局空闲M队列,休眠M;</li><li>schedule().</li></ul></li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>这个退出系统调用：
</span></span></span><span style=display:flex><span><span style=color:#75715e>  - 尝试重新绑定oldp,如果没有成功，从全局空闲P队列获得一个P。
</span></span></span><span style=display:flex><span><span style=color:#75715e>  - 如果还是失败，mcall--&gt;exitsyscall0()，
</span></span></span><span style=display:flex><span><span style=color:#75715e>    - 在这个里面再次从全局空闲P队列中尝试下，如果失败就把Goroutine放入全局空闲G队列;
</span></span></span><span style=display:flex><span><span style=color:#75715e>    - M放入全局空闲M队列,休眠M;
</span></span></span><span style=display:flex><span><span style=color:#75715e>    - schedule().
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>exitsyscall</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_g_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>locks</span><span style=color:#f92672>++</span> <span style=color:#75715e>// see comment in entersyscall 防止GC？ TODO zxc:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>getcallersp</span>() &gt; <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>syscallsp</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;exitsyscall: syscall frame is no longer valid&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>waitsince</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>oldp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>oldp</span>.<span style=color:#a6e22e>ptr</span>() <span style=color:#75715e>//重新取出oldp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>oldp</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>exitsyscallfast</span>(<span style=color:#a6e22e>oldp</span>) { <span style=color:#75715e>//如果返回true，那么M与P在这个里面已经重新关联了。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>mcache</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;lost mcache&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>trace</span>.<span style=color:#a6e22e>enabled</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>oldp</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>() <span style=color:#f92672>||</span> <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>syscalltick</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>().<span style=color:#a6e22e>syscalltick</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>systemstack</span>(<span style=color:#a6e22e>traceGoStart</span>)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#75715e>// There&#39;s a cpu for us, so we can run.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>().<span style=color:#a6e22e>syscalltick</span><span style=color:#f92672>++</span> <span style=color:#75715e>//系统调用完成，syscalltick自增。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// We need to cas the status and scan before resuming...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>casgstatus</span>(<span style=color:#a6e22e>_g_</span>, <span style=color:#a6e22e>_Gsyscall</span>, <span style=color:#a6e22e>_Grunning</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Garbage collector isn&#39;t running (since we are),
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// so okay to clear syscallsp.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>syscallsp</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>locks</span><span style=color:#f92672>--</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>preempt</span> {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// restore the preemption request in case we&#39;ve cleared it in newstack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>stackguard0</span> = <span style=color:#a6e22e>stackPreempt</span>
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// otherwise restore the real _StackGuard, we&#39;ve spoiled it in entersyscall/entersyscallblock
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>stackguard0</span> = <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>lo</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>_StackGuard</span> <span style=color:#75715e>//在entersyscall里面我们设置_g_.stackguard0 = stackPreempt //进入系统调用前就设置了抢占标志。这里要恢复。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>throwsplit</span> = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>disable</span>.<span style=color:#a6e22e>user</span> <span style=color:#f92672>&amp;&amp;</span> !<span style=color:#a6e22e>schedEnabled</span>(<span style=color:#a6e22e>_g_</span>) {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// Scheduling of this goroutine is disabled.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>Gosched</span>()
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>sysexitticks</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>trace</span>.<span style=color:#a6e22e>enabled</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Wait till traceGoSysBlock event is emitted.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// This ensures consistency of the trace (the goroutine is started after it is blocked).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>oldp</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>oldp</span>.<span style=color:#a6e22e>syscalltick</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>syscalltick</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>osyield</span>()
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#75715e>// We can&#39;t trace syscall exit right now because we don&#39;t have a P.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// Tracing code can invoke write barriers that cannot run without a P.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// So instead we remember the syscall exit time and emit the event
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// in execute when we have a P.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>sysexitticks</span> = <span style=color:#a6e22e>cputicks</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>locks</span><span style=color:#f92672>--</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Call the scheduler.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>mcall</span>(<span style=color:#a6e22e>exitsyscall0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>mcache</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;lost mcache&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Scheduler returned, so we&#39;re allowed to run now.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Delete the syscallsp information that we left for
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// the garbage collector during the system call.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Must wait until now because until gosched returns
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// we don&#39;t know for sure that the garbage collector
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// is not running.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>syscallsp</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>().<span style=color:#a6e22e>syscalltick</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>throwsplit</span> = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=exitsyscallfast>exitsyscallfast
<a class=anchor href=#exitsyscallfast>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>//go:nosplit
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>exitsyscallfast</span>(<span style=color:#a6e22e>oldp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>p</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_g_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Freezetheworld sets stopwait but does not retake P&#39;s.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>stopwait</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>freezeStopWait</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Try to re-acquire the last P.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>oldp</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>oldp</span>.<span style=color:#a6e22e>status</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>_Psyscall</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Cas</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>oldp</span>.<span style=color:#a6e22e>status</span>, <span style=color:#a6e22e>_Psyscall</span>, <span style=color:#a6e22e>_Pidle</span>) {
</span></span><span style=display:flex><span>		<span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>			- 查看老的P的状态是否是正处于_Psyscall;
</span></span></span><span style=display:flex><span><span style=color:#75715e>		      - 从reentersyscall里面的三个步骤，当它设置为_Psyscall, 它这个时候是没有与任何M相关联。
</span></span></span><span style=display:flex><span><span style=color:#75715e>		      - 所以这里如果发现P又处于_psyscall，直接关联。
</span></span></span><span style=display:flex><span><span style=color:#75715e>		*/</span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// There&#39;s a cpu for us, so we can run.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>wirep</span>(<span style=color:#a6e22e>oldp</span>) <span style=color:#75715e>// 关联M和P；当前的M和这个oldp。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>exitsyscallfast_reacquired</span>()
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Try to get any other idle P.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>pidle</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ok</span> <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>systemstack</span>(<span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>ok</span> = <span style=color:#a6e22e>exitsyscallfast_pidle</span>()
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ok</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>trace</span>.<span style=color:#a6e22e>enabled</span> {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>oldp</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>					<span style=color:#75715e>// Wait till traceGoSysBlock event is emitted.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>					<span style=color:#75715e>// This ensures consistency of the trace (the goroutine is started after it is blocked).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>					<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>oldp</span>.<span style=color:#a6e22e>syscalltick</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>syscalltick</span> {
</span></span><span style=display:flex><span>						<span style=color:#a6e22e>osyield</span>()
</span></span><span style=display:flex><span>					}
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>traceGoSysExit</span>(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		})
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h6 id=exitsyscallfast_reacquired>exitsyscallfast_reacquired
<a class=anchor href=#exitsyscallfast_reacquired>#</a></h6><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>exitsyscallfast_reacquired</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_g_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>syscalltick</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>().<span style=color:#a6e22e>syscalltick</span> { <span style=color:#75715e>// 如果他们两者不相等，那么说明该p被收回，然后再次进入syscall(因为_g_.m.syscalltick变了)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>trace</span>.<span style=color:#a6e22e>enabled</span> {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// The p was retaken and then enter into syscall again (since _g_.m.syscalltick has changed).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// traceGoSysBlock for this syscall was already emitted,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// but here we effectively retake the p from the new syscall running on the same p.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>systemstack</span>(<span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>				<span style=color:#75715e>// Denote blocking of the new syscall.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#a6e22e>traceGoSysBlock</span>(<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>())
</span></span><span style=display:flex><span>				<span style=color:#75715e>// Denote completion of the current syscall.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#a6e22e>traceGoSysExit</span>(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>			})
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>().<span style=color:#a6e22e>syscalltick</span><span style=color:#f92672>++</span> <span style=color:#75715e>// 这里又开始自增了---&gt;因为它在进入reentersyscall()函数是不能增加这个值的。只有当退出exitsyscall()函数才会自增，所以如果
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=mcallexitsyscall0>mcall(exitsyscall0)
<a class=anchor href=#mcallexitsyscall0>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// exitsyscall slow path on g0.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Failed to acquire P, enqueue gp as runnable.
</span></span></span><span style=display:flex><span><span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e>//go:nowritebarrierrec
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>exitsyscall0</span>(<span style=color:#a6e22e>gp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_g_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>casgstatus</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>_Gsyscall</span>, <span style=color:#a6e22e>_Grunnable</span>) <span style=color:#75715e>//从系统调用状态转变为可运行状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>dropg</span>() <span style=color:#75715e>//断开M与G之间的关系
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lock</span>) <span style=color:#75715e>//要修改全局的sched,先加锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>_p_</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>p</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>schedEnabled</span>(<span style=color:#a6e22e>_g_</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>_p_</span> = <span style=color:#a6e22e>pidleget</span>() <span style=color:#75715e>//从全局空闲P队列获取一个P
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_p_</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>globrunqput</span>(<span style=color:#a6e22e>gp</span>) <span style=color:#75715e>//如果没有获取P，那么把Goroutine放入全局空闲g队列。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	} <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>sysmonwait</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Store</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>sysmonwait</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>notewakeup</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>sysmonnote</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_p_</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> { <span style=color:#75715e>//如果有获取到P。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>acquirep</span>(<span style=color:#a6e22e>_p_</span>) <span style=color:#75715e>// 关联P与M
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>execute</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#66d9ef>false</span>) <span style=color:#75715e>// Never returns. 直接执行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>lockedg</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> { <span style=color:#75715e>// TODO zxc: 我记得是这个某个g,必须运行在某个线程上面，比如，main.main.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// Wait until another thread schedules gp and so m again.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>stoplockedm</span>()
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>execute</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#66d9ef>false</span>) <span style=color:#75715e>// Never returns.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>stopm</span>() <span style=color:#75715e>//停止M。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>schedule</span>() <span style=color:#75715e>// Never returns.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h2 id=syscalltick>syscalltick
<a class=anchor href=#syscalltick>#</a></h2><p>这个<code>syscalltick</code>;发现不是每次系统调用一次，才增加一次。</p><p>在我们这里，</p><ul><li>entersystem<ul><li><em>g</em>.m.syscalltick = <em>g</em>.m.p.ptr().syscalltick</li></ul></li><li>existsystem<ul><li>exitsyscall主函数里面有一次;</li><li>exitsyscallfast_reacquired函数又增加了一次.</li></ul></li></ul><p>// To ensure that traceGoSysExit is emitted strictly after traceGoSysBlock,
// we remember current value of syscalltick in m (<em>g</em>.m.syscalltick = <em>g</em>.m.p.ptr().syscalltick),
// whoever emits traceGoSysBlock increments p.syscalltick afterwards;
// and we wait for the increment before emitting traceGoSysExit.
// Note that the increment is done even if tracing is not enabled,
// because tracing can be enabled in the middle of syscall. We don&rsquo;t want the wait to hang.</p><p>// 为了确保traceGoSysExit严格在traceGoSysBlock之后发出。
// 我们记住m中syscalltick的当前值(<em>g</em>.m.syscalltick = <em>g</em>.m.p.ptr().syscalltick)。
// 不管是谁发出traceGoSysBlock，都会在之后增量p.syscalltick。
// 我们等待增量后再发出 traceGoSysExit。
// 注意，即使没有启用跟踪，增量也会被完成。
// 因为跟踪可以在syscall中间启用。我们不希望等待被挂起。</p><p>在这个解释里面,发现跟踪的时候也会<code>syscalltick</code></p><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20200923134905.png alt=syscall返回></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><script src=https://giscus.app/client.js data-repo=zput/utterances-comments data-repo-id=R_kgDOHhATGQ data-category=Announcements data-category-id=DIC_kwDOHhATGc4CPxca data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=1 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#执行系统调用抢占>执行系统调用抢占</a><ul><li><a href=#handoffp>handoffp</a></li></ul></li><li><a href=#系统调用收尾如从系统调用返回如何重新得到p>系统调用收尾,如从系统调用返回,如何重新得到P</a><ul><li><a href=#定义程序>定义程序</a></li><li><a href=#gdb调试前准备>gdb调试前准备</a><ul><li><a href=#编译程序>编译程序</a></li><li><a href=#准备mcall函数断点的文件>准备mcall函数断点的文件</a></li></ul></li><li><a href=#gdb>gdb</a><ul><li><a href=#entersyscall>entersyscall</a><ul><li><a href=#reentersyscall>reentersyscall</a></li></ul></li><li><a href=#exitsyscall>exitsyscall</a><ul><li></li><li><a href=#mcallexitsyscall0>mcall(exitsyscall0)</a></li></ul></li></ul></li><li><a href=#syscalltick>syscalltick</a></li></ul></li></ul></nav></div></aside></main></body></html><script type=text/javascript src=https://cdn.bootcss.com/viz.js/1.8.2/viz.js></script><script type=text/javascript>(function(){var e="language-viz-";Array.prototype.forEach.call(document.querySelectorAll("[class^="+e+"]"),function(t){console.log(t),t.getAttribute("class").split(" ").forEach(function(t){t.startsWith(e)&&(s=t.substr(e.length))}),console.log("------------MIDDLE--------");var s,o=Viz(t.innerText,{format:"svg",engine:s}),n=(new DOMParser).parseFromString(o,"image/svg+xml");n.documentElement.setAttribute("style","max-width:100%; max-height:100%;"),t.parentNode.insertBefore(n.documentElement,t),t.style.display="none",t.parentNode.style.backgroundColor="white",t.style.width=n.documentElement.getAttribute("width")+"px",t.style.height=n.documentElement.getAttribute("height")+"px",console.log("--------------END------")})})()</script>