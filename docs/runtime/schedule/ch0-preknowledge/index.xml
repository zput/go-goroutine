<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>前置知识 on go调度源码分析</title><link>https://zput.github.io/go-goroutine/docs/runtime/schedule/ch0-preknowledge/</link><description>Recent content in 前置知识 on go调度源码分析</description><generator>Hugo</generator><language>zh</language><lastBuildDate>Thu, 28 Feb 2019 15:03:00 +0000</lastBuildDate><atom:link href="https://zput.github.io/go-goroutine/docs/runtime/schedule/ch0-preknowledge/index.xml" rel="self" type="application/rss+xml"/><item><title>伪寄存器与函数栈帧</title><link>https://zput.github.io/go-goroutine/docs/runtime/schedule/ch0-preknowledge/register_functionstack/</link><pubDate>Thu, 28 Feb 2019 15:03:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/schedule/ch0-preknowledge/register_functionstack/</guid><description>&lt;h1 id="伪寄存器--函数栈">
 伪寄存器 &amp;amp; 函数栈
 &lt;a class="anchor" href="#%e4%bc%aa%e5%af%84%e5%ad%98%e5%99%a8--%e5%87%bd%e6%95%b0%e6%a0%88">#&lt;/a>
&lt;/h1>
&lt;h2 id="伪寄存器">
 伪寄存器
 &lt;a class="anchor" href="#%e4%bc%aa%e5%af%84%e5%ad%98%e5%99%a8">#&lt;/a>
&lt;/h2>
&lt;p>伪寄存器常用的一般是下面的四个:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">FP&lt;/span>: &lt;span style="color:#a6e22e">Frame&lt;/span> &lt;span style="color:#a6e22e">pointer&lt;/span>: &lt;span style="color:#a6e22e">arguments&lt;/span> &lt;span style="color:#a6e22e">and&lt;/span> &lt;span style="color:#a6e22e">locals&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PC&lt;/span>: &lt;span style="color:#a6e22e">Program&lt;/span> &lt;span style="color:#a6e22e">counter&lt;/span>: &lt;span style="color:#a6e22e">jumps&lt;/span> &lt;span style="color:#a6e22e">and&lt;/span> &lt;span style="color:#a6e22e">branches&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">SB&lt;/span>: &lt;span style="color:#a6e22e">Static&lt;/span> &lt;span style="color:#a6e22e">base&lt;/span> &lt;span style="color:#a6e22e">pointer&lt;/span>: &lt;span style="color:#a6e22e">global&lt;/span> &lt;span style="color:#a6e22e">symbols&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">SP&lt;/span>: &lt;span style="color:#a6e22e">Stack&lt;/span> &lt;span style="color:#a6e22e">pointer&lt;/span>: &lt;span style="color:#a6e22e">top&lt;/span> &lt;span style="color:#a6e22e">of&lt;/span> &lt;span style="color:#a6e22e">stack&lt;/span>.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>下面我们来翻译一下
 &lt;a href="https://golang.org/doc/asm#symbols">官网&lt;sup>1&lt;/sup>&lt;/a>的对他们的解释，然后做一个总结,方便理解。&lt;/p>
&lt;h3 id="fp">
 FP
 &lt;a class="anchor" href="#fp">#&lt;/a>
&lt;/h3>
&lt;blockquote>
&lt;p>FP伪寄存器是一个用于引用&lt;strong>函数参数&lt;/strong>的虚拟帧指针。编译器维护一个虚拟帧指针，并将堆栈上的参数引用为该伪寄存器的偏移量。因此0(FP)是函数的第一个参数，8(FP)是第二个参数(在64位机器上)，以此类推。但是，当以这种方式引用一个函数参数时，有必要将名称放在开头，如first_arg+0(FP)和second_arg+8(FP)。(偏移量的含义(从帧指针出发的偏移量)与它在SB中的使用不同，在SB中，它是从符号出发的偏移量。) 汇编器强制执行这个约定，拒绝普通的0(FP)和8(FP)。实际的名称在语义上是不相关的，但应该用来记录参数的名称。值得强调的是，FP始终是一个伪寄存器，而不是硬件寄存器，即使在具有硬件帧指针的架构上也是如此。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>The FP pseudo-register is a virtual frame pointer used to refer to function arguments. The compilers maintain a virtual frame pointer and refer to the arguments on the stack as offsets from that pseudo-register. Thus 0(FP) is the first argument to the function, 8(FP) is the second (on a 64-bit machine), and so on. However, when referring to a function argument this way, it is necessary to place a name at the beginning, as in first_arg+0(FP) and second_arg+8(FP). (The meaning of the offset—offset from the frame pointer—distinct from its use with SB, where it is an offset from the symbol.) The assembler enforces this convention, rejecting plain 0(FP) and 8(FP). The actual name is semantically irrelevant but should be used to document the argument&amp;rsquo;s name. It is worth stressing that FP is always a pseudo-register, not a hardware register, even on architectures with a hardware frame pointer.&lt;/p></description></item><item><title>类汇编</title><link>https://zput.github.io/go-goroutine/docs/runtime/schedule/ch0-preknowledge/similar_assemble/</link><pubDate>Thu, 28 Feb 2019 15:03:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/schedule/ch0-preknowledge/similar_assemble/</guid><description>&lt;h2 id="golang类汇编指令">
 golang类汇编指令
 &lt;a class="anchor" href="#golang%e7%b1%bb%e6%b1%87%e7%bc%96%e6%8c%87%e4%bb%a4">#&lt;/a>
&lt;/h2>
&lt;h3 id="寻址模式">
 寻址模式
 &lt;a class="anchor" href="#%e5%af%bb%e5%9d%80%e6%a8%a1%e5%bc%8f">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>(DI)(BX&lt;em>2): The location at address DI plus BX&lt;/em>2.&lt;/li>
&lt;li>64(DI)(BX&lt;em>2): The location at address DI plus BX&lt;/em>2 plus 64. These modes accept only 1, 2, 4, and 8 as scale factors.&lt;/li>
&lt;/ul>
&lt;h3 id="结构体寄存器">
 结构体+寄存器
 &lt;a class="anchor" href="#%e7%bb%93%e6%9e%84%e4%bd%93%e5%af%84%e5%ad%98%e5%99%a8">#&lt;/a>
&lt;/h3>
&lt;p>类似这种:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># (m_morebuf+gobuf_pc)(REGISTER)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">MOVQ&lt;/span>	&lt;span style="color:#ae81ff">8&lt;/span>(&lt;span style="color:#66d9ef">SP&lt;/span>), &lt;span style="color:#66d9ef">AX&lt;/span>	&lt;span style="color:#75715e"># f&amp;#39;s caller&amp;#39;s PC
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#a6e22e">MOVQ&lt;/span>	&lt;span style="color:#66d9ef">AX&lt;/span>, (&lt;span style="color:#66d9ef">m_morebuf&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">+&lt;/span>&lt;span style="color:#66d9ef">gobuf_pc&lt;/span>)(&lt;span style="color:#66d9ef">BX&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-golang" data-lang="golang">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">g0&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">g&lt;/span> &lt;span style="color:#75715e">// goroutine with scheduling stack
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#3c3d38">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#a6e22e">morebuf&lt;/span> &lt;span style="color:#a6e22e">gobuf&lt;/span> &lt;span style="color:#75715e">// gobuf arg to morestack //-----------morebuf-------------//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#a6e22e">divmod&lt;/span> &lt;span style="color:#66d9ef">uint32&lt;/span> &lt;span style="color:#75715e">// div/mod denominator for arm - known to liblink
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#75715e">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">gobuf&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">// The offsets of sp, pc, and g are known to (hard-coded in) libmach.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#75715e">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#75715e">// ctxt is unusual with respect to GC: it may be a
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#75715e">// heap-allocated funcval, so GC needs to track it, but it
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#75715e">// needs to be set and cleared from assembly, where it&amp;#39;s
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#75715e">// difficult to have write barriers. However, ctxt is really a
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#75715e">// saved, live register, and we only ever exchange it between
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#75715e">// the real register and the gobuf. Hence, we treat it as a
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#75715e">// root during stack scanning, which means assembly that saves
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#75715e">// and restores it doesn&amp;#39;t need write barriers. It&amp;#39;s still
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#75715e">// typed as a pointer so that any other writes from Go get
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#75715e">// write barriers.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#a6e22e">sp&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#3c3d38">&lt;span>	&lt;span style="color:#a6e22e">pc&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span> &lt;span style="color:#75715e">// &amp;lt;&amp;lt;&amp;lt;--- 
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#a6e22e">g&lt;/span> &lt;span style="color:#a6e22e">guintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">ctxt&lt;/span> &lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">ret&lt;/span> &lt;span style="color:#a6e22e">sys&lt;/span>.&lt;span style="color:#a6e22e">Uintreg&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">lr&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">bp&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span> &lt;span style="color:#75715e">// for GOEXPERIMENT=framepointer
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>我们从这个&lt;code>m_morebuf+gobuf_pc&lt;/code>就知道指的是这个m结构体中的morebuf结构体字段中的pc值。&lt;/p></description></item><item><title>底层重要结构</title><link>https://zput.github.io/go-goroutine/docs/runtime/schedule/ch0-preknowledge/go_underlying_struct/</link><pubDate>Sun, 20 Jan 2019 09:03:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/schedule/ch0-preknowledge/go_underlying_struct/</guid><description>&lt;p>
 &lt;a href="https://blog.tianfeiyu.com/source-code-reading-notes/go/golang_gpm.html">https://blog.tianfeiyu.com/source-code-reading-notes/go/golang_gpm.html&lt;/a>&lt;/p>
&lt;h1 id="g结构">
 g结构
 &lt;a class="anchor" href="#g%e7%bb%93%e6%9e%84">#&lt;/a>
&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">g&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">// 栈相关的两个字段
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#a6e22e">stack&lt;/span> &lt;span style="color:#a6e22e">stack&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">stackguard0&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">stackguard1&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span> &lt;span style="color:#75715e">// offset known to liblink
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">// defer 和 panic 
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#a6e22e">_panic&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">_panic&lt;/span> &lt;span style="color:#75715e">// 最内侧的 panic 结构体
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#a6e22e">_defer&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">_defer&lt;/span> &lt;span style="color:#75715e">// 最内侧的延迟函数结构体
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">sched&lt;/span> &lt;span style="color:#a6e22e">gobuf&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">atomicstatus&lt;/span> &lt;span style="color:#66d9ef">uint32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">goid&lt;/span> &lt;span style="color:#66d9ef">int64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">// 抢占
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#a6e22e">preempt&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#75715e">// 抢占信号
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#a6e22e">preemptStop&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#75715e">// 抢占时将状态修改成 `_Gpreempted`
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#a6e22e">preemptShrink&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#75715e">// 在同步安全点收缩栈
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">gobuf&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">sp&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">pc&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">g&lt;/span> &lt;span style="color:#a6e22e">guintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">ctxt&lt;/span> &lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">ret&lt;/span> &lt;span style="color:#a6e22e">sys&lt;/span>.&lt;span style="color:#a6e22e">Uintreg&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">lr&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">bp&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span> &lt;span style="color:#75715e">// for GOEXPERIMENT=framepointer ------------------------here
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="m结构">
 m结构
 &lt;a class="anchor" href="#m%e7%bb%93%e6%9e%84">#&lt;/a>
&lt;/h1>
&lt;p>
 &lt;a href="https://github.com/golang/go/blob/release-branch.go1.18/src/runtime/runtime2.go#L513">m&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">g0&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">g&lt;/span> &lt;span style="color:#75715e">// goroutine with scheduling stack
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#a6e22e">morebuf&lt;/span> &lt;span style="color:#a6e22e">gobuf&lt;/span> &lt;span style="color:#75715e">// gobuf arg to morestack
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#a6e22e">divmod&lt;/span> &lt;span style="color:#66d9ef">uint32&lt;/span> &lt;span style="color:#75715e">// div/mod denominator for arm - known to liblink
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">// Fields not known to debuggers.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#a6e22e">procid&lt;/span> &lt;span style="color:#66d9ef">uint64&lt;/span> &lt;span style="color:#75715e">// for debuggers, but offset not hard-coded
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#a6e22e">gsignal&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">g&lt;/span> &lt;span style="color:#75715e">// signal-handling g
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#a6e22e">goSigStack&lt;/span> &lt;span style="color:#a6e22e">gsignalStack&lt;/span> &lt;span style="color:#75715e">// Go-allocated signal handling stack
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#a6e22e">sigmask&lt;/span> &lt;span style="color:#a6e22e">sigset&lt;/span> &lt;span style="color:#75715e">// storage for saved signal mask
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#a6e22e">tls&lt;/span> [&lt;span style="color:#ae81ff">6&lt;/span>]&lt;span style="color:#66d9ef">uintptr&lt;/span> &lt;span style="color:#75715e">// thread-local storage (for x86 extern register)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#a6e22e">mstartfn&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">curg&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">g&lt;/span> &lt;span style="color:#75715e">// current running goroutine
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="m的创建与销毁">
 M的创建与销毁
 &lt;a class="anchor" href="#m%e7%9a%84%e5%88%9b%e5%bb%ba%e4%b8%8e%e9%94%80%e6%af%81">#&lt;/a>
&lt;/h2>
&lt;p>M 是 runtime 中的一个对象，代表线程，每创建一个 M 对象同时会创建一个线程与 M 进行绑定，线程的新建是通过执行 clone() 系统调用创建出来的。runtime 中定义 M 的最大数量为 10000 个，用户可以通过debug.SetMaxThreads(n) 进行调整。&lt;/p></description></item></channel></rss>