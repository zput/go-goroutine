<!doctype html><html lang=zh dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  golang类汇编指令
  #


  寻址模式
  #


(DI)(BX2): The location at address DI plus BX2.
64(DI)(BX2): The location at address DI plus BX2 plus 64. These modes accept only 1, 2, 4, and 8 as scale factors.


  结构体+寄存器
  #

类似这种:
# (m_morebuf+gobuf_pc)(REGISTER)

	MOVQ	8(SP), AX	# f's caller's PC
	MOVQ	AX, (m_morebuf+gobuf_pc)(BX)
type m struct {
	g0      *g     // goroutine with scheduling stack
	morebuf gobuf  // gobuf arg to morestack   //-----------morebuf-------------//
	divmod  uint32 // div/mod denominator for arm - known to liblink
	//...
}

type gobuf struct {
	// The offsets of sp, pc, and g are known to (hard-coded in) libmach.
	//
	// ctxt is unusual with respect to GC: it may be a
	// heap-allocated funcval, so GC needs to track it, but it
	// needs to be set and cleared from assembly, where it's
	// difficult to have write barriers. However, ctxt is really a
	// saved, live register, and we only ever exchange it between
	// the real register and the gobuf. Hence, we treat it as a
	// root during stack scanning, which means assembly that saves
	// and restores it doesn't need write barriers. It's still
	// typed as a pointer so that any other writes from Go get
	// write barriers.
	sp   uintptr
	pc   uintptr   // <<<--- 
	g    guintptr
	ctxt unsafe.Pointer
	ret  sys.Uintreg
	lr   uintptr
	bp   uintptr // for GOEXPERIMENT=framepointer
}
我们从这个m_morebuf+gobuf_pc就知道指的是这个m结构体中的morebuf结构体字段中的pc值。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://zput.github.io/go-goroutine/docs/runtime/schedule/ch0-preknowledge/similar_assemble/"><meta property="og:site_name" content="go调度源码分析"><meta property="og:title" content="类汇编"><meta property="og:description" content=" golang类汇编指令 # 寻址模式 # (DI)(BX2): The location at address DI plus BX2. 64(DI)(BX2): The location at address DI plus BX2 plus 64. These modes accept only 1, 2, 4, and 8 as scale factors. 结构体+寄存器 # 类似这种:
# (m_morebuf+gobuf_pc)(REGISTER) MOVQ	8(SP), AX	# f's caller's PC MOVQ	AX, (m_morebuf+gobuf_pc)(BX) type m struct { g0 *g // goroutine with scheduling stack morebuf gobuf // gobuf arg to morestack //-----------morebuf-------------// divmod uint32 // div/mod denominator for arm - known to liblink //... } type gobuf struct { // The offsets of sp, pc, and g are known to (hard-coded in) libmach. // // ctxt is unusual with respect to GC: it may be a // heap-allocated funcval, so GC needs to track it, but it // needs to be set and cleared from assembly, where it's // difficult to have write barriers. However, ctxt is really a // saved, live register, and we only ever exchange it between // the real register and the gobuf. Hence, we treat it as a // root during stack scanning, which means assembly that saves // and restores it doesn't need write barriers. It's still // typed as a pointer so that any other writes from Go get // write barriers. sp uintptr pc uintptr // <<<--- g guintptr ctxt unsafe.Pointer ret sys.Uintreg lr uintptr bp uintptr // for GOEXPERIMENT=framepointer } 我们从这个m_morebuf+gobuf_pc就知道指的是这个m结构体中的morebuf结构体字段中的pc值。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:published_time" content="2019-02-28T15:03:00+00:00"><meta property="article:modified_time" content="2019-02-28T15:03:00+00:00"><meta property="article:tag" content="Golang"><meta property="article:tag" content="Goroutine"><title>类汇编 | go调度源码分析</title>
<link rel=manifest href=/go-goroutine/manifest.json><link rel=icon href=/go-goroutine/favicon.png><link rel=stylesheet href=/go-goroutine/book.min.a7d3a43391e1f7eb43ae94bcae6354b739c49cba56473620924ec707afe0864d.css integrity="sha256-p9OkM5Hh9+tDrpS8rmNUtznEnLpWRzYgkk7HB6/ghk0=" crossorigin=anonymous><script defer src=/go-goroutine/flexsearch.min.js></script><script defer src=/go-goroutine/en.search.min.be99192eece134d6eb7ed57b4be97284f90048946e917f6a33b929cb79d49a0f.js integrity="sha256-vpkZLuzhNNbrftV7S+lyhPkASJRukX9qM7kpy3nUmg8=" crossorigin=anonymous></script><script defer src=/go-goroutine/sw.min.ec96d6e09af3075a94dd4de723a2edddf2ef138381c7e1e5b5a1f2c0578ee8bd.js integrity="sha256-7JbW4JrzB1qU3U3nI6Lt3fLvE4OBx+HltaHywFeO6L0=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/go-goroutine/><span>go调度源码分析</span></a></h2><div class=magic><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><div class=book-switch><label class=switch><input id=dark-mode-checkbox type=checkbox onchange=darkmode()>
<span class=slider></span></label></div></div><ul><li><a href=https://zput.github.io target=_blank rel=noopener>Zput博客</a></li><li><a href=https://github.com/zput target=_blank rel=noopener>GitHub</a></li></ul><hr><ul><li><span>基础知识</span><ul><li><a href=/go-goroutine/docs/foundation/golang_basic/>基本用法</a></li><li><a href=/go-goroutine/docs/foundation/slice/>slice</a></li><li><a href=/go-goroutine/docs/foundation/map/>map</a></li><li><a href=/go-goroutine/docs/foundation/sort/>sort</a></li><li><a href=/go-goroutine/docs/foundation/directory/>Directory</a></li></ul></li><li><span>鲁棒和性能</span><ul><li><a href=/go-goroutine/docs/robustness_and_performance/golang_test/>测试相关函数</a></li></ul></li><li><span>运行时</span><ul><li><a href=/go-goroutine/docs/runtime/golang_gmp/>GMP模型结构体</a></li><li><span>堆分配原理</span><ul><li><a href=/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/1_summarize/>概述</a></li><li><a href=/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_big_object/>分配大对象</a></li><li><a href=/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_middle_object/>概述</a></li><li><a href=/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_small_object/>概述</a></li></ul></li><li><a href=/go-goroutine/docs/runtime/golang_memery/>内存分配器</a></li><li><a href=/go-goroutine/docs/runtime/golang_gc/>垃圾回收</a></li><li><a href=/go-goroutine/docs/runtime/schedule/>调度</a><ul><li><span>前置知识</span><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/register_functionstack/>伪寄存器与函数栈帧</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/similar_assemble/ class=active>类汇编</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/go_underlying_struct/>底层重要结构</a></li></ul></li><li><a href=/go-goroutine/docs/runtime/schedule/2_init_before_enter_main_function/>初始化</a></li><li><a href=/go-goroutine/docs/runtime/schedule/3_exit_goroutine/>退出</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/>调度挑选策略</a><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/take_goroutine_from_globalorlocal_p/>从全局/本P队列</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/steal_goroutine_from_other_p/>从其他P队列</a></li></ul></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/>调度到达时机</a><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/active_scheduling/>主动调度</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/passive_scheduling/>被动调度</a></li><li><input type=checkbox id=section-740657f38f0c4de9a986bda642ff0388 class=toggle>
<label for=section-740657f38f0c4de9a986bda642ff0388 class="flex justify-between"><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/>剥夺调度</a></label><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/start_sysmon/>开启系统监控</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/user_code_preemption/>代码执行过久</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/system_call_preemption/>陷入系统调用</a></li></ul></li></ul></li></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script><script src=/go-goroutine/magic.js></script><script src=/go-goroutine/dark.js></script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/go-goroutine/svg/menu.svg class=book-icon alt=Menu>
</label><strong>类汇编</strong>
<label for=toc-control><img src=/go-goroutine/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#golang类汇编指令>golang类汇编指令</a><ul><li><a href=#寻址模式>寻址模式</a></li><li><a href=#结构体寄存器>结构体+寄存器</a></li></ul></li><li><a href=#golang类汇编函数>golang类汇编函数</a><ul><li><a href=#dropg函数>dropg函数</a></li><li><a href=#几个退出收尾函数>几个退出收尾函数</a></li><li><a href=#tls相关函数>tls相关函数</a><ul><li><a href=#runtimert0_gosb>runtime·rt0_go(SB)</a></li></ul></li><li><a href=#getg函数>getg函数</a></li></ul></li><li><a href=#附录>附录</a></li></ul></li></ul></nav></aside></header><article class=markdown><h2 id=golang类汇编指令>golang类汇编指令
<a class=anchor href=#golang%e7%b1%bb%e6%b1%87%e7%bc%96%e6%8c%87%e4%bb%a4>#</a></h2><h3 id=寻址模式>寻址模式
<a class=anchor href=#%e5%af%bb%e5%9d%80%e6%a8%a1%e5%bc%8f>#</a></h3><ul><li>(DI)(BX<em>2): The location at address DI plus BX</em>2.</li><li>64(DI)(BX<em>2): The location at address DI plus BX</em>2 plus 64. These modes accept only 1, 2, 4, and 8 as scale factors.</li></ul><h3 id=结构体寄存器>结构体+寄存器
<a class=anchor href=#%e7%bb%93%e6%9e%84%e4%bd%93%e5%af%84%e5%ad%98%e5%99%a8>#</a></h3><p>类似这种:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#75715e># (m_morebuf+gobuf_pc)(REGISTER)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#ae81ff>8</span>(<span style=color:#66d9ef>SP</span>), <span style=color:#66d9ef>AX</span>	<span style=color:#75715e># f&#39;s caller&#39;s PC
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#66d9ef>AX</span>, (<span style=color:#66d9ef>m_morebuf</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#66d9ef>gobuf_pc</span>)(<span style=color:#66d9ef>BX</span>)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>m</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>g0</span>      <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>     <span style=color:#75715e>// goroutine with scheduling stack
</span></span></span><span style=display:flex;background-color:#3c3d38><span><span style=color:#75715e></span>	<span style=color:#a6e22e>morebuf</span> <span style=color:#a6e22e>gobuf</span>  <span style=color:#75715e>// gobuf arg to morestack   //-----------morebuf-------------//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>divmod</span>  <span style=color:#66d9ef>uint32</span> <span style=color:#75715e>// div/mod denominator for arm - known to liblink
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>gobuf</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// The offsets of sp, pc, and g are known to (hard-coded in) libmach.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// ctxt is unusual with respect to GC: it may be a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// heap-allocated funcval, so GC needs to track it, but it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// needs to be set and cleared from assembly, where it&#39;s
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// difficult to have write barriers. However, ctxt is really a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// saved, live register, and we only ever exchange it between
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// the real register and the gobuf. Hence, we treat it as a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// root during stack scanning, which means assembly that saves
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// and restores it doesn&#39;t need write barriers. It&#39;s still
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// typed as a pointer so that any other writes from Go get
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// write barriers.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>sp</span>   <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex;background-color:#3c3d38><span>	<span style=color:#a6e22e>pc</span>   <span style=color:#66d9ef>uintptr</span>   <span style=color:#75715e>// &lt;&lt;&lt;--- 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>g</span>    <span style=color:#a6e22e>guintptr</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ctxt</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ret</span>  <span style=color:#a6e22e>sys</span>.<span style=color:#a6e22e>Uintreg</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>lr</span>   <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bp</span>   <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// for GOEXPERIMENT=framepointer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}</span></span></code></pre></div><p>我们从这个<code>m_morebuf+gobuf_pc</code>就知道指的是这个m结构体中的morebuf结构体字段中的pc值。</p><ul><li><p><a href=https://github.com/zput/go/blob/5622128a77b4af5e5dc02edf53ecac545e3af730/src/runtime/runtime2.go#L452>runtime.m</a></p></li><li><p><a href=https://github.com/zput/go/blob/5622128a77b4af5e5dc02edf53ecac545e3af730/src/runtime/runtime2.go#L302>runtime.gobuf</a></p></li><li><p><a href=https://github.com/zput/go/blob/5622128a77b4af5e5dc02edf53ecac545e3af730/src/runtime/runtime2.go#L387>runtime.g</a></p></li></ul><h2 id=golang类汇编函数>golang类汇编函数
<a class=anchor href=#golang%e7%b1%bb%e6%b1%87%e7%bc%96%e5%87%bd%e6%95%b0>#</a></h2><h3 id=dropg函数>dropg函数
<a class=anchor href=#dropg%e5%87%bd%e6%95%b0>#</a></h3><p>dropg()函数:解除g和m之间连接关系,其实就是设置g->m = nil, m->currg = nil.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>dropg</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_g_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>setMNoWB</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>curg</span>.<span style=color:#a6e22e>m</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>setGNoWB</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>curg</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=几个退出收尾函数>几个退出收尾函数
<a class=anchor href=#%e5%87%a0%e4%b8%aa%e9%80%80%e5%87%ba%e6%94%b6%e5%b0%be%e5%87%bd%e6%95%b0>#</a></h3><ul><li><p>非main goroutine运行结束：
<a href=/go-goroutine/docs/runtime/schedule/3_exit_goroutine/#goexit0%e5%87%bd%e6%95%b0 class=book-btn>goexit0</a></p></li><li><p>主动调度：
<a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/active_scheduling/#gosched_m%e5%87%bd%e6%95%b0 class=book-btn>gosched_m</a></p><ul><li>剥夺调度(运行太久)：
<a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/user_code_preemption/#gopreempt_m class=book-btn>gopreempt_m</a><ul><li>其中 gopreempt_m与gosched_m内部都是调用的goschedImpl函数，所以功能都是一样。</li></ul></li></ul></li><li><p>被动调度：
<a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/passive_scheduling/#park_m class=book-btn>park_m</a></p></li></ul><h3 id=tls相关函数>tls相关函数
<a class=anchor href=#tls%e7%9b%b8%e5%85%b3%e5%87%bd%e6%95%b0>#</a></h3><p>TLS代表的是伪寄存器,存储<strong>线程本地存储</strong>的基地址(基地址加上偏移地址能得到完整的一个地址), 语义上为<code>MOVQ TLS, reg; off(reg)(TLS*1)</code>等于<code>off(TLS)</code>,而这个<code>(TLS*1)</code>说明是从<strong>线程本地存储</strong>的基地址上<strong>进行索引</strong>。</p><p><a href=https://thestarman.pcministry.com/asm/debug/Segments.html>线程本地存储</a>: 普通的全局变量，一个线程对其进行了修改，所有线程都可以看到这个修改；线程私有全局变量不同，每个线程都有自己的一份副本，某个线程对其所做的修改不会影响到其它线程的副本</p><div class=book-expand><label><div class="book-expand-head flex justify-between"><span>Expand</span>
<span>↕</span></div><input type=checkbox class=hidden><div class="book-expand-content markdown-inner"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>	<span style=color:#75715e>// Thread-local storage references use the TLS pseudo-register.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// As a register, TLS refers to the thread-local storage base, and it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// can only be loaded into another register:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//         MOVQ TLS, AX
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// An offset from the thread-local storage base is written off(reg)(TLS*1).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Semantically it is off(reg), but the (TLS*1) annotation marks this as
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// indexing from the loaded TLS base. This emits a relocation so that
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// if the linker needs to adjust the offset, it can. For example:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//         MOVQ TLS, AX
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//         MOVQ 0(AX)(TLS*1), CX // load g into CX
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// On systems that support direct access to the TLS memory, this
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// pair of instructions can be reduced to a direct TLS memory reference:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//         MOVQ 0(TLS), CX // load g into CX
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// The 2-instruction and 1-instruction forms correspond to the two code
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// sequences for loading a TLS variable in the local exec model given in &#34;ELF
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Handling For Thread-Local Storage&#34;.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// When building for inclusion into a shared library, an instruction of the form
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//     MOV off(CX)(TLS*1), AX
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// becomes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//     mov %fs:off(%rcx), %rax
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// which assumes that the correct TLS offset has been loaded into %rcx (today
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// there is only one TLS variable -- g -- so this is OK). When not building for
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// a shared library the instruction does not require a prefix.
</span></span></span></code></pre></div></div></label></div><h4 id=runtimert0_gosb>runtime·rt0_go(SB)
<a class=anchor href=#runtimert0_gosb>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>TEXT</span> <span style=color:#66d9ef>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#66d9ef>rt0_go</span>(<span style=color:#66d9ef>SB</span>),<span style=color:#66d9ef>NOSPLIT</span>,<span style=color:#66d9ef>$0</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>LEAQ</span>	<span style=color:#66d9ef>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#66d9ef>m0</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#66d9ef>m_tls</span>(<span style=color:#66d9ef>SB</span>), <span style=color:#66d9ef>DI</span>  <span style=color:#75715e># DI = &amp;m0.tls，取m0的tls成员的地址到DI寄存器
</span></span></span><span style=display:flex;background-color:#3c3d38><span><span style=color:#75715e></span>	<span style=color:#a6e22e>CALL</span>	<span style=color:#66d9ef>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#66d9ef>settls</span>(<span style=color:#66d9ef>SB</span>)        <span style=color:#75715e># 调用settls设置线程本地存储，settls函数的参数在DI寄存器中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e># store through it, to make sure it works 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e># 可以看做是测试;测试刚刚那个绑定是否成功。
</span></span></span><span style=display:flex;background-color:#3c3d38><span><span style=color:#75715e></span>	<span style=color:#a6e22e>get_tls</span>(<span style=color:#66d9ef>BX</span>)    <span style=color:#75715e># 把TLS地址放入BX寄存器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#66d9ef>$0x123</span>, <span style=color:#66d9ef>g</span>(<span style=color:#66d9ef>BX</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#66d9ef>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#66d9ef>m0</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#66d9ef>m_tls</span>(<span style=color:#66d9ef>SB</span>), <span style=color:#66d9ef>AX</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>CMPQ</span>	<span style=color:#66d9ef>AX</span>, <span style=color:#66d9ef>$0x123</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>JEQ</span> <span style=color:#ae81ff>2</span>(<span style=color:#66d9ef>PC</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>CALL</span>	<span style=color:#66d9ef>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#66d9ef>abort</span>(<span style=color:#66d9ef>SB</span>)</span></span></code></pre></div><h5 id=settls>settls
<a class=anchor href=#settls>#</a></h5><p>设置段基地址</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#75715e># set tls base to DI
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>TEXT</span> <span style=color:#66d9ef>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#66d9ef>settls</span>(<span style=color:#66d9ef>SB</span>),<span style=color:#66d9ef>NOSPLIT</span>,<span style=color:#66d9ef>$32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ADDQ</span>	<span style=color:#66d9ef>$8</span>, <span style=color:#66d9ef>DI</span>	<span style=color:#75715e># ELF wants to use -8(FS) // https://akkadia.org/drepper/tls.pdf
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#66d9ef>DI</span>, <span style=color:#66d9ef>SI</span>  <span style=color:#75715e>#  SI 是 arch_prctl的第二个参数 addr
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#66d9ef>$0x1002</span>, <span style=color:#66d9ef>DI</span>	<span style=color:#75715e># ARCH_SET_FS, arch_prctl的第一个参数 code
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#66d9ef>$SYS_arch_prctl</span>, <span style=color:#66d9ef>AX</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>SYSCALL</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>CMPQ</span>	<span style=color:#66d9ef>AX</span>, <span style=color:#66d9ef>$0xfffffffffffff001</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>JLS</span>	<span style=color:#ae81ff>2</span>(<span style=color:#66d9ef>PC</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVL</span>	<span style=color:#66d9ef>$0xf1</span>, <span style=color:#ae81ff>0xf1</span>  <span style=color:#75715e># crash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>RET</span>
</span></span></code></pre></div><blockquote><p>主要使用系统API
<a href=https://www.man7.org/linux/man-pages/man2/arch_prctl.2.html>arch_prctl</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>arch_prctl</span>(<span style=color:#66d9ef>int</span> code, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> addr);
</span></span><span style=display:flex><span><span style=color:#75715e>// arch_prctl() sets architecture-specific process or thread state. code selects a subfunction and passes argument addr to it;
</span></span></span></code></pre></div><p>参数之一就是指定操作类型，其中：
<a href=https://docs.huihoo.com/doxygen/linux/kernel/3.7/arch_2x86_2include_2asm_2prctl_8h.html>ARCH_SET_FS <sup>1</sup></a>: 代表将FS寄存器的64位基数设置为addr指定的参数操作,它定义的操作类型代号为<code>0x1002</code></p></blockquote><p>上面的步骤是把段基寄存器 设置为 <code>m0.tls[0]</code>所在的地址.</p><h5 id=get_tlsbx与gbx>get_tls(BX)与g(BX)
<a class=anchor href=#get_tlsbx%e4%b8%8egbx>#</a></h5><p>这个<code>get_tls(BX)</code>与<code>g()</code>其实都是宏定义：</p><blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#75715e>#ifdef GOARCH_amd64
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define	get_tls(r)	MOVQ TLS, r
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define	g(r)	0(r)(TLS*1)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span></code></pre></div><p>翻译过来就是:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span> <span style=color:#66d9ef>TLS</span>, <span style=color:#66d9ef>BX</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>0(</span><span style=color:#a6e22e>BX</span>)(<span style=color:#66d9ef>TLS</span>*<span style=color:#ae81ff>1</span>) 
</span></span></code></pre></div></blockquote><p>而<code>0(BX)(TLS*1)</code>就等于<code>0(TLS)</code>, 所以上面就是把0x123设置到了<code>m0.tls[0]</code>, 然后通过比较<code>CMPQ AX, $0x123</code>看刚刚测试那个绑定是否成功。</p><h3 id=getg函数>getg函数
<a class=anchor href=#getg%e5%87%bd%e6%95%b0>#</a></h3><p>getg()单独返回当前的g, 得到当前用户g,最好使用<code>getg().m.curg</code>，因在系统或信号栈上执行时，这将分别返回当前M的 &ldquo;g0 &ldquo;或 &ldquo;gsignal&rdquo;。这通常不是你想要的。
想确定你是在用户栈还是系统栈上运行，可以使用<code>getg() == getg().m.curg</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// getg returns the pointer to the current g.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// The compiler rewrites calls to this function into instructions
</span></span></span><span style=display:flex><span><span style=color:#75715e>// that fetch the g directly (from TLS or from the dedicated register).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getg</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>
</span></span></code></pre></div><p><a href=https://github.com/golang/go/blob/master/src/runtime/HACKING.md#getg-and-getgmcurg>https://github.com/golang/go/blob/master/src/runtime/HACKING.md#getg-and-getgmcurg</a></p><h2 id=附录>附录
<a class=anchor href=#%e9%99%84%e5%bd%95>#</a></h2><p><a href=https://lrita.github.io/2017/12/12/golang-asm/#interface>https://lrita.github.io/2017/12/12/golang-asm/#interface</a></p><p><a href=https://www.zhihu.com/question/284288720>https://www.zhihu.com/question/284288720</a>
<a href=https://segmentfault.com/a/1190000038626134>https://segmentfault.com/a/1190000038626134</a>
<a href=https://www.altoros.com/blog/golang-internals-part-5-the-runtime-bootstrap-process/>https://www.altoros.com/blog/golang-internals-part-5-the-runtime-bootstrap-process/</a></p><p><a href=https://segmentfault.com/a/1190000010984538>gid</a></p><p><a href=https://golang.org/doc/asm#directives>https://golang.org/doc/asm#directives</a>
<a href=https://lrita.github.io/2017/12/12/golang-asm/#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E>https://lrita.github.io/2017/12/12/golang-asm/#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E</a>
<a href=https://github.com/go-internals-cn/go-internals>https://github.com/go-internals-cn/go-internals</a></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><script src=https://giscus.app/client.js data-repo=zput/utterances-comments data-repo-id=R_kgDOHhATGQ data-category=Announcements data-category-id=DIC_kwDOHhATGc4CPxca data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=1 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#golang类汇编指令>golang类汇编指令</a><ul><li><a href=#寻址模式>寻址模式</a></li><li><a href=#结构体寄存器>结构体+寄存器</a></li></ul></li><li><a href=#golang类汇编函数>golang类汇编函数</a><ul><li><a href=#dropg函数>dropg函数</a></li><li><a href=#几个退出收尾函数>几个退出收尾函数</a></li><li><a href=#tls相关函数>tls相关函数</a><ul><li><a href=#runtimert0_gosb>runtime·rt0_go(SB)</a></li></ul></li><li><a href=#getg函数>getg函数</a></li></ul></li><li><a href=#附录>附录</a></li></ul></li></ul></nav></div></aside></main></body></html><script type=text/javascript src=https://cdn.bootcss.com/viz.js/1.8.2/viz.js></script><script type=text/javascript>(function(){var e="language-viz-";Array.prototype.forEach.call(document.querySelectorAll("[class^="+e+"]"),function(t){console.log(t),t.getAttribute("class").split(" ").forEach(function(t){t.startsWith(e)&&(s=t.substr(e.length))}),console.log("------------MIDDLE--------");var s,o=Viz(t.innerText,{format:"svg",engine:s}),n=(new DOMParser).parseFromString(o,"image/svg+xml");n.documentElement.setAttribute("style","max-width:100%; max-height:100%;"),t.parentNode.insertBefore(n.documentElement,t),t.style.display="none",t.parentNode.style.backgroundColor="white",t.style.width=n.documentElement.getAttribute("width")+"px",t.style.height=n.documentElement.getAttribute("height")+"px",console.log("--------------END------")})})()</script>