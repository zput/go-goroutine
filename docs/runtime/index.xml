<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>运行时 on go调度源码分析</title><link>https://zput.github.io/go-goroutine/docs/runtime/</link><description>Recent content in 运行时 on go调度源码分析</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Tue, 23 Jun 2020 20:50:00 +0000</lastBuildDate><atom:link href="https://zput.github.io/go-goroutine/docs/runtime/index.xml" rel="self" type="application/rss+xml"/><item><title>GMP</title><link>https://zput.github.io/go-goroutine/docs/runtime/golang_gmp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/golang_gmp/</guid><description>golang GMP概念 # what: 是golang内部自己实现的调度器，由’‘G’’,“M”,“P&amp;quot;用来调度goruntine，被称为&amp;quot;GMP模型”。
GMP G:为了调度方便，保存寄存器，栈地址等-&amp;gt;对应cpu切换[1.cpu寄存器的值；2.stack地址] M:与系统线程一一对应 P:一些上下文，比如局部P，防止锁，局部P的heap,也能防止加锁的导致的资源损耗。 why:
单进程时代不需要调度器
1.单一的执行流程，计算机只能一个任务一个任务处理。 2.进程阻塞所带来的CPU时间浪费。 多进程/线程时代有了调度器需求
1.解决了阻塞的问题 2.CPU有很大的一部分都被浪费在进程调度 设计会变得更加复杂，要考虑很多同步竞争等问题，如锁、竞争冲突等。 协程(用户线程)来提高CPU利用率(减少CPU浪费在进程调度上)
为什么。 线程和进程有很多相同的控制权。线程有自己的信号掩码，可以分配CPU时间，可以放入cgroups，可以查询它们使用了哪些资源。所有这些控制都增加了一些功能的开销，而这些功能对于Go程序如何使用goroutine来说是根本不需要的，而且当你的程序中有10万个线程时，它们很快就会增加。 Go调度器可以做出只在它知道内存是一致的点进行调度的决定。 如何进行调度。 一种是N:1，即在一个操作系统线程上运行几个用户空间线程。这样做的好处是上下文切换非常快，但不能利用多核系统的优势。 另一种是1:1，一个执行线程匹配一个OS线程。它可以利用机器上所有的核心，但是上下文切换很慢，因为它要通过OS进行切换。 M:N调度器。你可以得到快速的上下文切换，你可以利用系统中所有的核心。这种方法的主要缺点是它增加了调度器的复杂性。 摆脱上下文(在这里P就是上下文)？ 不行。我们使用上下文的原因是，如果正在运行的线程由于某些原因需要阻塞，我们可以将它们移交给其他线程。 以前就只有一个全局的P，也可以运行。必须要有P（上下文），是有什么值保存在里面？ why: threads get a lot of the same controls as processes. Threads have their own signal mask, can be assigned CPU affinity, can be put into cgroups and can be queried for which resources they use. All these controls add overhead for features that are simply not needed for how Go programs use goroutines and they quickly add up when you have 100,000 threads in your program.</description></item><item><title>内存分配器</title><link>https://zput.github.io/go-goroutine/docs/runtime/golang_memery/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/golang_memery/</guid><description>结构 # on-heap 和 off-heap 的区别是这个对象占用的内存是否支持垃圾自动回收
off-heap的对象，必须只能手动管理，比如heapArena，mspan等runtime中的数据结构
golang对象分配采用的是:
sequential allocation sequential allocation 的实现方式非常简单，只需要把维护的空间直接分配出去就好，每次分配以后挪动指针，指向剩余空闲的位置的首地址，runtime off-heap object allocator一节中介绍的persistent allocator采用的就是sequential allocation这个方式。 free-list allocation free list allocation 这种分配方式相对sequential allocation这种方式没能更好的利用上缓存的空间局部性原理，并且分配的时候速度慢，虽然有first fit 、next fit、best fit三种寻找空闲块的策略 ，但是多少还是会造成外部碎片。但是free list allocation 可以支持立马把释放的空间放到list中用于后续的分配。 segregated-fit allocator 设置K个size class ，各自的大小是s1,s2&amp;hellip;sk (从小到大排队)，当程序需要S大小空间的时候，给其分配sn这么多的空间(sn&amp;lt;=S&amp;lt;sn+1)，每种size class都有一个分配器，专门分配这个大小，这样相比 free list allocation 可以免去寻找合适内存块的过程。但是会造成更多的浪费，因为对象的大小不一定正好等于slot的大小。调整size class 的个数和每个的大小是减少浪费的关键。 segregated-fit allocation 还有一个好处是可以非常方便的处理指向对象内部的指针，这可以为垃圾回收提供便利，对于任何一个指针，可以很轻松的找到这个指针所指向的对象的首地址。 type mheap struct { _ sys.NotInHeap // lock must only be acquired on the system stack, otherwise a g // could self-deadlock if its stack grows with the lock held.</description></item><item><title>垃圾回收</title><link>https://zput.github.io/go-goroutine/docs/runtime/golang_gc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/golang_gc/</guid><description>golang垃圾回收 # golang垃圾回收 理论 三色标记法 golang GC 三色 新分配对象的颜色 写屏障 写屏障的步骤推导 插入写屏障 删除写屏障 混合写屏障 其他的变种 golang实现 扩展 mutator? FQA 谈一谈golang的gc. 二：为什么清扫阶段不需要屏障了呢？ 三：golang的heap结构 四: 工作队列相关的问题：并发标记的分工问题？写屏障记录集的竞争问题？ 五： CUP utilization TODO: 并发GC如何缓解内存分配压力？ 附录 archive 202104-conclusion what,why,how 理论 # 三色标记法 # 黑色：当基于当前节点的追踪任务完成后，表示为存活数据，后续无需再追踪。 灰色：基于当前节点展开的追踪还未完成。 白色： 黑色对象如果指向白色对象,会导致白色对象被错误回收。 有两种方法来避免: 强三色：黑色对象只能引用灰色对象。 弱三色：所有被黑色对象引用的白色对象都处于灰色保护状态.
golang GC # what: # gc主要是释放那些不再需要的分配在堆（heap）上的数据 why: # 降低人的心智负担，从堆（heap）中申请的内存，不需要手动的释放。 how: # 一般判断对象是否存活是使用：是把可达性近视的认为存活性. 可把栈（stack），数据段（data segment? bss?）的数据对象作为root In a tri-color collector, every object is either white, grey, or black and we view the heap as a graph of connected objects.</description></item></channel></rss>