<!doctype html><html lang=zh dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="1 前言：变量的存放区 # 通常情况下，变量的分配位置一般是下列三个区：
全局数据区 栈区 堆区 全局数据区:主要用于全局变量的分配，也即包级别的变量,其生命周期和进程相同。
栈区:主要存储函数内部定义的本地变量,当函数执行完毕，变量即可释放。函数执行时通过栈帧加偏移来访问这些数据。
堆区:主要用于程序运行阶段的动态分配。
内存中的对象存在着相互的引用关系。全局数据区与栈区可能指同堆上的数据,这两个地方的指针是堆内存访问的起点，也就是堆内存访问的根节点(root)。
2 定义 # 垃圾回收（garbage collect）简称gc,主要是释放那些不再需要的分配在堆（heap）上的数据, 以便再次用来进行内存分配。垃圾回收一般分为两个步骤：垃圾识别和垃圾清理。
golang支持垃圾自动回收，主要是降低人的心智负担，从堆（heap）中申请的内存，不需要手动的释放。其采用三色标记法来识别垃圾对象，并使用清除算法进行垃圾清理。
2.1 垃圾识别 # 2.1.1 双色标记法 # 根节点一般为全局变量、栈中的变量，维护根节点集合是可达性分析的前提。可达性分析是指从根对象开始，遍历其引用的子节点对象，直至遍历完毕。凡是能够触达的对象，都视作有效对象，而无法触达的，则视作垃圾对象。
双色标标记法采用可达性分析来标记对象状态;通过对象的可达性近视的认为存活性。
双色标记法看上去简单易用，但却存在着一个比较大的缺点，即整个标记过程必须一次性完成，中间不能有任何停顿。也就是说，在执行过程中，不能让出CPU时间片给其他线程。对于应用程序来说，可能会出现用户线程完全停顿，直至标记过程结束。
双色标记法只能描述对象节点自身是否扫描，而不能描述子节点是否完成。这导致重启标记开始后，很难抉择该如何继续，如果再次从根节点开始，那就意味着上次所做的工作完全被浪费掉了。因此，双色标记在停顿、再次重启过程中，无法完成状态的自描述。
由于新增对象无法确定置为黑色还是白色，因此导致扫描过程不能停顿。对双色标记而言可将新增对象直接标记为黑色，然后到下轮垃圾回收才将本轮新增对象中的垃圾对象（往往是生命周期很短的对象）清除。
2.1.2 三色标记法 # 黑色：当基于当前节点的追踪任务完成后，表示为存活数据，后续无需再追踪。 灰色：基于当前节点展开的追踪还未完成。 白色： 黑色对象如果指向白色对象,会导致白色对象被错误回收。 有两种方法来避免: 强三色：黑色对象只能引用灰色对象。 弱三色：所有被黑色对象引用的白色对象都处于灰色保护状态.
全局数据区与栈区的指针是堆内存访问的起点, 所以把它们放入一个待扫描队列（工作队列）,通过它们可以发现堆上第一批可达数据,发现的可达数据中有指针的加入待扫描队列（灰色节点）扫描完的标为黑色，离开队列,通过扫描灰色节点会发现更多灰色节点，也会产生更多黑色点节点,直到没有待扫描的灰色节点,我们就找到了所有可达数据（黑色节点）,剩下的白色节点就是不可达数据不可达自然用不到,也即是可以进行释放。
问题： 原因： 并发执行,如果将白色对象写入黑色对象,同时没有其它未扫描的路径,可抵达该白色对象,它就不会被扫描携程发现,继而被误判为垃圾。
当gc使用三色标记法与用户程序并发执行的时候，可能让黑色对象重新引用了白色对象，且无其他灰色对象引用了这个白色对象。导致白色对象错误回收。(用户程序和垃圾收集器可以在交替工作的)
处理措施：
引入写屏障：就是在执行写操作时，额外做些标记工作(把数据对象的修改通知到垃圾回收器)，避免垃圾误判。
分为两种，一种是插入写屏障，一种是删除写屏障。
插入写屏障 writePointer(slot, ptr): // ⚠️:slot现在指向的还是旧对象 shade(ptr) //shade函数尝试改变指针的颜色-->改变ptr的颜色 *slot = ptr 删除写屏障： 会在老对象的引用被删除时，将白色的老对象涂成灰色。 writePointer(slot, ptr) // ⚠️:slot现在指向的还是旧对象 shade(*slot) //shade函数尝试改变指针的颜色-->改变(*slot)的颜色--->注意这个是*slot(旧对象),slot保存着它原先的保存的地址。 *slot = ptr 引入新问题：只有插入写屏障，但是这需要对所有堆、栈的写操作都开启写屏障，程序性能会受到影响，代价太大。为了改善这个问题，改为忽略协程栈上的写屏障，只在标记结束阶段重新扫描那些被激活的栈帧。但是Go语言通常会有大量活跃的协程，这就导致第二次STW时重新扫描协程栈的时间太长。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://zput.github.io/go-goroutine/docs/runtime/golang_gc/"><meta property="og:site_name" content="go调度源码分析"><meta property="og:title" content="垃圾回收"><meta property="og:description" content="1 前言：变量的存放区 # 通常情况下，变量的分配位置一般是下列三个区：
全局数据区 栈区 堆区 全局数据区:主要用于全局变量的分配，也即包级别的变量,其生命周期和进程相同。
栈区:主要存储函数内部定义的本地变量,当函数执行完毕，变量即可释放。函数执行时通过栈帧加偏移来访问这些数据。
堆区:主要用于程序运行阶段的动态分配。
内存中的对象存在着相互的引用关系。全局数据区与栈区可能指同堆上的数据,这两个地方的指针是堆内存访问的起点，也就是堆内存访问的根节点(root)。
2 定义 # 垃圾回收（garbage collect）简称gc,主要是释放那些不再需要的分配在堆（heap）上的数据, 以便再次用来进行内存分配。垃圾回收一般分为两个步骤：垃圾识别和垃圾清理。
golang支持垃圾自动回收，主要是降低人的心智负担，从堆（heap）中申请的内存，不需要手动的释放。其采用三色标记法来识别垃圾对象，并使用清除算法进行垃圾清理。
2.1 垃圾识别 # 2.1.1 双色标记法 # 根节点一般为全局变量、栈中的变量，维护根节点集合是可达性分析的前提。可达性分析是指从根对象开始，遍历其引用的子节点对象，直至遍历完毕。凡是能够触达的对象，都视作有效对象，而无法触达的，则视作垃圾对象。
双色标标记法采用可达性分析来标记对象状态;通过对象的可达性近视的认为存活性。
双色标记法看上去简单易用，但却存在着一个比较大的缺点，即整个标记过程必须一次性完成，中间不能有任何停顿。也就是说，在执行过程中，不能让出CPU时间片给其他线程。对于应用程序来说，可能会出现用户线程完全停顿，直至标记过程结束。
双色标记法只能描述对象节点自身是否扫描，而不能描述子节点是否完成。这导致重启标记开始后，很难抉择该如何继续，如果再次从根节点开始，那就意味着上次所做的工作完全被浪费掉了。因此，双色标记在停顿、再次重启过程中，无法完成状态的自描述。
由于新增对象无法确定置为黑色还是白色，因此导致扫描过程不能停顿。对双色标记而言可将新增对象直接标记为黑色，然后到下轮垃圾回收才将本轮新增对象中的垃圾对象（往往是生命周期很短的对象）清除。
2.1.2 三色标记法 # 黑色：当基于当前节点的追踪任务完成后，表示为存活数据，后续无需再追踪。 灰色：基于当前节点展开的追踪还未完成。 白色： 黑色对象如果指向白色对象,会导致白色对象被错误回收。 有两种方法来避免: 强三色：黑色对象只能引用灰色对象。 弱三色：所有被黑色对象引用的白色对象都处于灰色保护状态.
全局数据区与栈区的指针是堆内存访问的起点, 所以把它们放入一个待扫描队列（工作队列）,通过它们可以发现堆上第一批可达数据,发现的可达数据中有指针的加入待扫描队列（灰色节点）扫描完的标为黑色，离开队列,通过扫描灰色节点会发现更多灰色节点，也会产生更多黑色点节点,直到没有待扫描的灰色节点,我们就找到了所有可达数据（黑色节点）,剩下的白色节点就是不可达数据不可达自然用不到,也即是可以进行释放。
问题： 原因： 并发执行,如果将白色对象写入黑色对象,同时没有其它未扫描的路径,可抵达该白色对象,它就不会被扫描携程发现,继而被误判为垃圾。
当gc使用三色标记法与用户程序并发执行的时候，可能让黑色对象重新引用了白色对象，且无其他灰色对象引用了这个白色对象。导致白色对象错误回收。(用户程序和垃圾收集器可以在交替工作的)
处理措施：
引入写屏障：就是在执行写操作时，额外做些标记工作(把数据对象的修改通知到垃圾回收器)，避免垃圾误判。
分为两种，一种是插入写屏障，一种是删除写屏障。
插入写屏障 writePointer(slot, ptr): // ⚠️:slot现在指向的还是旧对象 shade(ptr) //shade函数尝试改变指针的颜色-->改变ptr的颜色 *slot = ptr 删除写屏障： 会在老对象的引用被删除时，将白色的老对象涂成灰色。 writePointer(slot, ptr) // ⚠️:slot现在指向的还是旧对象 shade(*slot) //shade函数尝试改变指针的颜色-->改变(*slot)的颜色--->注意这个是*slot(旧对象),slot保存着它原先的保存的地址。 *slot = ptr 引入新问题：只有插入写屏障，但是这需要对所有堆、栈的写操作都开启写屏障，程序性能会受到影响，代价太大。为了改善这个问题，改为忽略协程栈上的写屏障，只在标记结束阶段重新扫描那些被激活的栈帧。但是Go语言通常会有大量活跃的协程，这就导致第二次STW时重新扫描协程栈的时间太长。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>垃圾回收 | go调度源码分析</title>
<link rel=manifest href=/go-goroutine/manifest.json><link rel=icon href=/go-goroutine/favicon.png><link rel=stylesheet href=/go-goroutine/book.min.a7d3a43391e1f7eb43ae94bcae6354b739c49cba56473620924ec707afe0864d.css integrity="sha256-p9OkM5Hh9+tDrpS8rmNUtznEnLpWRzYgkk7HB6/ghk0=" crossorigin=anonymous><script defer src=/go-goroutine/flexsearch.min.js></script><script defer src=/go-goroutine/en.search.min.f6fad63fd3a7931333c8b9050702f15b521bc9747c2d396abcd04987c939fa25.js integrity="sha256-9vrWP9OnkxMzyLkFBwLxW1IbyXR8LTlqvNBJh8k5+iU=" crossorigin=anonymous></script><script defer src=/go-goroutine/sw.min.ec96d6e09af3075a94dd4de723a2edddf2ef138381c7e1e5b5a1f2c0578ee8bd.js integrity="sha256-7JbW4JrzB1qU3U3nI6Lt3fLvE4OBx+HltaHywFeO6L0=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/go-goroutine/><span>go调度源码分析</span></a></h2><div class=magic><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><div class=book-switch><label class=switch><input id=dark-mode-checkbox type=checkbox onchange=darkmode()>
<span class=slider></span></label></div></div><ul><li><a href=https://zput.github.io target=_blank rel=noopener>Zput博客</a></li><li><a href=https://github.com/zput target=_blank rel=noopener>GitHub</a></li></ul><hr><ul><li><span>基础知识</span><ul><li><a href=/go-goroutine/docs/foundation/golang_basic/>基本用法</a></li><li><a href=/go-goroutine/docs/foundation/slice/>slice</a></li><li><a href=/go-goroutine/docs/foundation/map/>map</a></li><li><a href=/go-goroutine/docs/foundation/sort/>sort</a></li><li><a href=/go-goroutine/docs/foundation/directory/>Directory</a></li></ul></li><li><span>鲁棒和性能</span><ul><li><a href=/go-goroutine/docs/robustness_and_performance/golang_test/>测试相关函数</a></li></ul></li><li><span>运行时</span><ul><li><a href=/go-goroutine/docs/runtime/golang_gmp/>GMP</a></li><li><span>堆分配原理</span><ul><li><a href=/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/1_summarize/>概述</a></li><li><a href=/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_big_object/>分配大对象</a></li><li><a href=/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_middle_object/>概述</a></li><li><a href=/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_small_object/>概述</a></li></ul></li><li><a href=/go-goroutine/docs/runtime/complement-source-reverse/>源码-反码-补码</a></li><li><a href=/go-goroutine/docs/runtime/golang_memery/>内存分配器</a></li><li><a href=/go-goroutine/docs/runtime/golang_gc/ class=active>垃圾回收</a></li><li><a href=/go-goroutine/docs/runtime/schedule/>调度</a><ul><li><span>前置知识</span><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/memory/>内存大小端</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/register_functionstack/>伪寄存器与函数栈帧</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/similar_assemble/>类汇编</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/go_underlying_struct/>底层重要结构</a></li></ul></li><li><a href=/go-goroutine/docs/runtime/schedule/2_init_before_enter_main_function/>初始化</a></li><li><a href=/go-goroutine/docs/runtime/schedule/3_exit_goroutine/>退出</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/>调度挑选策略</a><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/take_goroutine_from_globalorlocal_p/>从全局/本P队列</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/steal_goroutine_from_other_p/>从其他P队列</a></li></ul></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/>调度到达时机</a><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/active_scheduling/>主动调度</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/passive_scheduling/>被动调度</a></li><li><input type=checkbox id=section-740657f38f0c4de9a986bda642ff0388 class=toggle>
<label for=section-740657f38f0c4de9a986bda642ff0388 class="flex justify-between"><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/>剥夺调度</a></label><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/start_sysmon/>开启系统监控</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/user_code_preemption/>代码执行过久</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/system_call_preemption/>陷入系统调用</a></li></ul></li></ul></li></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script><script src=/go-goroutine/magic.js></script><script src=/go-goroutine/dark.js></script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/go-goroutine/svg/menu.svg class=book-icon alt=Menu>
</label><strong>垃圾回收</strong>
<label for=toc-control><img src=/go-goroutine/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#1-前言变量的存放区>1 前言：变量的存放区</a><ul><li><a href=#2-定义>2 定义</a><ul><li><a href=#21-垃圾识别>2.1 垃圾识别</a><ul><li><a href=#211-双色标记法>2.1.1 双色标记法</a></li><li><a href=#212-三色标记法>2.1.2 三色标记法</a></li></ul></li></ul></li></ul></li><li><a href=#golang垃圾回收>golang垃圾回收</a><ul><li><a href=#总体流程>总体流程</a><ul><li><a href=#三色>三色</a></li><li><a href=#写屏障>写屏障</a><ul><li><a href=#写屏障的步骤推导>写屏障的步骤推导</a></li></ul></li></ul></li></ul></li><li><a href=#fqa>FQA</a><ul><li><a href=#为什么gc也要扫描栈不是都在堆上面吗>为什么gc也要扫描栈，不是都在堆上面吗？</a></li><li><a href=#混合写屏障>混合写屏障</a></li><li><a href=#golang中gc支持增量与并发式回收怎么理解>Golang中GC支持增量与并发式回收怎么理解</a></li><li><a href=#为什么清扫阶段不需要屏障了呢>为什么清扫阶段不需要屏障了呢？</a></li><li><a href=#golang的heap结构>golang的heap结构</a><ul><li><ul><li><a href=#四-工作队列相关的问题并发标记的分工问题写屏障记录集的竞争问题>四: <strong>工作队列</strong>相关的问题：并发标记的分工问题？写屏障记录集的竞争问题？</a></li><li><a href=#五-cup-utilization>五： CUP utilization</a></li><li><a href=#todo-并发gc如何缓解内存分配压力>TODO: 并发GC如何缓解内存分配压力？</a></li></ul></li></ul></li></ul></li><li><a href=#总结>总结</a><ul><li><a href=#为什么golang需要gc>为什么golang需要GC</a><ul><li><a href=#what>what:</a></li><li><a href=#why>why:</a></li><li><a href=#how>how:</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=1-前言变量的存放区>1 前言：变量的存放区
<a class=anchor href=#1-%e5%89%8d%e8%a8%80%e5%8f%98%e9%87%8f%e7%9a%84%e5%ad%98%e6%94%be%e5%8c%ba>#</a></h1><p>通常情况下，变量的分配位置一般是下列三个区：</p><ol><li>全局数据区</li><li>栈区</li><li>堆区</li></ol><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240622185210.png width=50% height=50% alt=效果图></p><p>全局数据区:主要用于全局变量的分配，也即包级别的变量,其生命周期和进程相同。</p><p>栈区:主要存储函数内部定义的本地变量,当函数执行完毕，变量即可释放。函数执行时通过栈帧加偏移来访问这些数据。</p><p>堆区:主要用于程序运行阶段的动态分配。</p><p>内存中的对象存在着相互的引用关系。全局数据区与栈区可能指同堆上的数据,这两个地方的指针是堆内存访问的起点，也就是堆内存访问的根节点(root)。</p><h2 id=2-定义>2 定义
<a class=anchor href=#2-%e5%ae%9a%e4%b9%89>#</a></h2><p>垃圾回收（garbage collect）简称gc,主要是释放那些不再需要的分配在堆（heap）上的数据, 以便再次用来进行内存分配。垃圾回收一般分为两个步骤：<strong>垃圾识别</strong>和<strong>垃圾清理</strong>。</p><p>golang支持垃圾自动回收，主要是降低人的心智负担，从堆（heap）中申请的内存，不需要手动的释放。其采用三色标记法来识别垃圾对象，并使用清除算法进行垃圾清理。</p><h3 id=21-垃圾识别>2.1 垃圾识别
<a class=anchor href=#21-%e5%9e%83%e5%9c%be%e8%af%86%e5%88%ab>#</a></h3><h4 id=211-双色标记法>2.1.1 双色标记法
<a class=anchor href=#211-%e5%8f%8c%e8%89%b2%e6%a0%87%e8%ae%b0%e6%b3%95>#</a></h4><p>根节点一般为全局变量、栈中的变量，维护根节点集合是可达性分析的前提。可达性分析是指从根对象开始，遍历其引用的子节点对象，直至遍历完毕。凡是能够触达的对象，都视作有效对象，而无法触达的，则视作垃圾对象。</p><p>双色标标记法采用可达性分析来标记对象状态;通过对象的可达性近视的认为存活性。</p><p>双色标记法看上去简单易用，但却存在着一个比较大的缺点，即整个标记过程必须一次性完成，中间不能有任何停顿。也就是说，在执行过程中，不能让出CPU时间片给其他线程。对于应用程序来说，可能会出现用户线程完全停顿，直至标记过程结束。</p><p>双色标记法只能描述对象节点自身是否扫描，<strong>而不能描述子节点是否完成</strong>。这导致重启标记开始后，很难抉择该如何继续，如果再次从根节点开始，那就意味着上次所做的工作完全被浪费掉了。因此，双色标记在停顿、再次重启过程中，无法完成状态的自描述。</p><blockquote><p>由于新增对象无法确定置为黑色还是白色，因此导致扫描过程不能停顿。对双色标记而言可将新增对象直接标记为黑色，然后到下轮垃圾回收才将本轮新增对象中的垃圾对象（往往是生命周期很短的对象）清除。</p></blockquote><h4 id=212-三色标记法>2.1.2 三色标记法
<a class=anchor href=#212-%e4%b8%89%e8%89%b2%e6%a0%87%e8%ae%b0%e6%b3%95>#</a></h4><ul><li>黑色：当基于当前节点的追踪任务完成后，表示为存活数据，后续无需再追踪。</li><li>灰色：基于当前节点展开的追踪还未完成。</li><li>白色：</li></ul><p>黑色对象如果指向白色对象,会导致白色对象被错误回收。
有两种方法来避免:
强三色：黑色对象只能引用灰色对象。
弱三色：所有被黑色对象引用的白色对象都处于灰色保护状态.</p><p>全局数据区与栈区的指针是堆内存访问的起点, 所以把它们放入一个待扫描队列（工作队列）,通过它们可以发现堆上第一批可达数据,发现的可达数据中有指针的加入待扫描队列（灰色节点）扫描完的标为黑色，离开队列,通过扫描灰色节点会发现更多灰色节点，也会产生更多黑色点节点,直到没有待扫描的灰色节点,我们就找到了所有可达数据（黑色节点）,剩下的白色节点就是不可达数据不可达自然用不到,也即是可以进行释放。</p><p>问题：
<img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240622204628.png alt=20240622204628></p><p>原因：
并发执行,如果将白色对象写入黑色对象,同时没有其它未扫描的路径,可抵达该白色对象,它就不会被扫描携程发现,继而被误判为垃圾。</p><blockquote><p>当gc使用三色标记法与用户程序并发执行的时候，可能让黑色对象重新引用了白色对象，且无其他灰色对象引用了这个白色对象。导致白色对象错误回收。(用户程序和垃圾收集器可以在交替工作的)</p></blockquote><p>处理措施：</p><p>引入写屏障：就是在执行写操作时，额外做些标记工作(把数据对象的修改通知到垃圾回收器)，避免垃圾误判。</p><p>分为两种，一种是插入写屏障，一种是删除写屏障。</p><ol><li>插入写屏障</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>writePointer</span>(<span style=color:#a6e22e>slot</span>, <span style=color:#a6e22e>ptr</span>): <span style=color:#75715e>// ⚠️:slot现在指向的还是旧对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  	<span style=color:#a6e22e>shade</span>(<span style=color:#a6e22e>ptr</span>) <span style=color:#75715e>//shade函数尝试改变指针的颜色--&gt;改变ptr的颜色
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   	<span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span> = <span style=color:#a6e22e>ptr</span>
</span></span></code></pre></div><ol start=2><li>删除写屏障： 会在老对象的引用被删除时，将白色的老对象涂成灰色。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>writePointer</span>(<span style=color:#a6e22e>slot</span>, <span style=color:#a6e22e>ptr</span>) <span style=color:#75715e>// ⚠️:slot现在指向的还是旧对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> 	<span style=color:#a6e22e>shade</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span>) <span style=color:#75715e>//shade函数尝试改变指针的颜色--&gt;改变(*slot)的颜色---&gt;注意这个是*slot(旧对象),slot保存着它原先的保存的地址。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> 	<span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span> = <span style=color:#a6e22e>ptr</span>
</span></span></code></pre></div><blockquote><p>引入新问题：只有插入写屏障，但是这需要对所有堆、栈的写操作都开启写屏障，程序性能会受到影响，代价太大。为了改善这个问题，改为<strong>忽略协程栈</strong>上的写屏障，只在标记结束阶段重新扫描那些被激活的栈帧。但是Go语言通常会有大量活跃的协程，这就导致第二次STW时重新扫描协程栈的时间太长。</p></blockquote><ol start=3><li>混合写屏障</li></ol><p>把指向的旧对象标记成灰色; 如果当前正在标记的goroutine栈没有完成标记完（标记完，它栈上的对象应该都是黑色的，如果还未有开始当时goroutine栈标记，它的栈应该还是灰色的）则将新对象也标记成灰色。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span> <span style=color:#a6e22e>writePointer</span>(<span style=color:#a6e22e>slot</span>, <span style=color:#a6e22e>ptr</span>): <span style=color:#75715e>// ⚠️:slot现在指向的还是旧的对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>     <span style=color:#a6e22e>shade</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span>) <span style=color:#75715e>//旧对象标记为灰色。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>     <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>current</span> <span style=color:#a6e22e>stack</span> <span style=color:#a6e22e>is</span> <span style=color:#a6e22e>grey</span>: <span style=color:#75715e>// The insertion part of the barrier is necessary while the calling goroutine&#39;s stack is grey.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         <span style=color:#a6e22e>shade</span>(<span style=color:#a6e22e>ptr</span>)
</span></span><span style=display:flex><span>     <span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span> = <span style=color:#a6e22e>ptr</span>
</span></span></code></pre></div><p>既可<strong>忽略当前栈帧的写屏障</strong>。(不管是插入写屏障，还是删除写屏障.)</p><ul><li><p>这里模拟很容易，黑色关联白色，且没有其他灰色关联这个黑色；就会出现hiding object。</p><ul><li>模拟heap上触发<strong>删除写屏障</strong>。&mdash;》所以stack上一个black object关联heap上面的white object；这时候heap上的其他颜色object断开与它的连接。</li><li>模拟heap上触发<strong>插入写屏障</strong>。<ul><li><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220727161744.png width=90% height=90% alt=gc></p></li></ul></li></ul></li><li><p>又不需要在第二次STW的时，重新扫描所有活跃G的栈帧。</p></li></ul><h1 id=golang垃圾回收>golang垃圾回收
<a class=anchor href=#golang%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6>#</a></h1><h2 id=总体流程>总体流程
<a class=anchor href=#%e6%80%bb%e4%bd%93%e6%b5%81%e7%a8%8b>#</a></h2><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220727142135.png width=90% height=90% alt=效果图></p><blockquote><p><a href=https://go.dev/blog/go15gc>In a tri-color collector, every object is either white, grey, or black and we view the heap as a graph of connected objects. At the start of a GC cycle all objects are white. The GC visits all roots, which are objects directly accessible by the application such as globals and things on the stack, and colors these grey. The GC then chooses a grey object, blackens it, and then scans it for pointers to other objects. When this scan finds a pointer to a white object, it turns that object grey. This process repeats until there are no more grey objects. At this point, white objects are known to be unreachable and can be reused.</a></p></blockquote><ul><li>gc开始：<ul><li>将所有的对象设置为<strong>白色</strong></li></ul></li><li>扫描阶段（scan）<ul><li>把全局变量和goroutine栈上的指针对象，标记为<strong>灰色</strong>, 而且收集起来（比如放入一个先入先出队列中）</li></ul></li><li>标记阶段(mark)<ul><li>从队列中弹出一个<strong>灰色</strong>指针对象</li><li>访问这个<strong>灰色</strong>对象所指向的对象，如果此对象是<strong>白色</strong>，则将它转变为<strong>灰色</strong>，并加入到队列中</li><li>将这个<strong>灰色</strong>对象标记为黑色，表示访问完毕</li><li>重复上述过程，直到队列为空(没有灰色对象了)</li></ul></li><li>清扫阶段(sweep)<ul><li>剩余的<strong>白色</strong>对象,说明不可达，可进行垃圾回收。</li></ul></li></ul><h3 id=三色>三色
<a class=anchor href=#%e4%b8%89%e8%89%b2>#</a></h3><h3 id=写屏障>写屏障
<a class=anchor href=#%e5%86%99%e5%b1%8f%e9%9a%9c>#</a></h3><p>背景：如果对栈和堆都执行写屏障(不管是插入写屏障，还是删除写屏障)，那么按照三色原则，插入写屏障使它不满足强三色不变式，删除写屏障使它一定不满足弱三色不变式。两种写屏障都不会错误回收。<strong>但是基于性能考虑，栈上不触发写屏障。</strong></p><ul><li><code>writePointer(slot, ptr):</code><ul><li><code>*slot</code>可能是null。</li><li><code>*slot</code>可能是它以前关联的那个值，现在要断开。</li><li><code>ptr</code>是现在将要关联的这个值。</li></ul></li></ul><p>引申的插入写屏障，删除写屏障</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>    <span style=color:#a6e22e>writePointer</span>(<span style=color:#a6e22e>slot</span>, <span style=color:#a6e22e>ptr</span>):  <span style=color:#75715e>// 插入写屏障
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>shade</span>(<span style=color:#a6e22e>ptr</span>) <span style=color:#75715e>//shade函数尝试改变指针的颜色--&gt;改变ptr的颜色
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span> = <span style=color:#a6e22e>ptr</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>writePointer</span>(<span style=color:#a6e22e>slot</span>, <span style=color:#a6e22e>ptr</span>)   <span style=color:#75715e>// 删除写屏障
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>shade</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span>) <span style=color:#75715e>//shade函数尝试改变指针的颜色--&gt;改变(*slot)的颜色---&gt;注意这个是*slot,slot保存着它原先的保存的地址。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span> = <span style=color:#a6e22e>ptr</span>
</span></span></code></pre></div><h4 id=写屏障的步骤推导>写屏障的步骤推导
<a class=anchor href=#%e5%86%99%e5%b1%8f%e9%9a%9c%e7%9a%84%e6%ad%a5%e9%aa%a4%e6%8e%a8%e5%af%bc>#</a></h4><pre tabindex=0><code>   |........标记清扫阶段...........|
STW begin                     STW end
</code></pre><ul><li><p>分类步骤:</p><ul><li>STW扫描的位置点: 是在<strong>开始扫描</strong>还是在<strong>最后来一次扫描</strong>?</li><li>STW扫描可以按照每个goroutine的方式来一个个扫描? 不必一次暂停所有goroutine栈<ul><li>STW goroutine栈扫描: 栈上对象都变成黑色,一些堆对象(与栈对联直连)为灰色,其他的为白色.// TODO picture</li></ul></li><li>创建的新对象是黑色还是白色?</li></ul></li><li><p>防止类型就是:</p><ul><li>heap_black_object -> heap_white_object</li><li>stack_black_object -> heap_white_object</li></ul></li></ul><hr><h5 id=插入写屏障>插入写屏障
<a class=anchor href=#%e6%8f%92%e5%85%a5%e5%86%99%e5%b1%8f%e9%9a%9c>#</a></h5><table><thead><tr><th>开始步骤</th><th>步骤</th><th>\</th><th>新生成对象的颜色</th></tr></thead><tbody><tr><td>STW全栈扫描</td><td>堆上使用插入写屏障</td><td>\</td><td>新生成的对象都是黑色</td></tr><tr><td>STW goroutine栈扫描</td><td>堆上使用插入写屏障</td><td>\</td><td>新生成的对象都是黑色</td></tr><tr><td>堆上使用插入写屏障</td><td>STW全栈扫描</td><td>\</td><td>新生成的对象黑白都可</td></tr><tr><td>堆上使用插入写屏障</td><td>STW goroutine栈扫描</td><td>\</td><td>新生成的对象黑白都可</td></tr></tbody></table><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>/**************<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span>**************/ 
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  STW全栈扫描
</span></span><span style=display:flex><span>  堆上使用插入写屏障 | <span style=color:#f92672>[</span>创建新对象为黑色<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>/**************<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span>**************/ 
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  STW goroutine栈扫描
</span></span><span style=display:flex><span>  堆上使用插入写屏障 | <span style=color:#f92672>[</span>创建新对象为黑色<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>/**************<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span>**************/ 
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  堆上使用插入写屏障 | <span style=color:#f92672>[</span>创建新对象为可以为白色,也可以为黑色<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  STW全栈扫描
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>/**************<span style=color:#f92672>(</span>4<span style=color:#f92672>)</span>**************/ 
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  堆上使用插入写屏障 | <span style=color:#f92672>[</span>创建新对象为可以为白色,也可以为黑色<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  STW goroutine栈扫描
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>(1)(2)不行,如图:</p><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210404172432.png width=90% height=90% alt=效果图></p><p>(3)可以,1.5到1.7就是使用的这种方式
(4)没必要了,都是最后STW,重新扫描一次灰色的goroutine栈</p><h5 id=删除写屏障>删除写屏障
<a class=anchor href=#%e5%88%a0%e9%99%a4%e5%86%99%e5%b1%8f%e9%9a%9c>#</a></h5><ul><li>删除写屏障<ul><li>起始快照整栈跨找，扫黑，使得整个堆上的在用对象都处于灰色保护；<ul><li>整栈扫黑，那么在用的堆上的对象是一定处于灰色堆对象的保护下的，之后配合堆对象删除写屏障就能保证在用对象不丢失。</li></ul></li><li>加入插入写屏障的逻辑，C 指向 D 的时候，把 D 置灰，这样扫描也没问题。这样就能去掉起始 STW 扫描，从而可以并发，一个一个栈扫描。</li></ul></li></ul><table><thead><tr><th>开始步骤</th><th>步骤</th><th>\</th><th>新生成对象的颜色</th></tr></thead><tbody><tr><td>STW全栈扫描</td><td>堆上使用删除写屏障</td><td>\</td><td>新生成的对象都是黑色</td></tr><tr><td>STW goroutine栈扫描</td><td>堆上使用删除写屏障</td><td>\</td><td>新生成的对象都是黑色</td></tr><tr><td>堆上使用删除写屏障</td><td>STW全栈扫描</td><td>\</td><td>新生成的对象黑白都可</td></tr><tr><td>堆上使用删除写屏障</td><td>STW goroutine栈扫描</td><td>\</td><td>新生成的对象黑白都可</td></tr></tbody></table><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>/**************<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span>**************/ 
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  STW全栈扫描
</span></span><span style=display:flex><span>  堆上使用删除写屏障 | <span style=color:#f92672>[</span>创建新对象为黑色<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>/**************<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span>**************/ 
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  STW goroutine栈扫描
</span></span><span style=display:flex><span>  堆上使用删除写屏障 | <span style=color:#f92672>[</span>创建新对象为黑色<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>/**************<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span>**************/ 
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  堆上使用删除写屏障 | <span style=color:#f92672>[</span>创建新对象为可以为白色/黑色<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  STW全栈扫描
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>/**************<span style=color:#f92672>(</span>4<span style=color:#f92672>)</span>**************/ 
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  堆上使用删除写屏障 | <span style=color:#f92672>[</span>创建新对象为可以为白色/黑色<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  STW goroutine栈扫描
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>(1)可以
(2)不行,如图:</p><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210404172300.png width=90% height=90% alt=效果图></p><p>(3)(4)的话,因为是最后进行栈重新扫描,可以知道不会出现<code>stack_black_object -> heap_white_object</code>这种情况.
如图:
// TODO</p><h5 id=混合写屏障hybrid-write-barrier>混合写屏障（hybrid write barrier）
<a class=anchor href=#%e6%b7%b7%e5%90%88%e5%86%99%e5%b1%8f%e9%9a%9chybrid-write-barrier>#</a></h5><blockquote><p>由前面的删除写屏障(2),我们只要加上插入写屏障就能避免出现隐藏白色对象这种情况.</p><blockquote><p>这个也是<code>if current stack is grey:</code>的由来.</p></blockquote></blockquote><table><thead><tr><th>步骤</th><th>步骤</th><th>\</th><th>新生成对象的颜色</th></tr></thead><tbody><tr><td>STW goroutine栈扫描(要么全黑要么全白)</td><td>堆上使用删除写屏障+堆上使用插入写屏障</td><td>\</td><td>新生成的对象都是黑色</td></tr></tbody></table><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>writePointer</span>(<span style=color:#a6e22e>slot</span>, <span style=color:#a6e22e>ptr</span>):
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>shade</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>current</span> <span style=color:#a6e22e>stack</span> <span style=color:#a6e22e>is</span> <span style=color:#a6e22e>grey</span>:
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>shade</span>(<span style=color:#a6e22e>ptr</span>)
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span> = <span style=color:#a6e22e>ptr</span>
</span></span></code></pre></div><blockquote><p>The hybrid barrier requires that objects be allocated black (allocate-white is a common policy, but incompatible with this barrier).</p></blockquote><p><a href=https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md>https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md</a></p><h1 id=fqa>FQA
<a class=anchor href=#fqa>#</a></h1><h2 id=为什么gc也要扫描栈不是都在堆上面吗>为什么gc也要扫描栈，不是都在堆上面吗？
<a class=anchor href=#%e4%b8%ba%e4%bb%80%e4%b9%88gc%e4%b9%9f%e8%a6%81%e6%89%ab%e6%8f%8f%e6%a0%88%e4%b8%8d%e6%98%af%e9%83%bd%e5%9c%a8%e5%a0%86%e4%b8%8a%e9%9d%a2%e5%90%97>#</a></h2><p>因为堆上的地址，可能保存在栈上某个变量里，所以需要扫描。</p><h2 id=混合写屏障>混合写屏障
<a class=anchor href=#%e6%b7%b7%e5%90%88%e5%86%99%e5%b1%8f%e9%9a%9c>#</a></h2><p>问：我就是觉得混合写屏障好像也没法 解决重新扫描栈的问题</p><p>现在有 A, B, C三个对象，A(黑色，栈上)，B（灰色，栈上），C（白色，堆上）；
当前引用关系是：</p><pre tabindex=0><code>A（黑） -&gt; nil
B（灰） -&gt; C（白）
</code></pre><p>现在应用程序赋值修改，把A指向C：</p><pre tabindex=0><code>A（黑） -&gt; C（白）
B（灰） -&gt; nil
</code></pre><p>由于A，B是栈上的对象，栈上对象赋值这里可是没有写屏障的；那么岂不是黑色对象指向白色对象了，C会回收了，就悬挂指针了？</p><hr><p>答：Goroutine 栈扫描的过程需要 STW，所以你描述的这种状况是不存在的，<strong>栈上的对象要么全白要么全黑</strong></p><blockquote><ul><li>你说的“栈上的对象要么全白，要么全黑“ ，这个只是对一个 goroutine 栈来说的（golang 暂停业务扫描栈也是一个一个来的）。如果场景是 A 在 Goroutine1，B在Goroutine2呢？这种情况就是A是黑色，B是白色或者灰色。这样会不会就有我说的原本那个问题呢？<ul><li><a href=https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md#channel-operations-and-go-statements>The hybrid barrier assumes a goroutine cannot write to another goroutine&rsquo;s stack.(混合写屏障假设一个goroutine,不能写到另一个goroutine的栈)</a></li></ul></li><li>除了从一个Goroutine通过chan发送/生成一个新Goroutine<ul><li>如果两个Goroutine 栈只要有一个是灰色的，那么就会有<code>shade(ptr)</code></li><li>新生成的Goroutine栈都是黑色的（由前面的条件保证）,如果父Goroutine是灰色的，那么需使用<code>shade(ptr)</code></li></ul></li></ul></blockquote><h2 id=golang中gc支持增量与并发式回收怎么理解>Golang中GC支持增量与并发式回收怎么理解
<a class=anchor href=#golang%e4%b8%adgc%e6%94%af%e6%8c%81%e5%a2%9e%e9%87%8f%e4%b8%8e%e5%b9%b6%e5%8f%91%e5%bc%8f%e5%9b%9e%e6%94%b6%e6%80%8e%e4%b9%88%e7%90%86%e8%a7%a3>#</a></h2><p>增量和并发，一个是横向一个是纵向，gc与mutator交替与运行。</p><ul><li>横向：增量垃圾收集（增量地标记和清除垃圾，降低应用程序暂停的最长时间）</li><li>纵向：并发垃圾收集（利用多核的计算资源，在用户程序执行时并发标记和清除垃圾）<ul><li>因为增量和并发两种方式都可以与用户程序交替运行，所以我们需要使用屏障技术保证垃圾收集的正确性.</li></ul></li></ul><hr><ul><li><p>使用混合写屏障的原因是缩短gc暂停的时间。</p><ul><li>因为栈上使用写屏障，会导致耗时太多。但是如果栈上不使用写屏障，等到第二次STW重新扫描栈空间，goroutine数目多，需要扫描的stack耗时也多。
忽略协程栈的写屏障;其他的使用删除写屏障，插入写屏障。</li></ul></li><li><p>如果没有任何STW的时间，也就是说垃圾回收程序与用户程序完全并发执行，其代价与实现难度可能都会高于短暂的STW。例如标记——清扫回收器中，若完全抛弃STW，那么垃圾回收开始的消息便很难准确及时地通知到所有线程，可能导致<strong>某些线程</strong>开启<strong>写屏障</strong>的动作有所延迟而无法保障双方执行的正确性。</p></li></ul><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210113105703.png alt=gc></p><h2 id=为什么清扫阶段不需要屏障了呢>为什么清扫阶段不需要屏障了呢？
<a class=anchor href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%b8%85%e6%89%ab%e9%98%b6%e6%ae%b5%e4%b8%8d%e9%9c%80%e8%a6%81%e5%b1%8f%e9%9a%9c%e4%ba%86%e5%91%a2>#</a></h2><p>当标记完成了，那么它白色的对象都是不可达的对象，是可以删除的对象，程序不可能再找到已经不可达的对象。所以放心的清除。</p><h2 id=golang的heap结构>golang的heap结构
<a class=anchor href=#golang%e7%9a%84heap%e7%bb%93%e6%9e%84>#</a></h2><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210113134838.png alt=20210113134838>
参见下面的内存分配器</p><ul><li><ol start=3><li>Golang中GC的三色标记
-（1）着为灰色对应的操作就是把指针对应的<code>gcmarkBits</code>标记位置为1并<strong>加入工作队列</strong>；
-（2）着为黑色对应的操作就是把指针对应的<code>gcmarkBits</code>标记位置为<code>1</code>。
-（3）白色对象就是那些<code>gcMarkBits</code>中标记为0的对象。</li></ol></li></ul><p>知道标记在哪了，那么如果进行分工？</p><h4 id=四-工作队列相关的问题并发标记的分工问题写屏障记录集的竞争问题>四: <strong>工作队列</strong>相关的问题：并发标记的分工问题？写屏障记录集的竞争问题？
<a class=anchor href=#%e5%9b%9b-%e5%b7%a5%e4%bd%9c%e9%98%9f%e5%88%97%e7%9b%b8%e5%85%b3%e7%9a%84%e9%97%ae%e9%a2%98%e5%b9%b6%e5%8f%91%e6%a0%87%e8%ae%b0%e7%9a%84%e5%88%86%e5%b7%a5%e9%97%ae%e9%a2%98%e5%86%99%e5%b1%8f%e9%9a%9c%e8%ae%b0%e5%bd%95%e9%9b%86%e7%9a%84%e7%ab%9e%e4%ba%89%e9%97%ae%e9%a2%98>#</a></h4><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210121134453.png alt=20210121134453></p><blockquote><p>这里的竞争问题，我怀疑是： 一个是gc从root Object到一直遍历，打标记(从上到下)，同时另一个用户程序也在更新Object的关联（比如从从一个灰色到白色节点断开）</p><blockquote><p>其中用户程序的写到每个P中的写屏障缓冲区。</p></blockquote></blockquote><ul><li>前面提到了全局变量work中存储着全局工作队列缓存（work.full），其实每个P都有<strong>一个本地工作队列（p.gcw）和一个写屏障缓冲（p.wbBuf）</strong>。</li><li>p.gcw中有两个workbuf：wbuf1和wbuf2，添加任务时总是从wbuf1添加，wbuf1满了就交换wbuf1和wbuf2，如果还是满的，就把当前wbuf1的工作flush到全局工作缓存中去。</li></ul><p>知道分工了，不可能占用很多CPU进行gc,这样会限制用户程序。</p><h4 id=五-cup-utilization>五： CUP utilization
<a class=anchor href=#%e4%ba%94-cup-utilization>#</a></h4><ul><li>GC默认的CPU目标使用率为25%，在GC执行的初始化阶段，会根据当前CPU核数乘以CPU目标使用率来计算需要启动的<code>mark worker</code>数量。</li><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210113134856.png alt=20210113134856></li></ul><h4 id=todo-并发gc如何缓解内存分配压力>TODO: 并发GC如何缓解内存分配压力？
<a class=anchor href=#todo-%e5%b9%b6%e5%8f%91gc%e5%a6%82%e4%bd%95%e7%bc%93%e8%a7%a3%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%8e%8b%e5%8a%9b>#</a></h4><ul><li>借贷偿还机制。也可以偷。</li></ul><h1 id=总结>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93>#</a></h1><h2 id=为什么golang需要gc>为什么golang需要GC
<a class=anchor href=#%e4%b8%ba%e4%bb%80%e4%b9%88golang%e9%9c%80%e8%a6%81gc>#</a></h2><blockquote><h3 id=what>what:
<a class=anchor href=#what>#</a></h3></blockquote><ul><li>gc主要是释放那些不再需要的分配在堆（heap）上的数据</li></ul><blockquote><h3 id=why>why:
<a class=anchor href=#why>#</a></h3></blockquote><ul><li>降低人的心智负担，从堆（heap）中申请的内存，不需要手动的释放。</li></ul><blockquote><h3 id=how>how:
<a class=anchor href=#how>#</a></h3></blockquote><ul><li>一般判断对象是否存活是使用：是把可达性近视的认为存活性.<ul><li>可把栈（stack），数据段（data segment? bss?）的数据对象作为root</li></ul></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><script src=https://giscus.app/client.js data-repo=zput/utterances-comments data-repo-id=R_kgDOHhATGQ data-category=Announcements data-category-id=DIC_kwDOHhATGc4CPxca data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=1 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#1-前言变量的存放区>1 前言：变量的存放区</a><ul><li><a href=#2-定义>2 定义</a><ul><li><a href=#21-垃圾识别>2.1 垃圾识别</a><ul><li><a href=#211-双色标记法>2.1.1 双色标记法</a></li><li><a href=#212-三色标记法>2.1.2 三色标记法</a></li></ul></li></ul></li></ul></li><li><a href=#golang垃圾回收>golang垃圾回收</a><ul><li><a href=#总体流程>总体流程</a><ul><li><a href=#三色>三色</a></li><li><a href=#写屏障>写屏障</a><ul><li><a href=#写屏障的步骤推导>写屏障的步骤推导</a></li></ul></li></ul></li></ul></li><li><a href=#fqa>FQA</a><ul><li><a href=#为什么gc也要扫描栈不是都在堆上面吗>为什么gc也要扫描栈，不是都在堆上面吗？</a></li><li><a href=#混合写屏障>混合写屏障</a></li><li><a href=#golang中gc支持增量与并发式回收怎么理解>Golang中GC支持增量与并发式回收怎么理解</a></li><li><a href=#为什么清扫阶段不需要屏障了呢>为什么清扫阶段不需要屏障了呢？</a></li><li><a href=#golang的heap结构>golang的heap结构</a><ul><li><ul><li><a href=#四-工作队列相关的问题并发标记的分工问题写屏障记录集的竞争问题>四: <strong>工作队列</strong>相关的问题：并发标记的分工问题？写屏障记录集的竞争问题？</a></li><li><a href=#五-cup-utilization>五： CUP utilization</a></li><li><a href=#todo-并发gc如何缓解内存分配压力>TODO: 并发GC如何缓解内存分配压力？</a></li></ul></li></ul></li></ul></li><li><a href=#总结>总结</a><ul><li><a href=#为什么golang需要gc>为什么golang需要GC</a><ul><li><a href=#what>what:</a></li><li><a href=#why>why:</a></li><li><a href=#how>how:</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html><script type=text/javascript src=https://cdn.bootcss.com/viz.js/1.8.2/viz.js></script><script type=text/javascript>(function(){var e="language-viz-";Array.prototype.forEach.call(document.querySelectorAll("[class^="+e+"]"),function(t){console.log(t),t.getAttribute("class").split(" ").forEach(function(t){t.startsWith(e)&&(s=t.substr(e.length))}),console.log("------------MIDDLE--------");var s,o=Viz(t.innerText,{format:"svg",engine:s}),n=(new DOMParser).parseFromString(o,"image/svg+xml");n.documentElement.setAttribute("style","max-width:100%; max-height:100%;"),t.parentNode.insertBefore(n.documentElement,t),t.style.display="none",t.parentNode.style.backgroundColor="white",t.style.width=n.documentElement.getAttribute("width")+"px",t.style.height=n.documentElement.getAttribute("height")+"px",console.log("--------------END------")})})()</script>