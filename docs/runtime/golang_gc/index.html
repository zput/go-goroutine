<!doctype html><html lang=zh dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="1 前言：变量的存放区 # 通常情况下，变量的分配位置一般是下列三个区：
全局数据区 栈区 堆区 全局数据区:主要用于全局变量的分配，也即包级别的变量,其生命周期和进程相同。
栈区:主要存储函数内部定义的本地变量,当函数执行完毕，变量即可释放。函数执行时通过栈帧加偏移来访问这些数据。
堆区:主要用于程序运行阶段的动态分配。
内存中的对象存在着相互的引用关系。全局数据区与栈区可能指同堆上的数据,这两个地方的指针是堆内存访问的起点，也就是堆内存访问的根节点(root)。
2 定义 # 垃圾回收（garbage collect）简称gc,主要是释放那些不再需要的分配在堆（heap）上的数据, 以便再次用来进行内存分配。垃圾回收一般分为两个步骤：垃圾识别和垃圾清理。
golang支持垃圾自动回收，主要是降低人的心智负担，从堆（heap）中申请的内存，不需要手动的释放。其采用三色标记法来识别垃圾对象，并使用清除算法进行垃圾清理。
2.1 垃圾识别 # 2.1.1 双色标记法 # 根节点一般为全局变量、栈中的变量，维护根节点集合是可达性分析的前提。可达性分析是指从根对象开始，遍历其引用的子节点对象，直至遍历完毕。凡是能够触达的对象，都视作有效对象，而无法触达的，则视作垃圾对象。
双色标标记法采用可达性分析来标记对象状态;通过对象的可达性近视的认为存活性。
双色标记法看上去简单易用，但却存在着一个比较大的缺点，即整个标记过程必须一次性完成，中间不能有任何停顿。也就是说，在执行过程中，不能让出CPU时间片给其他线程。对于应用程序来说，可能会出现用户线程完全停顿，直至标记过程结束。
双色标记法只能描述对象节点自身是否扫描，而不能描述子节点是否完成。这导致重启标记开始后，很难抉择该如何继续，如果再次从根节点开始，那就意味着上次所做的工作完全被浪费掉了。因此，双色标记在停顿、再次重启过程中，无法完成状态的自描述。
由于新增对象无法确定置为黑色还是白色，因此导致扫描过程不能停顿。对双色标记而言可将新增对象直接标记为黑色，然后到下轮垃圾回收才将本轮新增对象中的垃圾对象（往往是生命周期很短的对象）清除。
2.1.2 三色标记法 # 全局数据区与栈区的指针是堆内存访问的起点, 所以把它们放入一个待扫描队列（工作队列）,通过它们可以发现堆上第一批可达数据,发现的可达数据中有指针的加入待扫描队列（灰色节点）扫描完的标为黑色，离开队列,通过扫描灰色节点会发现更多灰色节点，也会产生更多黑色点节点,直到没有待扫描的灰色节点,我们就找到了所有可达数据（黑色节点）,剩下的白色节点就是不可达数据不可达自然用不到,也即是可以进行释放。
黑色：当基于当前节点的追踪任务完成后，表示为存活数据，后续无需再追踪。 灰色：基于当前节点展开的追踪还未完成。 白色：当追踪完成后，代表可回收的对象。 问题：黑色对象如果指向白色对象,会导致白色对象被错误回收。
原因： 并发执行,如果将白色对象写入黑色对象,同时没有其它未扫描的路径,可抵达该白色对象,它就不会被扫描携程发现,继而被误判为垃圾。
当gc使用三色标记法与用户程序并发执行的时候，可能让黑色对象重新引用了白色对象，且无其他灰色对象引用了这个白色对象。导致白色对象错误回收。(用户程序和垃圾收集器可以在交替工作的)
处理措施：
有两种方法来避免:
强三色：黑色对象只能引用灰色对象。 弱三色：所有被黑色对象引用的白色对象都处于灰色保护状态. 引入写屏障：就是在执行写操作时，额外做些标记工作(把数据对象的修改通知到垃圾回收器)，避免垃圾误判。
分为两种，一种是插入写屏障，一种是删除写屏障。
插入写屏障 writePointer(slot, ptr): // ⚠️:slot现在指向的还是旧对象 shade(ptr) //shade函数尝试改变指针的颜色-->改变ptr的颜色 *slot = ptr 删除写屏障： 会在老对象的引用被删除时，将白色的老对象涂成灰色。 writePointer(slot, ptr) // ⚠️:slot现在指向的还是旧对象 shade(*slot) //shade函数尝试改变指针的颜色-->改变(*slot)的颜色--->注意这个是*slot(旧对象),slot保存着它原先的保存的地址。 *slot = ptr 引入新问题：只有插入写屏障，但是这需要对所有堆、栈的写操作都开启写屏障，程序性能会受到影响，代价太大。为了改善这个问题，改为忽略协程栈上的写屏障，只在标记结束阶段重新扫描那些被激活的栈帧。但是Go语言通常会有大量活跃的协程，这就导致第二次STW时重新扫描协程栈的时间太长。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://zput.github.io/go-goroutine/docs/runtime/golang_gc/"><meta property="og:site_name" content="go调度源码分析"><meta property="og:title" content="垃圾回收"><meta property="og:description" content="1 前言：变量的存放区 # 通常情况下，变量的分配位置一般是下列三个区：
全局数据区 栈区 堆区 全局数据区:主要用于全局变量的分配，也即包级别的变量,其生命周期和进程相同。
栈区:主要存储函数内部定义的本地变量,当函数执行完毕，变量即可释放。函数执行时通过栈帧加偏移来访问这些数据。
堆区:主要用于程序运行阶段的动态分配。
内存中的对象存在着相互的引用关系。全局数据区与栈区可能指同堆上的数据,这两个地方的指针是堆内存访问的起点，也就是堆内存访问的根节点(root)。
2 定义 # 垃圾回收（garbage collect）简称gc,主要是释放那些不再需要的分配在堆（heap）上的数据, 以便再次用来进行内存分配。垃圾回收一般分为两个步骤：垃圾识别和垃圾清理。
golang支持垃圾自动回收，主要是降低人的心智负担，从堆（heap）中申请的内存，不需要手动的释放。其采用三色标记法来识别垃圾对象，并使用清除算法进行垃圾清理。
2.1 垃圾识别 # 2.1.1 双色标记法 # 根节点一般为全局变量、栈中的变量，维护根节点集合是可达性分析的前提。可达性分析是指从根对象开始，遍历其引用的子节点对象，直至遍历完毕。凡是能够触达的对象，都视作有效对象，而无法触达的，则视作垃圾对象。
双色标标记法采用可达性分析来标记对象状态;通过对象的可达性近视的认为存活性。
双色标记法看上去简单易用，但却存在着一个比较大的缺点，即整个标记过程必须一次性完成，中间不能有任何停顿。也就是说，在执行过程中，不能让出CPU时间片给其他线程。对于应用程序来说，可能会出现用户线程完全停顿，直至标记过程结束。
双色标记法只能描述对象节点自身是否扫描，而不能描述子节点是否完成。这导致重启标记开始后，很难抉择该如何继续，如果再次从根节点开始，那就意味着上次所做的工作完全被浪费掉了。因此，双色标记在停顿、再次重启过程中，无法完成状态的自描述。
由于新增对象无法确定置为黑色还是白色，因此导致扫描过程不能停顿。对双色标记而言可将新增对象直接标记为黑色，然后到下轮垃圾回收才将本轮新增对象中的垃圾对象（往往是生命周期很短的对象）清除。
2.1.2 三色标记法 # 全局数据区与栈区的指针是堆内存访问的起点, 所以把它们放入一个待扫描队列（工作队列）,通过它们可以发现堆上第一批可达数据,发现的可达数据中有指针的加入待扫描队列（灰色节点）扫描完的标为黑色，离开队列,通过扫描灰色节点会发现更多灰色节点，也会产生更多黑色点节点,直到没有待扫描的灰色节点,我们就找到了所有可达数据（黑色节点）,剩下的白色节点就是不可达数据不可达自然用不到,也即是可以进行释放。
黑色：当基于当前节点的追踪任务完成后，表示为存活数据，后续无需再追踪。 灰色：基于当前节点展开的追踪还未完成。 白色：当追踪完成后，代表可回收的对象。 问题：黑色对象如果指向白色对象,会导致白色对象被错误回收。
原因： 并发执行,如果将白色对象写入黑色对象,同时没有其它未扫描的路径,可抵达该白色对象,它就不会被扫描携程发现,继而被误判为垃圾。
当gc使用三色标记法与用户程序并发执行的时候，可能让黑色对象重新引用了白色对象，且无其他灰色对象引用了这个白色对象。导致白色对象错误回收。(用户程序和垃圾收集器可以在交替工作的)
处理措施：
有两种方法来避免:
强三色：黑色对象只能引用灰色对象。 弱三色：所有被黑色对象引用的白色对象都处于灰色保护状态. 引入写屏障：就是在执行写操作时，额外做些标记工作(把数据对象的修改通知到垃圾回收器)，避免垃圾误判。
分为两种，一种是插入写屏障，一种是删除写屏障。
插入写屏障 writePointer(slot, ptr): // ⚠️:slot现在指向的还是旧对象 shade(ptr) //shade函数尝试改变指针的颜色-->改变ptr的颜色 *slot = ptr 删除写屏障： 会在老对象的引用被删除时，将白色的老对象涂成灰色。 writePointer(slot, ptr) // ⚠️:slot现在指向的还是旧对象 shade(*slot) //shade函数尝试改变指针的颜色-->改变(*slot)的颜色--->注意这个是*slot(旧对象),slot保存着它原先的保存的地址。 *slot = ptr 引入新问题：只有插入写屏障，但是这需要对所有堆、栈的写操作都开启写屏障，程序性能会受到影响，代价太大。为了改善这个问题，改为忽略协程栈上的写屏障，只在标记结束阶段重新扫描那些被激活的栈帧。但是Go语言通常会有大量活跃的协程，这就导致第二次STW时重新扫描协程栈的时间太长。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>垃圾回收 | go调度源码分析</title>
<link rel=manifest href=/go-goroutine/manifest.json><link rel=icon href=/go-goroutine/favicon.png><link rel=stylesheet href=/go-goroutine/book.min.a7d3a43391e1f7eb43ae94bcae6354b739c49cba56473620924ec707afe0864d.css integrity="sha256-p9OkM5Hh9+tDrpS8rmNUtznEnLpWRzYgkk7HB6/ghk0=" crossorigin=anonymous><script defer src=/go-goroutine/flexsearch.min.js></script><script defer src=/go-goroutine/en.search.min.7aa8f6ba29cc1cea57c470bbfe1eb91c523936bb33fcbafa08abf2f7cc240e96.js integrity="sha256-eqj2uinMHOpXxHC7/h65HFI5Nrsz/Lr6CKvy98wkDpY=" crossorigin=anonymous></script><script defer src=/go-goroutine/sw.min.ec96d6e09af3075a94dd4de723a2edddf2ef138381c7e1e5b5a1f2c0578ee8bd.js integrity="sha256-7JbW4JrzB1qU3U3nI6Lt3fLvE4OBx+HltaHywFeO6L0=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/go-goroutine/><span>go调度源码分析</span></a></h2><div class=magic><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><div class=book-switch><label class=switch><input id=dark-mode-checkbox type=checkbox onchange=darkmode()>
<span class=slider></span></label></div></div><ul><li><a href=https://zput.github.io target=_blank rel=noopener>Zput博客</a></li><li><a href=https://github.com/zput target=_blank rel=noopener>GitHub</a></li></ul><hr><ul><li><span>基础知识</span><ul><li><a href=/go-goroutine/docs/foundation/golang_basic/>基本用法</a></li><li><a href=/go-goroutine/docs/foundation/slice/>slice</a></li><li><a href=/go-goroutine/docs/foundation/map/>map</a></li><li><a href=/go-goroutine/docs/foundation/sort/>sort</a></li><li><a href=/go-goroutine/docs/foundation/directory/>Directory</a></li></ul></li><li><span>鲁棒和性能</span><ul><li><a href=/go-goroutine/docs/robustness_and_performance/golang_test/>测试相关函数</a></li></ul></li><li><span>运行时</span><ul><li><a href=/go-goroutine/docs/runtime/golang_gmp/>GMP</a></li><li><span>堆分配原理</span><ul><li><a href=/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/1_summarize/>概述</a></li><li><a href=/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_big_object/>分配大对象</a></li><li><a href=/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_middle_object/>概述</a></li><li><a href=/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_small_object/>概述</a></li></ul></li><li><a href=/go-goroutine/docs/runtime/complement-source-reverse/>源码-反码-补码</a></li><li><a href=/go-goroutine/docs/runtime/golang_memery/>内存分配器</a></li><li><a href=/go-goroutine/docs/runtime/golang_gc/ class=active>垃圾回收</a></li><li><a href=/go-goroutine/docs/runtime/schedule/>调度</a><ul><li><span>前置知识</span><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/memory/>内存大小端</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/register_functionstack/>伪寄存器与函数栈帧</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/similar_assemble/>类汇编</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/go_underlying_struct/>底层重要结构</a></li></ul></li><li><a href=/go-goroutine/docs/runtime/schedule/2_init_before_enter_main_function/>初始化</a></li><li><a href=/go-goroutine/docs/runtime/schedule/3_exit_goroutine/>退出</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/>调度挑选策略</a><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/take_goroutine_from_globalorlocal_p/>从全局/本P队列</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/steal_goroutine_from_other_p/>从其他P队列</a></li></ul></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/>调度到达时机</a><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/active_scheduling/>主动调度</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/passive_scheduling/>被动调度</a></li><li><input type=checkbox id=section-740657f38f0c4de9a986bda642ff0388 class=toggle>
<label for=section-740657f38f0c4de9a986bda642ff0388 class="flex justify-between"><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/>剥夺调度</a></label><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/start_sysmon/>开启系统监控</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/user_code_preemption/>代码执行过久</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/system_call_preemption/>陷入系统调用</a></li></ul></li></ul></li></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script><script src=/go-goroutine/magic.js></script><script src=/go-goroutine/dark.js></script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/go-goroutine/svg/menu.svg class=book-icon alt=Menu>
</label><strong>垃圾回收</strong>
<label for=toc-control><img src=/go-goroutine/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#1-前言变量的存放区>1 前言：变量的存放区</a></li><li><a href=#2-定义>2 定义</a><ul><li><a href=#21-垃圾识别>2.1 垃圾识别</a><ul><li><a href=#211-双色标记法>2.1.1 双色标记法</a></li><li><a href=#212-三色标记法>2.1.2 三色标记法</a></li></ul></li></ul></li><li><a href=#3-golang垃圾回收>3 golang垃圾回收</a><ul><li><a href=#31-三色标记法>3.1 三色标记法</a></li><li><a href=#32-总体流程>3.2 总体流程</a><ul><li><a href=#321-第一次stw>3.2.1 第一次STW</a><ul><li><a href=#预先生成标记协程>预先生成标记协程</a></li><li><a href=#控制标记协程的cpu利用率>控制标记协程的CPU利用率</a></li></ul></li><li><a href=#322-标记阶段>3.2.2 标记阶段</a></li><li><a href=#323-第二次stw>3.2.3 第二次STW</a></li><li><a href=#324-清扫阶段>3.2.4 清扫阶段</a></li><li><a href=#xx>xx</a></li></ul></li><li><a href=#并发标记的分工问题写屏障记录集的竞争问题>并发标记的分工问题？写屏障记录集的竞争问题？</a></li></ul></li><li><a href=#fqa>FQA</a><ul><li><a href=#为什么gc也要扫描栈不是都在堆上面吗>为什么gc也要扫描栈，不是都在堆上面吗？</a></li><li><a href=#混合写屏障>混合写屏障</a></li><li><a href=#golang中gc支持增量与并发式回收怎么理解>Golang中GC支持增量与并发式回收怎么理解</a></li><li><a href=#为什么清扫阶段不需要屏障了呢>为什么清扫阶段不需要屏障了呢？</a><ul><li><ul><li><a href=#todo-并发gc如何缓解内存分配压力>TODO: 并发GC如何缓解内存分配压力？</a></li></ul></li></ul></li></ul></li><li><a href=#总结>总结</a><ul><li><a href=#为什么golang需要gc>为什么golang需要GC</a><ul><li><a href=#what>what:</a></li><li><a href=#why>why:</a></li><li><a href=#how>how:</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=1-前言变量的存放区>1 前言：变量的存放区
<a class=anchor href=#1-%e5%89%8d%e8%a8%80%e5%8f%98%e9%87%8f%e7%9a%84%e5%ad%98%e6%94%be%e5%8c%ba>#</a></h1><p>通常情况下，变量的分配位置一般是下列三个区：</p><ol><li>全局数据区</li><li>栈区</li><li>堆区</li></ol><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240622185210.png width=70% height=70% alt=效果图></p><p>全局数据区:主要用于全局变量的分配，也即包级别的变量,其生命周期和进程相同。</p><p>栈区:主要存储函数内部定义的本地变量,当函数执行完毕，变量即可释放。函数执行时通过栈帧加偏移来访问这些数据。</p><p>堆区:主要用于程序运行阶段的动态分配。</p><p>内存中的对象存在着相互的引用关系。全局数据区与栈区可能指同堆上的数据,这两个地方的指针是堆内存访问的起点，也就是堆内存访问的根节点(root)。</p><h1 id=2-定义>2 定义
<a class=anchor href=#2-%e5%ae%9a%e4%b9%89>#</a></h1><p>垃圾回收（garbage collect）简称gc,主要是释放那些不再需要的分配在堆（heap）上的数据, 以便再次用来进行内存分配。垃圾回收一般分为两个步骤：<strong>垃圾识别</strong>和<strong>垃圾清理</strong>。</p><p>golang支持垃圾自动回收，主要是降低人的心智负担，从堆（heap）中申请的内存，不需要手动的释放。其采用三色标记法来识别垃圾对象，并使用清除算法进行垃圾清理。</p><h2 id=21-垃圾识别>2.1 垃圾识别
<a class=anchor href=#21-%e5%9e%83%e5%9c%be%e8%af%86%e5%88%ab>#</a></h2><h3 id=211-双色标记法>2.1.1 双色标记法
<a class=anchor href=#211-%e5%8f%8c%e8%89%b2%e6%a0%87%e8%ae%b0%e6%b3%95>#</a></h3><p>根节点一般为全局变量、栈中的变量，维护根节点集合是可达性分析的前提。可达性分析是指从根对象开始，遍历其引用的子节点对象，直至遍历完毕。凡是能够触达的对象，都视作有效对象，而无法触达的，则视作垃圾对象。</p><p>双色标标记法采用可达性分析来标记对象状态;通过对象的可达性近视的认为存活性。</p><p>双色标记法看上去简单易用，但却存在着一个比较大的缺点，即整个标记过程必须一次性完成，中间不能有任何停顿。也就是说，在执行过程中，不能让出CPU时间片给其他线程。对于应用程序来说，可能会出现用户线程完全停顿，直至标记过程结束。</p><p>双色标记法只能描述对象节点自身是否扫描，<strong>而不能描述子节点是否完成</strong>。这导致重启标记开始后，很难抉择该如何继续，如果再次从根节点开始，那就意味着上次所做的工作完全被浪费掉了。因此，双色标记在停顿、再次重启过程中，无法完成状态的自描述。</p><blockquote><p>由于新增对象无法确定置为黑色还是白色，因此导致扫描过程不能停顿。对双色标记而言可将新增对象直接标记为黑色，然后到下轮垃圾回收才将本轮新增对象中的垃圾对象（往往是生命周期很短的对象）清除。</p></blockquote><h3 id=212-三色标记法>2.1.2 三色标记法
<a class=anchor href=#212-%e4%b8%89%e8%89%b2%e6%a0%87%e8%ae%b0%e6%b3%95>#</a></h3><p>全局数据区与栈区的指针是堆内存访问的起点, 所以把它们放入一个待扫描队列（工作队列）,通过它们可以发现堆上第一批可达数据,发现的可达数据中有指针的加入待扫描队列（灰色节点）扫描完的标为黑色，离开队列,通过扫描灰色节点会发现更多灰色节点，也会产生更多黑色点节点,直到没有待扫描的灰色节点,我们就找到了所有可达数据（黑色节点）,剩下的白色节点就是不可达数据不可达自然用不到,也即是可以进行释放。</p><ul><li>黑色：当基于当前节点的追踪任务完成后，表示为存活数据，后续无需再追踪。</li><li>灰色：基于当前节点展开的追踪还未完成。</li><li>白色：当追踪完成后，代表可回收的对象。</li></ul><p>问题：黑色对象如果指向白色对象,会导致白色对象被错误回收。</p><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240622204628.png width=50% height=50% alt=效果图></p><p>原因：
并发执行,如果将白色对象写入黑色对象,同时没有其它未扫描的路径,可抵达该白色对象,它就不会被扫描携程发现,继而被误判为垃圾。</p><blockquote><p>当gc使用三色标记法与用户程序并发执行的时候，可能让黑色对象重新引用了白色对象，且无其他灰色对象引用了这个白色对象。导致白色对象错误回收。(用户程序和垃圾收集器可以在交替工作的)</p></blockquote><p>处理措施：</p><p>有两种方法来避免:</p><ul><li>强三色：黑色对象只能引用灰色对象。</li><li>弱三色：所有被黑色对象引用的白色对象都处于灰色保护状态.</li></ul><p>引入写屏障：就是在执行写操作时，额外做些标记工作(把数据对象的修改通知到垃圾回收器)，避免垃圾误判。</p><p>分为两种，一种是插入写屏障，一种是删除写屏障。</p><ol><li>插入写屏障</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>writePointer</span>(<span style=color:#a6e22e>slot</span>, <span style=color:#a6e22e>ptr</span>): <span style=color:#75715e>// ⚠️:slot现在指向的还是旧对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  	<span style=color:#a6e22e>shade</span>(<span style=color:#a6e22e>ptr</span>) <span style=color:#75715e>//shade函数尝试改变指针的颜色--&gt;改变ptr的颜色
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   	<span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span> = <span style=color:#a6e22e>ptr</span>
</span></span></code></pre></div><ol start=2><li>删除写屏障： 会在老对象的引用被删除时，将白色的老对象涂成灰色。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>writePointer</span>(<span style=color:#a6e22e>slot</span>, <span style=color:#a6e22e>ptr</span>) <span style=color:#75715e>// ⚠️:slot现在指向的还是旧对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> 	<span style=color:#a6e22e>shade</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span>) <span style=color:#75715e>//shade函数尝试改变指针的颜色--&gt;改变(*slot)的颜色---&gt;注意这个是*slot(旧对象),slot保存着它原先的保存的地址。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> 	<span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span> = <span style=color:#a6e22e>ptr</span>
</span></span></code></pre></div><blockquote><p>引入新问题：只有插入写屏障，但是这需要对所有堆、栈的写操作都开启写屏障，程序性能会受到影响，代价太大。为了改善这个问题，改为<strong>忽略协程栈</strong>上的写屏障，只在标记结束阶段重新扫描那些被激活的栈帧。但是Go语言通常会有大量活跃的协程，这就导致第二次STW时重新扫描协程栈的时间太长。</p></blockquote><ol start=3><li>混合写屏障</li></ol><p>把指向的旧对象标记成灰色; 如果当前正在标记的goroutine栈没有完成标记完（标记完，它栈上的对象应该都是黑色的，如果还未有开始当时goroutine栈标记，它的栈应该还是灰色的）则将新对象也标记成灰色。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span> <span style=color:#a6e22e>writePointer</span>(<span style=color:#a6e22e>slot</span>, <span style=color:#a6e22e>ptr</span>): <span style=color:#75715e>// ⚠️:slot现在指向的还是旧的对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>     <span style=color:#a6e22e>shade</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span>) <span style=color:#75715e>//旧对象标记为灰色。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>     <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>current</span> <span style=color:#a6e22e>stack</span> <span style=color:#a6e22e>is</span> <span style=color:#a6e22e>grey</span>: <span style=color:#75715e>// The insertion part of the barrier is necessary while the calling goroutine&#39;s stack is grey.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         <span style=color:#a6e22e>shade</span>(<span style=color:#a6e22e>ptr</span>)
</span></span><span style=display:flex><span>     <span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span> = <span style=color:#a6e22e>ptr</span>
</span></span></code></pre></div><ul><li><code>shade(*slot)</code>主要是防止用户程序把只有堆上唯一指向的*slot转移到通过栈来唯一指向，从而导致错误回收。</li></ul><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240707161156.png width=50% height=50% alt=效果图></p><ul><li><code>shade(ptr)</code>主要是防止用户程序把只有栈上唯一指向的ptr转移到通过堆来唯一指向，从而导致错误回收。</li></ul><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240707160348.png width=50% height=50% alt=效果图></p><ul><li><code>shade(ptr)</code>通过将对象从栈移动到堆来防止隐藏对象，但这需要首先在栈上隐藏一个指针。在堆栈被扫描后，它只指向灰色对象，所以它不会隐藏任何东西。故只有<code>if current stack is grey</code>的才进行<code>shade(ptr)</code></li></ul><p>既可<strong>忽略当前栈帧的写屏障</strong>，(不管是插入写屏障，还是删除写屏障)又不需要在第二次STW的时，重新扫描所有活跃G的栈帧。</p><h1 id=3-golang垃圾回收>3 golang垃圾回收
<a class=anchor href=#3-golang%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6>#</a></h1><h2 id=31-三色标记法>3.1 三色标记法
<a class=anchor href=#31-%e4%b8%89%e8%89%b2%e6%a0%87%e8%ae%b0%e6%b3%95>#</a></h2><p>在golang内存分配器一章中已讲述如何根据内存地址找到对象的所有管理单元以及重要的标志位，在heapArena中就有gc会用到的标志位：</p><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240727211054.png width=80% height=80% alt=效果图></p><table><thead><tr><th>颜色</th><th>含义</th><th>golang具体表示</th></tr></thead><tbody><tr><td>白色</td><td>代表未标记也未扫描的对象</td><td>白色对象就是那些<code>gcMarkBits</code>中标记为0的对象。</td></tr><tr><td>灰色</td><td>表示已标记但未进行扫描的对象</td><td>着为灰色对应的操作就是把指针对应的<code>gcmarkBits</code>标记位置为1并<strong>加入工作队列</strong></td></tr><tr><td>黑色</td><td>表示已标记但已扫描的对象</td><td>着为黑色对应的操作就是移出工作队列，并把指针对应的<code>gcmarkBits</code>标记位置为<code>1</code></td></tr></tbody></table><p>这里的工作队列，指的是实现了灰色对象指针的生产者-消费者模型的缓冲队列。</p><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240727193809.png width=50% height=50% alt=效果图></p><p>gcWork数据结构源代码如下所示:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>gcWork</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>wbuf1</span>, <span style=color:#a6e22e>wbuf2</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>workbuf</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>workbuf</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>workbufhdr</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// obj是uintptr数组，用来存储扫描过程中发现的指针。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>obj</span> [(<span style=color:#a6e22e>_WorkbufSize</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Sizeof</span>(<span style=color:#a6e22e>workbufhdr</span>{})) <span style=color:#f92672>/</span> <span style=color:#a6e22e>goarch</span>.<span style=color:#a6e22e>PtrSize</span>]<span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>_WorkbufSize</span> = <span style=color:#ae81ff>2048</span> <span style=color:#75715e>// 数组obj的容量为253。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>workbufhdr</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>node</span> <span style=color:#a6e22e>lfnode</span> 
</span></span><span style=display:flex><span>      <span style=color:#75715e>// nobj记录obj数组已使用的个数；当nobj==0表示缓存区为空，当nobj==缓存区长度时表示已满。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>nobj</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>lfnode</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>next</span>    <span style=color:#66d9ef>uint64</span>
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>pushcnt</span> <span style=color:#66d9ef>uint</span>
</span></span><span style=display:flex><span>            }
</span></span></code></pre></div><p>队列有了，下面来看对象置灰操作，主要是greyobject方法中，置灰分三步：</p><ol><li>将mspan.gcmarkBits对应bit位置为1</li><li>将heapArena.pageMarks对应bit位置为1</li><li>将对象添加到灰色对象缓存队列</li></ol><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240727211054.png width=80% height=80% alt=效果图></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>greyobject</span>(<span style=color:#a6e22e>obj</span>, <span style=color:#a6e22e>base</span>, <span style=color:#a6e22e>off</span> <span style=color:#66d9ef>uintptr</span>, <span style=color:#a6e22e>span</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span>, <span style=color:#a6e22e>gcw</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gcWork</span>, <span style=color:#a6e22e>objIndex</span> <span style=color:#66d9ef>uintptr</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mbits</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>markBitsForIndex</span>(<span style=color:#a6e22e>objIndex</span>)
</span></span><span style=display:flex><span>  <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// If marked we have nothing to do.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>mbits</span>.<span style=color:#a6e22e>isMarked</span>() {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 在其所属的 mspan 中，将对应位置的 gcMark bitmap 位置为 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>mbits</span>.<span style=color:#a6e22e>setMarked</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Mark span.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>arena</span>, <span style=color:#a6e22e>pageIdx</span>, <span style=color:#a6e22e>pageMask</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>pageIndexOf</span>(<span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>base</span>())
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>arena</span>.<span style=color:#a6e22e>pageMarks</span>[<span style=color:#a6e22e>pageIdx</span>]<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>pageMask</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Or8</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>arena</span>.<span style=color:#a6e22e>pageMarks</span>[<span style=color:#a6e22e>pageIdx</span>], <span style=color:#a6e22e>pageMask</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// If this is a noscan object, fast-track it to black nstead of greying it.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>spanclass</span>.<span style=color:#a6e22e>noscan</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>gcw</span>.<span style=color:#a6e22e>bytesMarked</span> <span style=color:#f92672>+=</span> uint64(<span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>elemsize</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>  <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Queue the obj for scanning.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 将对象添加到当前 p 的本地队列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>gcw</span>.<span style=color:#a6e22e>putFast</span>(<span style=color:#a6e22e>obj</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>gcw</span>.<span style=color:#a6e22e>put</span>(<span style=color:#a6e22e>obj</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=32-总体流程>3.2 总体流程
<a class=anchor href=#32-%e6%80%bb%e4%bd%93%e6%b5%81%e7%a8%8b>#</a></h2><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240727185445.png width=70% height=70% alt=效果图></p><p>全局变量</p><ul><li>runtime.gcphase 是垃圾收集器当前处于的阶段，可能处于 _GCoff、_GCmark 和 _GCmarktermination，Goroutine 在读取或者修改该阶段时需要保证原子性；</li><li>runtime.gcBlackenEnabled 是一个布尔值，当垃圾收集处于标记阶段时，该变量会被置为 1，在这里辅助垃圾收集的用户程序和后台标记的任务可以将对象涂黑；</li><li>runtime.writeBarrier 是一个包含写屏障状态的结构体，其中的 enabled 字段表示写屏障的开启与关闭；</li><li>runtime.worldsema 是全局的信号量，获取该信号量的线程有权利暂停当前应用程序；</li></ul><h3 id=321-第一次stw>3.2.1 第一次STW
<a class=anchor href=#321-%e7%ac%ac%e4%b8%80%e6%ac%a1stw>#</a></h3><p>垃圾收集在启动过程一定会调用<code>runtime.gcStart</code>函数，主要在标记工作之前做一些准备工作，其工作阶段对应垃圾回收总体流程的<strong>第一次STW</strong>。我们根据这个函数流程图来介绍该函数的实现：</p><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240803150624.png width=30% height=30% alt=效果图></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gcStart</span>(<span style=color:#a6e22e>trigger</span> <span style=color:#a6e22e>gcTrigger</span>) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>//并发地处理剩余的未清扫/正在清扫的span(完成上一个垃圾收集的收尾工作)。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>     <span style=color:#75715e>// 如果我们是在后台模式下调用的，这种情况不应该发生，因为比例清扫应该刚刚完成了所有清扫工作，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>     <span style=color:#75715e>// 但四舍五入误差等可能会留下一些未清扫的 span。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>     <span style=color:#75715e>// 在强制模式下，这是必要的，因为GC可以在清扫周期的任何点被强制触发。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>trigger</span>.<span style=color:#a6e22e>test</span>() <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>sweepone</span>() <span style=color:#f92672>!=</span> ^uintptr(<span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sweep</span>.<span style=color:#a6e22e>nbgsweep</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>//加锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>semacquire</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>worldsema</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//启动与P的个数相同的标记协程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>gcBgMarkStartWorkers</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>//1.切换到g0后执行Stop the world操作
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>systemstack</span>(<span style=color:#a6e22e>stopTheWorldWithSema</span>)
</span></span><span style=display:flex><span>  <span style=color:#75715e>//2.在我们开始并发扫描之前完成清扫。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>systemstack</span>(<span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>finishsweep_m</span>()
</span></span><span style=display:flex><span>  })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//3.限制标记协程占用CPU时间片的比例为趋近25%
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>gcController</span>.<span style=color:#a6e22e>startCycle</span>(<span style=color:#a6e22e>now</span>, int(<span style=color:#a6e22e>gomaxprocs</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//4.进入并发标记阶段并启用写屏障。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>setGCPhase</span>(<span style=color:#a6e22e>_GCmark</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//5.标记所有活动的tinyalloc块。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//因为我们正在从这些块中分配内存，所以它们需要像其他分配一样被标记为黑色。另一种选择是在每次从tiny块分配时将其变黑，这会减慢tiny分配器的速度。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>gcMarkTinyAllocs</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Store</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>gcBlackenEnabled</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//6.切换至g0，重新start the world
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>systemstack</span>(<span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>now</span> = <span style=color:#a6e22e>startTheWorldWithSema</span>(<span style=color:#a6e22e>trace</span>.<span style=color:#a6e22e>enabled</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  })
</span></span><span style=display:flex><span>  <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>semrelease</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>worldsema</span>)
</span></span><span style=display:flex><span>  <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h4 id=预先生成标记协程>预先生成标记协程
<a class=anchor href=#%e9%a2%84%e5%85%88%e7%94%9f%e6%88%90%e6%a0%87%e8%ae%b0%e5%8d%8f%e7%a8%8b>#</a></h4><p>gcBgMarkStartWorkers预先生成标记协程（数量对应于P的个数）</p><blockquote><p>其中通过 notesleepg与notewake的机制，使得for循环与gcBgMarkWorker内部形成联动节奏，主要是为了缩短当进入标记阶段后，标记携程可开始标记的时间间隔.</p><blockquote><p>note是go runtime实现的一次性睡眠和唤醒机制，一个线程可以通过调用<code>notesleep(*note)</code>进入睡眠状态，而另外一个线程则可以通过<code>notewakeup(*note)</code>把其唤醒。</p></blockquote></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gcBgMarkStartWorkers</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>gcBgMarkWorkerCount</span> &lt; <span style=color:#a6e22e>gomaxprocs</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>gcBgMarkWorker</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>notetsleepg</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>work</span>.<span style=color:#a6e22e>bgMarkReady</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>noteclear</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>work</span>.<span style=color:#a6e22e>bgMarkReady</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>gcBgMarkWorkerCount</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>gcBgMarkWorker方法中将g包装成一个node天添加到全局的gcBgMarkWorkerPool中，并调用 gopark 方法将当前g挂起，等待被唤醒.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gcBgMarkWorker</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> new(<span style=color:#a6e22e>gcBgMarkWorkerNode</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>preemptoff</span> = <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>gp</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>acquirem</span>())
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 唤醒外部的 for 循环
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>notewakeup</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>work</span>.<span style=color:#a6e22e>bgMarkReady</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 当前 g 阻塞至此，直到 gcController.findRunnableGCWorker 方法被调用，会将当前 g 唤醒
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>gopark</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>g</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>nodep</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>gcBgMarkWorkerNode</span>)(<span style=color:#a6e22e>nodep</span>)
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 将当前 g 包装成一个 node 添加到 gcBgMarkWorkerPool 中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>gcBgMarkWorkerPool</span>.<span style=color:#a6e22e>push</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>node</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>        }, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>node</span>), <span style=color:#a6e22e>waitReasonGCWorkerIdle</span>, <span style=color:#a6e22e>traceEvGoBlock</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=控制标记协程的cpu利用率>控制标记协程的CPU利用率
<a class=anchor href=#%e6%8e%a7%e5%88%b6%e6%a0%87%e8%ae%b0%e5%8d%8f%e7%a8%8b%e7%9a%84cpu%e5%88%a9%e7%94%a8%e7%8e%87>#</a></h4><p>GC默认的CPU目标使用率为25%，在初始化阶段，根据<code>gomaxprocs*0.25%</code>得出需要启动的标记协程个数，而这有时不为整数，所以需要进行四舍五入(+0.5，然后转化为整形)，但是这样的取整会和原目标产生误差，而误差大于0.3时就比较明显了。</p><blockquote><p><code>9*25%=2.25</code>然后再<code>+0.5</code>取整，等于<code>3</code></p><blockquote><p>误差为：<code>3/2.25-1=1/3=0.3333333333333</code></p></blockquote></blockquote><p>所以，GC把标记协程分成了以下几种工作模式:</p><ul><li>gcMarkWorkerDedicatedMode：专用标记模式。&ldquo;不会"被调度器抢占<ul><li>会先以可被抢占的模式尝试执行，倘若真的被用户协程抢占，再将标记模式改为不可抢占模式. (减少当前P下用户协程的等待时长，提高用户体验.)</li></ul></li><li>gcMarkWorkerFractionalMode：分时标记模式. 当标记协程执行时长达到一定比例后，可以被抢占</li><li>gcMarkWorkerIdleMode: 空闲模式. 随时可以被抢占</li></ul><p>记录在对应的P结构中，作为它的标记协程的工作模式。</p><p><code>startCycle</code>会根据全局处理器的个数以及垃圾收集的 CPU 利用率计算出 dedicatedMarkWorkersNeeded 和 fractionalUtilizationGoal 以决定不同模式的工作协程的数量。</p><p>还是以上面的例子来说明，fractionalUtilizationGoal等于<code>(2.25-2)/procs的个数</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gcControllerState</span>) <span style=color:#a6e22e>startCycle</span>(<span style=color:#a6e22e>markStartTime</span> <span style=color:#66d9ef>int64</span>, <span style=color:#a6e22e>procs</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 计算后台标记利用率目标。总的来说，这可能不会完全准确。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 我们四舍五入专用工作线程的数量(+0.5，然后强转换为整形)，使利用率尽可能接近 25%。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 对于小的 GOMAXPROCS，这会引入太多误差，因此在这种情况下我们添加分数工作线程。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>totalUtilizationGoal</span> <span style=color:#f92672>:=</span> float64(<span style=color:#a6e22e>procs</span>) <span style=color:#f92672>*</span> <span style=color:#a6e22e>gcBackgroundUtilization</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dedicatedMarkWorkersNeeded</span> = int64(<span style=color:#a6e22e>totalUtilizationGoal</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>utilError</span> <span style=color:#f92672>:=</span> float64(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dedicatedMarkWorkersNeeded</span>)<span style=color:#f92672>/</span><span style=color:#a6e22e>totalUtilizationGoal</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>maxUtilError</span> = <span style=color:#ae81ff>0.3</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>utilError</span> &lt; <span style=color:#f92672>-</span><span style=color:#a6e22e>maxUtilError</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>utilError</span> &gt; <span style=color:#a6e22e>maxUtilError</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 四舍五入使我们偏离目标超过 30%。对于 gcBackgroundUtilization 为 25%，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 这发生在 GOMAXPROCS&lt;=3 或 GOMAXPROCS=6 时。启用分数工作线程进行补偿。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> float64(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dedicatedMarkWorkersNeeded</span>) &gt; <span style=color:#a6e22e>totalUtilizationGoal</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 专用工作线程太多。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dedicatedMarkWorkersNeeded</span><span style=color:#f92672>--</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 计算出每个 P 需要额外执行标记任务的时间片比例
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>fractionalUtilizationGoal</span> = (<span style=color:#a6e22e>totalUtilizationGoal</span> <span style=color:#f92672>-</span> float64(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dedicatedMarkWorkersNeeded</span>)) <span style=color:#f92672>/</span> float64(<span style=color:#a6e22e>procs</span>)
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>fractionalUtilizationGoal</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>P会记录自己累计执行Fractional worker的时间，</p><pre tabindex=0><code>type P struct {
    //...
    gcFractionalMarkTime int64 // Nanoseconds in fractional mark worker (atomic)

    // gcMarkWorkerMode 是下一个标记工作线程运行的模式。
    // 也就是说，这用于与由 gcController.findRunnableGCWorker 选定用于立即执行的工作 Goroutine 进行通信。
    // 当调度其他 Goroutine 时，这个字段必须设置为 gcMarkWorkerNotWorker。
    gcMarkWorkerMode gcMarkWorkerMode

    // gcMarkWorkerStartTime 是最近一次标记工作线程开始运行的 nanotime() 时间。
    gcMarkWorkerStartTime int64
    //...
}
</code></pre><p>同时全局的gcControllerState会记录后台标记工作线程开始时间。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>gcControllerState</span> <span style=color:#66d9ef>struct</span>{
</span></span><span style=display:flex><span>  <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// markStartTime 是后台标记工作线程开始的绝对时间，以纳秒为单位。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>markStartTime</span> <span style=color:#66d9ef>int64</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>通过检查当前P累计在fractionalt模式下的工作时间与本轮GC已经执行的时间比值，跟<code>fractionalUtilizationGoal</code>相比较就能知道当前标记协程是否可以退出了。</p><h5 id=heading><a class=anchor href=#heading>#</a></h5><h3 id=322-标记阶段>3.2.2 标记阶段
<a class=anchor href=#322-%e6%a0%87%e8%ae%b0%e9%98%b6%e6%ae%b5>#</a></h3><h3 id=323-第二次stw>3.2.3 第二次STW
<a class=anchor href=#323-%e7%ac%ac%e4%ba%8c%e6%ac%a1stw>#</a></h3><h3 id=324-清扫阶段>3.2.4 清扫阶段
<a class=anchor href=#324-%e6%b8%85%e6%89%ab%e9%98%b6%e6%ae%b5>#</a></h3><h3 id=xx>xx
<a class=anchor href=#xx>#</a></h3><ul><li>gc开始：<ul><li>将所有的对象设置为<strong>白色</strong></li></ul></li><li>扫描阶段（scan）<ul><li>把全局变量和goroutine栈上的指针对象，标记为<strong>灰色</strong>, 而且收集起来（比如放入一个先入先出队列中）</li></ul></li><li>标记阶段(mark)<ul><li>从队列中弹出一个<strong>灰色</strong>指针对象</li><li>访问这个<strong>灰色</strong>对象所指向的对象，如果此对象是<strong>白色</strong>，则将它转变为<strong>灰色</strong>，并加入到队列中</li><li>将这个<strong>灰色</strong>对象标记为黑色，表示访问完毕</li><li>重复上述过程，直到队列为空(没有灰色对象了)</li></ul></li><li>清扫阶段(sweep)<ul><li>剩余的<strong>白色</strong>对象,说明不可达，可进行垃圾回收。</li></ul></li></ul><h2 id=并发标记的分工问题写屏障记录集的竞争问题>并发标记的分工问题？写屏障记录集的竞争问题？
<a class=anchor href=#%e5%b9%b6%e5%8f%91%e6%a0%87%e8%ae%b0%e7%9a%84%e5%88%86%e5%b7%a5%e9%97%ae%e9%a2%98%e5%86%99%e5%b1%8f%e9%9a%9c%e8%ae%b0%e5%bd%95%e9%9b%86%e7%9a%84%e7%ab%9e%e4%ba%89%e9%97%ae%e9%a2%98>#</a></h2><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210121134453.png alt=20210121134453></p><blockquote><p>这里的竞争问题，我怀疑是： 一个是gc从root Object到一直遍历，打标记(从上到下)，同时另一个用户程序也在更新Object的关联（比如从从一个灰色到白色节点断开）</p><blockquote><p>其中用户程序的写到每个P中的写屏障缓冲区。</p></blockquote></blockquote><ul><li>前面提到了全局变量work中存储着全局工作队列缓存（work.full），其实每个P都有<strong>一个本地工作队列（p.gcw）和一个写屏障缓冲（p.wbBuf）</strong>。</li><li>p.gcw中有两个workbuf：wbuf1和wbuf2，添加任务时总是从wbuf1添加，wbuf1满了就交换wbuf1和wbuf2，如果还是满的，就把当前wbuf1的工作flush到全局工作缓存中去。</li></ul><p>知道分工了，不可能占用很多CPU进行gc,这样会限制用户程序。</p><hr><hr><hr><h1 id=fqa>FQA
<a class=anchor href=#fqa>#</a></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>p的个数是固定的吗</span><span style=color:#960050;background-color:#1e0010>，</span><span style=color:#a6e22e>可以比机器CPU个数多吗</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>知道为什么一个gcWorker一个p了</span><span style=color:#960050;background-color:#1e0010>，</span><span style=color:#a6e22e>因为gcWorker不会被抢占</span><span style=color:#960050;background-color:#1e0010>，</span><span style=color:#a6e22e>它会一直占有一个p</span><span style=color:#960050;background-color:#1e0010>?</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>如果有多个P</span><span style=color:#960050;background-color:#1e0010>，</span><span style=color:#a6e22e>那么会不会存在有一个p一直不回被执行的</span><span style=color:#960050;background-color:#1e0010>？</span>
</span></span></code></pre></div><h2 id=为什么gc也要扫描栈不是都在堆上面吗>为什么gc也要扫描栈，不是都在堆上面吗？
<a class=anchor href=#%e4%b8%ba%e4%bb%80%e4%b9%88gc%e4%b9%9f%e8%a6%81%e6%89%ab%e6%8f%8f%e6%a0%88%e4%b8%8d%e6%98%af%e9%83%bd%e5%9c%a8%e5%a0%86%e4%b8%8a%e9%9d%a2%e5%90%97>#</a></h2><p>因为堆上的地址，可能保存在栈上某个变量里，所以需要扫描。</p><h2 id=混合写屏障>混合写屏障
<a class=anchor href=#%e6%b7%b7%e5%90%88%e5%86%99%e5%b1%8f%e9%9a%9c>#</a></h2><p>问：我就是觉得混合写屏障好像也没法 解决重新扫描栈的问题</p><p>现在有 A, B, C三个对象，A(黑色，栈上)，B（灰色，栈上），C（白色，堆上）；
当前引用关系是：</p><pre tabindex=0><code>A（黑） -&gt; nil
B（灰） -&gt; C（白）
</code></pre><p>现在应用程序赋值修改，把A指向C：</p><pre tabindex=0><code>A（黑） -&gt; C（白）
B（灰） -&gt; nil
</code></pre><p>由于A，B是栈上的对象，栈上对象赋值这里可是没有写屏障的；那么岂不是黑色对象指向白色对象了，C会回收了，就悬挂指针了？</p><hr><p>答：Goroutine 栈扫描的过程需要 STW，所以你描述的这种状况是不存在的，<strong>栈上的对象要么全白要么全黑</strong></p><blockquote><ul><li>你说的“栈上的对象要么全白，要么全黑“ ，这个只是对一个 goroutine 栈来说的（golang 暂停业务扫描栈也是一个一个来的）。如果场景是 A 在 Goroutine1，B在Goroutine2呢？这种情况就是A是黑色，B是白色或者灰色。这样会不会就有我说的原本那个问题呢？<ul><li><a href=https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md#channel-operations-and-go-statements>The hybrid barrier assumes a goroutine cannot write to another goroutine&rsquo;s stack.(混合写屏障假设一个goroutine,不能写到另一个goroutine的栈)</a></li></ul></li><li>除了从一个Goroutine通过chan发送/生成一个新Goroutine<ul><li>如果两个Goroutine 栈只要有一个是灰色的，那么就会有<code>shade(ptr)</code></li><li>新生成的Goroutine栈都是黑色的（由前面的条件保证）,如果父Goroutine是灰色的，那么需使用<code>shade(ptr)</code></li></ul></li></ul></blockquote><h2 id=golang中gc支持增量与并发式回收怎么理解>Golang中GC支持增量与并发式回收怎么理解
<a class=anchor href=#golang%e4%b8%adgc%e6%94%af%e6%8c%81%e5%a2%9e%e9%87%8f%e4%b8%8e%e5%b9%b6%e5%8f%91%e5%bc%8f%e5%9b%9e%e6%94%b6%e6%80%8e%e4%b9%88%e7%90%86%e8%a7%a3>#</a></h2><p>增量和并发，一个是横向一个是纵向，gc与mutator交替与运行。</p><ul><li>横向：增量垃圾收集（增量地标记和清除垃圾，降低应用程序暂停的最长时间）</li><li>纵向：并发垃圾收集（利用多核的计算资源，在用户程序执行时并发标记和清除垃圾）<ul><li>因为增量和并发两种方式都可以与用户程序交替运行，所以我们需要使用屏障技术保证垃圾收集的正确性.</li></ul></li></ul><hr><ul><li><p>使用混合写屏障的原因是缩短gc暂停的时间。</p><ul><li>因为栈上使用写屏障，会导致耗时太多。但是如果栈上不使用写屏障，等到第二次STW重新扫描栈空间，goroutine数目多，需要扫描的stack耗时也多。
忽略协程栈的写屏障;其他的使用删除写屏障，插入写屏障。</li></ul></li><li><p>如果没有任何STW的时间，也就是说垃圾回收程序与用户程序完全并发执行，其代价与实现难度可能都会高于短暂的STW。例如标记——清扫回收器中，若完全抛弃STW，那么垃圾回收开始的消息便很难准确及时地通知到所有线程，可能导致<strong>某些线程</strong>开启<strong>写屏障</strong>的动作有所延迟而无法保障双方执行的正确性。</p></li></ul><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210113105703.png alt=gc></p><h2 id=为什么清扫阶段不需要屏障了呢>为什么清扫阶段不需要屏障了呢？
<a class=anchor href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%b8%85%e6%89%ab%e9%98%b6%e6%ae%b5%e4%b8%8d%e9%9c%80%e8%a6%81%e5%b1%8f%e9%9a%9c%e4%ba%86%e5%91%a2>#</a></h2><p>当标记完成了，那么它白色的对象都是不可达的对象，是可以删除的对象，程序不可能再找到已经不可达的对象。所以放心的清除。</p><h4 id=todo-并发gc如何缓解内存分配压力>TODO: 并发GC如何缓解内存分配压力？
<a class=anchor href=#todo-%e5%b9%b6%e5%8f%91gc%e5%a6%82%e4%bd%95%e7%bc%93%e8%a7%a3%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%8e%8b%e5%8a%9b>#</a></h4><ul><li>借贷偿还机制。也可以偷。</li></ul><h1 id=总结>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93>#</a></h1><h2 id=为什么golang需要gc>为什么golang需要GC
<a class=anchor href=#%e4%b8%ba%e4%bb%80%e4%b9%88golang%e9%9c%80%e8%a6%81gc>#</a></h2><blockquote><h3 id=what>what:
<a class=anchor href=#what>#</a></h3></blockquote><ul><li>gc主要是释放那些不再需要的分配在堆（heap）上的数据</li></ul><blockquote><h3 id=why>why:
<a class=anchor href=#why>#</a></h3></blockquote><ul><li>降低人的心智负担，从堆（heap）中申请的内存，不需要手动的释放。</li></ul><blockquote><h3 id=how>how:
<a class=anchor href=#how>#</a></h3></blockquote><ul><li>一般判断对象是否存活是使用：是把可达性近视的认为存活性.<ul><li>可把栈（stack），数据段（data segment? bss?）的数据对象作为root</li></ul></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><script src=https://giscus.app/client.js data-repo=zput/utterances-comments data-repo-id=R_kgDOHhATGQ data-category=Announcements data-category-id=DIC_kwDOHhATGc4CPxca data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=1 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#1-前言变量的存放区>1 前言：变量的存放区</a></li><li><a href=#2-定义>2 定义</a><ul><li><a href=#21-垃圾识别>2.1 垃圾识别</a><ul><li><a href=#211-双色标记法>2.1.1 双色标记法</a></li><li><a href=#212-三色标记法>2.1.2 三色标记法</a></li></ul></li></ul></li><li><a href=#3-golang垃圾回收>3 golang垃圾回收</a><ul><li><a href=#31-三色标记法>3.1 三色标记法</a></li><li><a href=#32-总体流程>3.2 总体流程</a><ul><li><a href=#321-第一次stw>3.2.1 第一次STW</a><ul><li><a href=#预先生成标记协程>预先生成标记协程</a></li><li><a href=#控制标记协程的cpu利用率>控制标记协程的CPU利用率</a></li></ul></li><li><a href=#322-标记阶段>3.2.2 标记阶段</a></li><li><a href=#323-第二次stw>3.2.3 第二次STW</a></li><li><a href=#324-清扫阶段>3.2.4 清扫阶段</a></li><li><a href=#xx>xx</a></li></ul></li><li><a href=#并发标记的分工问题写屏障记录集的竞争问题>并发标记的分工问题？写屏障记录集的竞争问题？</a></li></ul></li><li><a href=#fqa>FQA</a><ul><li><a href=#为什么gc也要扫描栈不是都在堆上面吗>为什么gc也要扫描栈，不是都在堆上面吗？</a></li><li><a href=#混合写屏障>混合写屏障</a></li><li><a href=#golang中gc支持增量与并发式回收怎么理解>Golang中GC支持增量与并发式回收怎么理解</a></li><li><a href=#为什么清扫阶段不需要屏障了呢>为什么清扫阶段不需要屏障了呢？</a><ul><li><ul><li><a href=#todo-并发gc如何缓解内存分配压力>TODO: 并发GC如何缓解内存分配压力？</a></li></ul></li></ul></li></ul></li><li><a href=#总结>总结</a><ul><li><a href=#为什么golang需要gc>为什么golang需要GC</a><ul><li><a href=#what>what:</a></li><li><a href=#why>why:</a></li><li><a href=#how>how:</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html><script type=text/javascript src=https://cdn.bootcss.com/viz.js/1.8.2/viz.js></script><script type=text/javascript>(function(){var e="language-viz-";Array.prototype.forEach.call(document.querySelectorAll("[class^="+e+"]"),function(t){console.log(t),t.getAttribute("class").split(" ").forEach(function(t){t.startsWith(e)&&(s=t.substr(e.length))}),console.log("------------MIDDLE--------");var s,o=Viz(t.innerText,{format:"svg",engine:s}),n=(new DOMParser).parseFromString(o,"image/svg+xml");n.documentElement.setAttribute("style","max-width:100%; max-height:100%;"),t.parentNode.insertBefore(n.documentElement,t),t.style.display="none",t.parentNode.style.backgroundColor="white",t.style.width=n.documentElement.getAttribute("width")+"px",t.style.height=n.documentElement.getAttribute("height")+"px",console.log("--------------END------")})})()</script>