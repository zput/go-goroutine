<!doctype html><html lang=zh dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="1 前言：变量的存放区 # 通常情况下，变量的分配位置一般是下列三个区：
全局数据区 栈区 堆区 全局数据区:主要用于全局变量的分配，也即包级别的变量,其生命周期和进程相同。
栈区:主要存储函数内部定义的本地变量,当函数执行完毕，变量即可释放。函数执行时通过栈帧加偏移来访问这些数据。
堆区:主要用于程序运行阶段的动态分配。
内存中的对象存在着相互的引用关系。全局数据区与栈区可能指同堆上的数据,这两个地方的指针是堆内存访问的起点，也就是堆内存访问的根节点(root)。
2 定义 # 垃圾回收（garbage collect）简称gc,主要是释放那些不再需要的分配在堆（heap）上的数据, 以便再次用来进行内存分配。垃圾回收一般分为两个步骤：垃圾识别和垃圾清理。
golang支持垃圾自动回收，主要是降低人的心智负担，从堆（heap）中申请的内存，不需要手动的释放。其采用三色标记法来识别垃圾对象，并使用清除算法进行垃圾清理。
2.1 垃圾识别 # 2.1.1 双色标记法 # 根节点一般为全局变量、栈中的变量，维护根节点集合是可达性分析的前提。可达性分析是指从根对象开始，遍历其引用的子节点对象，直至遍历完毕。凡是能够触达的对象，都视作有效对象，而无法触达的，则视作垃圾对象。
双色标标记法采用可达性分析来标记对象状态;通过对象的可达性近视的认为存活性。
双色标记法看上去简单易用，但却存在着一个比较大的缺点，即整个标记过程必须一次性完成，中间不能有任何停顿。也就是说，在执行过程中，不能让出CPU时间片给其他线程。对于应用程序来说，可能会出现用户线程完全停顿，直至标记过程结束。
双色标记法只能描述对象节点自身是否扫描，而不能描述子节点是否完成。这导致重启标记开始后，很难抉择该如何继续，如果再次从根节点开始，那就意味着上次所做的工作完全被浪费掉了。因此，双色标记在停顿、再次重启过程中，无法完成状态的自描述。
由于新增对象无法确定置为黑色还是白色，因此导致扫描过程不能停顿。对双色标记而言可将新增对象直接标记为黑色，然后到下轮垃圾回收才将本轮新增对象中的垃圾对象（往往是生命周期很短的对象）清除。
2.1.2 三色标记法 # 全局数据区与栈区的指针是堆内存访问的起点, 所以把它们放入一个待扫描队列（工作队列）,通过它们可以发现堆上第一批可达数据,发现的可达数据中有指针的加入待扫描队列（灰色节点）扫描完的标为黑色，离开队列,通过扫描灰色节点会发现更多灰色节点，也会产生更多黑色点节点,直到没有待扫描的灰色节点,我们就找到了所有可达数据（黑色节点）,剩下的白色节点就是不可达数据不可达自然用不到,也即是可以进行释放。
黑色：当基于当前节点的追踪任务完成后，表示为存活数据，后续无需再追踪。 灰色：基于当前节点展开的追踪还未完成。 白色：当追踪完成后，代表可回收的对象。 问题：黑色对象如果指向白色对象,会导致白色对象被错误回收。
原因： 并发执行,如果将白色对象写入黑色对象,同时没有其它未扫描的路径,可抵达该白色对象,它就不会被扫描携程发现,继而被误判为垃圾。
当gc使用三色标记法与用户程序并发执行的时候，可能让黑色对象重新引用了白色对象，且无其他灰色对象引用了这个白色对象。导致白色对象错误回收。(用户程序和垃圾收集器可以在交替工作的)
处理措施：
有两种方法来避免:
强三色：黑色对象只能引用灰色对象。 弱三色：所有被黑色对象引用的白色对象都处于灰色保护状态. 引入写屏障：就是在执行写操作时，额外做些标记工作(把数据对象的修改通知到垃圾回收器)，避免垃圾误判。
分为两种，一种是插入写屏障，一种是删除写屏障。
插入写屏障 writePointer(slot, ptr): // ⚠️:slot现在指向的还是旧对象 shade(ptr) //shade函数尝试改变指针的颜色-->改变ptr的颜色 *slot = ptr 删除写屏障： 会在老对象的引用被删除时，将白色的老对象涂成灰色。 writePointer(slot, ptr) // ⚠️:slot现在指向的还是旧对象 shade(*slot) //shade函数尝试改变指针的颜色-->改变(*slot)的颜色--->注意这个是*slot(旧对象),slot保存着它原先的保存的地址。 *slot = ptr 引入新问题：只有插入写屏障，但是这需要对所有堆、栈的写操作都开启写屏障，程序性能会受到影响，代价太大。为了改善这个问题，改为忽略协程栈上的写屏障，只在标记结束阶段重新扫描那些被激活的栈帧。但是Go语言通常会有大量活跃的协程，这就导致第二次STW时重新扫描协程栈的时间太长。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://zput.github.io/go-goroutine/docs/runtime/golang_gc/"><meta property="og:site_name" content="go调度源码分析"><meta property="og:title" content="垃圾回收"><meta property="og:description" content="1 前言：变量的存放区 # 通常情况下，变量的分配位置一般是下列三个区：
全局数据区 栈区 堆区 全局数据区:主要用于全局变量的分配，也即包级别的变量,其生命周期和进程相同。
栈区:主要存储函数内部定义的本地变量,当函数执行完毕，变量即可释放。函数执行时通过栈帧加偏移来访问这些数据。
堆区:主要用于程序运行阶段的动态分配。
内存中的对象存在着相互的引用关系。全局数据区与栈区可能指同堆上的数据,这两个地方的指针是堆内存访问的起点，也就是堆内存访问的根节点(root)。
2 定义 # 垃圾回收（garbage collect）简称gc,主要是释放那些不再需要的分配在堆（heap）上的数据, 以便再次用来进行内存分配。垃圾回收一般分为两个步骤：垃圾识别和垃圾清理。
golang支持垃圾自动回收，主要是降低人的心智负担，从堆（heap）中申请的内存，不需要手动的释放。其采用三色标记法来识别垃圾对象，并使用清除算法进行垃圾清理。
2.1 垃圾识别 # 2.1.1 双色标记法 # 根节点一般为全局变量、栈中的变量，维护根节点集合是可达性分析的前提。可达性分析是指从根对象开始，遍历其引用的子节点对象，直至遍历完毕。凡是能够触达的对象，都视作有效对象，而无法触达的，则视作垃圾对象。
双色标标记法采用可达性分析来标记对象状态;通过对象的可达性近视的认为存活性。
双色标记法看上去简单易用，但却存在着一个比较大的缺点，即整个标记过程必须一次性完成，中间不能有任何停顿。也就是说，在执行过程中，不能让出CPU时间片给其他线程。对于应用程序来说，可能会出现用户线程完全停顿，直至标记过程结束。
双色标记法只能描述对象节点自身是否扫描，而不能描述子节点是否完成。这导致重启标记开始后，很难抉择该如何继续，如果再次从根节点开始，那就意味着上次所做的工作完全被浪费掉了。因此，双色标记在停顿、再次重启过程中，无法完成状态的自描述。
由于新增对象无法确定置为黑色还是白色，因此导致扫描过程不能停顿。对双色标记而言可将新增对象直接标记为黑色，然后到下轮垃圾回收才将本轮新增对象中的垃圾对象（往往是生命周期很短的对象）清除。
2.1.2 三色标记法 # 全局数据区与栈区的指针是堆内存访问的起点, 所以把它们放入一个待扫描队列（工作队列）,通过它们可以发现堆上第一批可达数据,发现的可达数据中有指针的加入待扫描队列（灰色节点）扫描完的标为黑色，离开队列,通过扫描灰色节点会发现更多灰色节点，也会产生更多黑色点节点,直到没有待扫描的灰色节点,我们就找到了所有可达数据（黑色节点）,剩下的白色节点就是不可达数据不可达自然用不到,也即是可以进行释放。
黑色：当基于当前节点的追踪任务完成后，表示为存活数据，后续无需再追踪。 灰色：基于当前节点展开的追踪还未完成。 白色：当追踪完成后，代表可回收的对象。 问题：黑色对象如果指向白色对象,会导致白色对象被错误回收。
原因： 并发执行,如果将白色对象写入黑色对象,同时没有其它未扫描的路径,可抵达该白色对象,它就不会被扫描携程发现,继而被误判为垃圾。
当gc使用三色标记法与用户程序并发执行的时候，可能让黑色对象重新引用了白色对象，且无其他灰色对象引用了这个白色对象。导致白色对象错误回收。(用户程序和垃圾收集器可以在交替工作的)
处理措施：
有两种方法来避免:
强三色：黑色对象只能引用灰色对象。 弱三色：所有被黑色对象引用的白色对象都处于灰色保护状态. 引入写屏障：就是在执行写操作时，额外做些标记工作(把数据对象的修改通知到垃圾回收器)，避免垃圾误判。
分为两种，一种是插入写屏障，一种是删除写屏障。
插入写屏障 writePointer(slot, ptr): // ⚠️:slot现在指向的还是旧对象 shade(ptr) //shade函数尝试改变指针的颜色-->改变ptr的颜色 *slot = ptr 删除写屏障： 会在老对象的引用被删除时，将白色的老对象涂成灰色。 writePointer(slot, ptr) // ⚠️:slot现在指向的还是旧对象 shade(*slot) //shade函数尝试改变指针的颜色-->改变(*slot)的颜色--->注意这个是*slot(旧对象),slot保存着它原先的保存的地址。 *slot = ptr 引入新问题：只有插入写屏障，但是这需要对所有堆、栈的写操作都开启写屏障，程序性能会受到影响，代价太大。为了改善这个问题，改为忽略协程栈上的写屏障，只在标记结束阶段重新扫描那些被激活的栈帧。但是Go语言通常会有大量活跃的协程，这就导致第二次STW时重新扫描协程栈的时间太长。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>垃圾回收 | go调度源码分析</title>
<link rel=manifest href=/go-goroutine/manifest.json><link rel=icon href=/go-goroutine/favicon.png><link rel=stylesheet href=/go-goroutine/book.min.a7d3a43391e1f7eb43ae94bcae6354b739c49cba56473620924ec707afe0864d.css integrity="sha256-p9OkM5Hh9+tDrpS8rmNUtznEnLpWRzYgkk7HB6/ghk0=" crossorigin=anonymous><script defer src=/go-goroutine/flexsearch.min.js></script><script defer src=/go-goroutine/en.search.min.61341c710fd47b317fb5a30d5c006fd7e6326c759b9af9d0a5e94822232f64a1.js integrity="sha256-YTQccQ/UezF/taMNXABv1+YybHWbmvnQpelIIiMvZKE=" crossorigin=anonymous></script><script defer src=/go-goroutine/sw.min.ec96d6e09af3075a94dd4de723a2edddf2ef138381c7e1e5b5a1f2c0578ee8bd.js integrity="sha256-7JbW4JrzB1qU3U3nI6Lt3fLvE4OBx+HltaHywFeO6L0=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/go-goroutine/><span>go调度源码分析</span></a></h2><div class=magic><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><div class=book-switch><label class=switch><input id=dark-mode-checkbox type=checkbox onchange=darkmode()>
<span class=slider></span></label></div></div><ul><li><a href=https://zput.github.io target=_blank rel=noopener>Zput博客</a></li><li><a href=https://github.com/zput target=_blank rel=noopener>GitHub</a></li></ul><hr><ul><li><span>基础知识</span><ul><li><a href=/go-goroutine/docs/foundation/golang_basic/>基本用法</a></li><li><a href=/go-goroutine/docs/foundation/slice/>slice</a></li><li><a href=/go-goroutine/docs/foundation/map/>map</a></li><li><a href=/go-goroutine/docs/foundation/sort/>sort</a></li><li><a href=/go-goroutine/docs/foundation/directory/>Directory</a></li></ul></li><li><span>鲁棒和性能</span><ul><li><a href=/go-goroutine/docs/robustness_and_performance/golang_test/>测试相关函数</a></li></ul></li><li><span>运行时</span><ul><li><a href=/go-goroutine/docs/runtime/golang_gmp/>GMP</a></li><li><span>堆分配原理</span><ul><li><a href=/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/1_summarize/>概述</a></li><li><a href=/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_big_object/>分配大对象</a></li><li><a href=/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_middle_object/>概述</a></li><li><a href=/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_small_object/>概述</a></li></ul></li><li><a href=/go-goroutine/docs/runtime/complement-source-reverse/>源码-反码-补码</a></li><li><a href=/go-goroutine/docs/runtime/golang_memery/>内存分配器</a></li><li><a href=/go-goroutine/docs/runtime/golang_gc/ class=active>垃圾回收</a></li><li><a href=/go-goroutine/docs/runtime/schedule/>调度</a><ul><li><span>前置知识</span><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/memory/>内存大小端</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/register_functionstack/>伪寄存器与函数栈帧</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/similar_assemble/>类汇编</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/go_underlying_struct/>底层重要结构</a></li></ul></li><li><a href=/go-goroutine/docs/runtime/schedule/2_init_before_enter_main_function/>初始化</a></li><li><a href=/go-goroutine/docs/runtime/schedule/3_exit_goroutine/>退出</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/>调度挑选策略</a><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/take_goroutine_from_globalorlocal_p/>从全局/本P队列</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/steal_goroutine_from_other_p/>从其他P队列</a></li></ul></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/>调度到达时机</a><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/active_scheduling/>主动调度</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/passive_scheduling/>被动调度</a></li><li><input type=checkbox id=section-740657f38f0c4de9a986bda642ff0388 class=toggle>
<label for=section-740657f38f0c4de9a986bda642ff0388 class="flex justify-between"><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/>剥夺调度</a></label><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/start_sysmon/>开启系统监控</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/user_code_preemption/>代码执行过久</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/system_call_preemption/>陷入系统调用</a></li></ul></li></ul></li></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script><script src=/go-goroutine/magic.js></script><script src=/go-goroutine/dark.js></script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/go-goroutine/svg/menu.svg class=book-icon alt=Menu>
</label><strong>垃圾回收</strong>
<label for=toc-control><img src=/go-goroutine/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#1-前言变量的存放区>1 前言：变量的存放区</a></li><li><a href=#2-定义>2 定义</a><ul><li><a href=#21-垃圾识别>2.1 垃圾识别</a><ul><li><a href=#211-双色标记法>2.1.1 双色标记法</a></li><li><a href=#212-三色标记法>2.1.2 三色标记法</a></li></ul></li></ul></li><li><a href=#3-golang垃圾回收>3 golang垃圾回收</a><ul><li><a href=#31-三色标记法>3.1 三色标记法</a></li><li><a href=#32-总体流程>3.2 总体流程</a><ul><li><a href=#321-第一次stw>3.2.1 第一次STW</a><ul><li><a href=#预生成标记协程>预生成标记协程</a></li><li><a href=#控制标记协程的cpu利用率>控制标记协程的CPU利用率</a></li></ul></li><li><a href=#322-标记阶段>3.2.2 标记阶段</a><ul><li><a href=#调度标记协程>调度标记协程</a></li><li><a href=#标记协程>标记协程</a></li><li><a href=#3221-中止标记协程>3.2.2.1 中止标记协程</a></li><li><a href=#3221-扫描根对象>3.2.2.1 扫描根对象</a></li><li><a href=#3223-标记堆对象>3.2.2.3 标记堆对象</a></li><li><a href=#置黑新分配对象>置黑新分配对象</a></li><li><a href=#辅助标记>辅助标记</a></li></ul></li><li><a href=#323-第二次stw>3.2.3 第二次STW</a><ul><li><a href=#标记终止>标记终止</a></li><li><a href=#3231唤醒清扫协程>3.2.3.1.唤醒清扫协程</a></li><li><a href=#3231-清扫工作>3.2.3.1. 清扫工作</a></li></ul></li><li><a href=#324-清扫阶段>3.2.4 清扫阶段</a></li><li><a href=#xx>xx</a></li></ul></li><li><a href=#并发标记的分工问题写屏障记录集的竞争问题>并发标记的分工问题？写屏障记录集的竞争问题？</a></li></ul></li><li><a href=#fqa>FQA</a><ul><li><a href=#为什么gc也要扫描栈不是都在堆上面吗>为什么gc也要扫描栈，不是都在堆上面吗？</a></li><li><a href=#混合写屏障>混合写屏障</a></li><li><a href=#golang中gc支持增量与并发式回收怎么理解>Golang中GC支持增量与并发式回收怎么理解</a></li><li><a href=#为什么清扫阶段不需要屏障了呢>为什么清扫阶段不需要屏障了呢？</a><ul><li><ul><li><a href=#todo-并发gc如何缓解内存分配压力>TODO: 并发GC如何缓解内存分配压力？</a></li></ul></li></ul></li></ul></li><li><a href=#总结>总结</a><ul><li><a href=#为什么golang需要gc>为什么golang需要GC</a><ul><li><a href=#what>what:</a></li><li><a href=#why>why:</a></li><li><a href=#how>how:</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=1-前言变量的存放区>1 前言：变量的存放区
<a class=anchor href=#1-%e5%89%8d%e8%a8%80%e5%8f%98%e9%87%8f%e7%9a%84%e5%ad%98%e6%94%be%e5%8c%ba>#</a></h1><p>通常情况下，变量的分配位置一般是下列三个区：</p><ol><li>全局数据区</li><li>栈区</li><li>堆区</li></ol><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240622185210.png width=70% height=70% alt=效果图></p><p>全局数据区:主要用于全局变量的分配，也即包级别的变量,其生命周期和进程相同。</p><p>栈区:主要存储函数内部定义的本地变量,当函数执行完毕，变量即可释放。函数执行时通过栈帧加偏移来访问这些数据。</p><p>堆区:主要用于程序运行阶段的动态分配。</p><p>内存中的对象存在着相互的引用关系。全局数据区与栈区可能指同堆上的数据,这两个地方的指针是堆内存访问的起点，也就是堆内存访问的根节点(root)。</p><h1 id=2-定义>2 定义
<a class=anchor href=#2-%e5%ae%9a%e4%b9%89>#</a></h1><p>垃圾回收（garbage collect）简称gc,主要是释放那些不再需要的分配在堆（heap）上的数据, 以便再次用来进行内存分配。垃圾回收一般分为两个步骤：<strong>垃圾识别</strong>和<strong>垃圾清理</strong>。</p><p>golang支持垃圾自动回收，主要是降低人的心智负担，从堆（heap）中申请的内存，不需要手动的释放。其采用三色标记法来识别垃圾对象，并使用清除算法进行垃圾清理。</p><h2 id=21-垃圾识别>2.1 垃圾识别
<a class=anchor href=#21-%e5%9e%83%e5%9c%be%e8%af%86%e5%88%ab>#</a></h2><h3 id=211-双色标记法>2.1.1 双色标记法
<a class=anchor href=#211-%e5%8f%8c%e8%89%b2%e6%a0%87%e8%ae%b0%e6%b3%95>#</a></h3><p>根节点一般为全局变量、栈中的变量，维护根节点集合是可达性分析的前提。可达性分析是指从根对象开始，遍历其引用的子节点对象，直至遍历完毕。凡是能够触达的对象，都视作有效对象，而无法触达的，则视作垃圾对象。</p><p>双色标标记法采用可达性分析来标记对象状态;通过对象的可达性近视的认为存活性。</p><p>双色标记法看上去简单易用，但却存在着一个比较大的缺点，即整个标记过程必须一次性完成，中间不能有任何停顿。也就是说，在执行过程中，不能让出CPU时间片给其他线程。对于应用程序来说，可能会出现用户线程完全停顿，直至标记过程结束。</p><p>双色标记法只能描述对象节点自身是否扫描，<strong>而不能描述子节点是否完成</strong>。这导致重启标记开始后，很难抉择该如何继续，如果再次从根节点开始，那就意味着上次所做的工作完全被浪费掉了。因此，双色标记在停顿、再次重启过程中，无法完成状态的自描述。</p><blockquote><p>由于新增对象无法确定置为黑色还是白色，因此导致扫描过程不能停顿。对双色标记而言可将新增对象直接标记为黑色，然后到下轮垃圾回收才将本轮新增对象中的垃圾对象（往往是生命周期很短的对象）清除。</p></blockquote><h3 id=212-三色标记法>2.1.2 三色标记法
<a class=anchor href=#212-%e4%b8%89%e8%89%b2%e6%a0%87%e8%ae%b0%e6%b3%95>#</a></h3><p>全局数据区与栈区的指针是堆内存访问的起点, 所以把它们放入一个待扫描队列（工作队列）,通过它们可以发现堆上第一批可达数据,发现的可达数据中有指针的加入待扫描队列（灰色节点）扫描完的标为黑色，离开队列,通过扫描灰色节点会发现更多灰色节点，也会产生更多黑色点节点,直到没有待扫描的灰色节点,我们就找到了所有可达数据（黑色节点）,剩下的白色节点就是不可达数据不可达自然用不到,也即是可以进行释放。</p><ul><li>黑色：当基于当前节点的追踪任务完成后，表示为存活数据，后续无需再追踪。</li><li>灰色：基于当前节点展开的追踪还未完成。</li><li>白色：当追踪完成后，代表可回收的对象。</li></ul><p>问题：黑色对象如果指向白色对象,会导致白色对象被错误回收。</p><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240622204628.png width=50% height=50% alt=效果图></p><p>原因：
并发执行,如果将白色对象写入黑色对象,同时没有其它未扫描的路径,可抵达该白色对象,它就不会被扫描携程发现,继而被误判为垃圾。</p><blockquote><p>当gc使用三色标记法与用户程序并发执行的时候，可能让黑色对象重新引用了白色对象，且无其他灰色对象引用了这个白色对象。导致白色对象错误回收。(用户程序和垃圾收集器可以在交替工作的)</p></blockquote><p>处理措施：</p><p>有两种方法来避免:</p><ul><li>强三色：黑色对象只能引用灰色对象。</li><li>弱三色：所有被黑色对象引用的白色对象都处于灰色保护状态.</li></ul><p>引入写屏障：就是在执行写操作时，额外做些标记工作(把数据对象的修改通知到垃圾回收器)，避免垃圾误判。</p><p>分为两种，一种是插入写屏障，一种是删除写屏障。</p><ol><li>插入写屏障</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>writePointer</span>(<span style=color:#a6e22e>slot</span>, <span style=color:#a6e22e>ptr</span>): <span style=color:#75715e>// ⚠️:slot现在指向的还是旧对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>shade</span>(<span style=color:#a6e22e>ptr</span>) <span style=color:#75715e>//shade函数尝试改变指针的颜色--&gt;改变ptr的颜色
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span> = <span style=color:#a6e22e>ptr</span>
</span></span></code></pre></div><ol start=2><li>删除写屏障： 会在老对象的引用被删除时，将白色的老对象涂成灰色。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>writePointer</span>(<span style=color:#a6e22e>slot</span>, <span style=color:#a6e22e>ptr</span>) <span style=color:#75715e>// ⚠️:slot现在指向的还是旧对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>shade</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span>) <span style=color:#75715e>//shade函数尝试改变指针的颜色--&gt;改变(*slot)的颜色---&gt;注意这个是*slot(旧对象),slot保存着它原先的保存的地址。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span> = <span style=color:#a6e22e>ptr</span>
</span></span></code></pre></div><blockquote><p>引入新问题：只有插入写屏障，但是这需要对所有堆、栈的写操作都开启写屏障，程序性能会受到影响，代价太大。为了改善这个问题，改为<strong>忽略协程栈</strong>上的写屏障，只在标记结束阶段重新扫描那些被激活的栈帧。但是Go语言通常会有大量活跃的协程，这就导致第二次STW时重新扫描协程栈的时间太长。</p></blockquote><ol start=3><li>混合写屏障</li></ol><p>把指向的旧对象标记成灰色; 如果当前正在标记的goroutine栈没有完成标记完（标记完，它栈上的对象应该都是黑色的，如果还未有开始当时goroutine栈标记，它的栈应该还是灰色的）则将新对象也标记成灰色。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span> <span style=color:#a6e22e>writePointer</span>(<span style=color:#a6e22e>slot</span>, <span style=color:#a6e22e>ptr</span>): <span style=color:#75715e>// ⚠️:slot现在指向的还是旧的对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>     <span style=color:#a6e22e>shade</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span>) <span style=color:#75715e>//旧对象标记为灰色。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>     <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>current</span> <span style=color:#a6e22e>stack</span> <span style=color:#a6e22e>is</span> <span style=color:#a6e22e>grey</span>: <span style=color:#75715e>// The insertion part of the barrier is necessary while the calling goroutine&#39;s stack is grey.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         <span style=color:#a6e22e>shade</span>(<span style=color:#a6e22e>ptr</span>)
</span></span><span style=display:flex><span>     <span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span> = <span style=color:#a6e22e>ptr</span>
</span></span></code></pre></div><ul><li><code>shade(*slot)</code>主要是防止用户程序把只有堆上唯一指向的*slot转移到通过栈来唯一指向，从而导致错误回收。</li></ul><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240707161156.png width=50% height=50% alt=效果图></p><ul><li><code>shade(ptr)</code>主要是防止用户程序把只有栈上唯一指向的ptr转移到通过堆来唯一指向，从而导致错误回收。</li></ul><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240707160348.png width=50% height=50% alt=效果图></p><ul><li><code>shade(ptr)</code>通过将对象从栈移动到堆来防止隐藏对象，但这需要首先在栈上隐藏一个指针。在堆栈被扫描后，它只指向灰色对象，所以它不会隐藏任何东西。故只有<code>if current stack is grey</code>的才进行<code>shade(ptr)</code></li></ul><p>既可<strong>忽略当前栈帧的写屏障</strong>，(不管是插入写屏障，还是删除写屏障)又不需要在第二次STW的时，重新扫描所有活跃G的栈帧。</p><h1 id=3-golang垃圾回收>3 golang垃圾回收
<a class=anchor href=#3-golang%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6>#</a></h1><h2 id=31-三色标记法>3.1 三色标记法
<a class=anchor href=#31-%e4%b8%89%e8%89%b2%e6%a0%87%e8%ae%b0%e6%b3%95>#</a></h2><p>在golang内存分配器一章中已讲述如何根据内存地址找到对象的所有管理单元以及重要的标志位，在heapArena中就有gc会用到的标志位：</p><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240727211054.png width=80% height=80% alt=效果图></p><table><thead><tr><th>颜色</th><th>含义</th><th>golang具体表示</th></tr></thead><tbody><tr><td>白色</td><td>代表未标记也未扫描的对象</td><td>白色对象就是那些<code>gcMarkBits</code>中标记为0的对象。</td></tr><tr><td>灰色</td><td>表示已标记但未进行扫描的对象</td><td>着为灰色对应的操作就是把指针对应的<code>gcmarkBits</code>标记位置为1并<strong>加入工作队列</strong></td></tr><tr><td>黑色</td><td>表示已标记但已扫描的对象</td><td>着为黑色对应的操作就是移出工作队列，并把指针对应的<code>gcmarkBits</code>标记位置为<code>1</code></td></tr></tbody></table><p>这里的工作队列，指的是实现了灰色对象指针的生产者-消费者模型的缓冲队列。</p><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240727193809.png width=50% height=50% alt=效果图></p><p>gcWork数据结构源代码如下所示:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>gcWork</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>wbuf1</span>, <span style=color:#a6e22e>wbuf2</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>workbuf</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>workbuf</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>workbufhdr</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// obj是uintptr数组，用来存储扫描过程中发现的指针。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>obj</span> [(<span style=color:#a6e22e>_WorkbufSize</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Sizeof</span>(<span style=color:#a6e22e>workbufhdr</span>{})) <span style=color:#f92672>/</span> <span style=color:#a6e22e>goarch</span>.<span style=color:#a6e22e>PtrSize</span>]<span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>_WorkbufSize</span> = <span style=color:#ae81ff>2048</span> <span style=color:#75715e>// 数组obj的容量为253。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>workbufhdr</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>node</span> <span style=color:#a6e22e>lfnode</span> 
</span></span><span style=display:flex><span>      <span style=color:#75715e>// nobj记录obj数组已使用的个数；当nobj==0表示缓存区为空，当nobj==缓存区长度时表示已满。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>nobj</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>lfnode</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>next</span>    <span style=color:#66d9ef>uint64</span>
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>pushcnt</span> <span style=color:#66d9ef>uint</span>
</span></span><span style=display:flex><span>            }
</span></span></code></pre></div><p>队列有了，下面来看对象置灰操作，主要是greyobject方法中，置灰分三步：</p><ol><li>将mspan.gcmarkBits对应bit位置为1</li><li>将heapArena.pageMarks对应bit位置为1</li><li>将对象添加到灰色对象缓存队列</li></ol><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240727211054.png width=80% height=80% alt=效果图></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>greyobject</span>(<span style=color:#a6e22e>obj</span>, <span style=color:#a6e22e>base</span>, <span style=color:#a6e22e>off</span> <span style=color:#66d9ef>uintptr</span>, <span style=color:#a6e22e>span</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span>, <span style=color:#a6e22e>gcw</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gcWork</span>, <span style=color:#a6e22e>objIndex</span> <span style=color:#66d9ef>uintptr</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mbits</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>markBitsForIndex</span>(<span style=color:#a6e22e>objIndex</span>)
</span></span><span style=display:flex><span>  <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// If marked we have nothing to do.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>mbits</span>.<span style=color:#a6e22e>isMarked</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 在其所属的 mspan 中，将对应位置的 gcMark bitmap 位置为 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>mbits</span>.<span style=color:#a6e22e>setMarked</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Mark span.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>arena</span>, <span style=color:#a6e22e>pageIdx</span>, <span style=color:#a6e22e>pageMask</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>pageIndexOf</span>(<span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>base</span>())
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>arena</span>.<span style=color:#a6e22e>pageMarks</span>[<span style=color:#a6e22e>pageIdx</span>]<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>pageMask</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Or8</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>arena</span>.<span style=color:#a6e22e>pageMarks</span>[<span style=color:#a6e22e>pageIdx</span>], <span style=color:#a6e22e>pageMask</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// If this is a noscan object, fast-track it to black nstead of greying it.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>spanclass</span>.<span style=color:#a6e22e>noscan</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>gcw</span>.<span style=color:#a6e22e>bytesMarked</span> <span style=color:#f92672>+=</span> uint64(<span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>elemsize</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Queue the obj for scanning.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 将对象添加到当前 p 的本地队列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>gcw</span>.<span style=color:#a6e22e>putFast</span>(<span style=color:#a6e22e>obj</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>gcw</span>.<span style=color:#a6e22e>put</span>(<span style=color:#a6e22e>obj</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=32-总体流程>3.2 总体流程
<a class=anchor href=#32-%e6%80%bb%e4%bd%93%e6%b5%81%e7%a8%8b>#</a></h2><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240727185445.png width=70% height=70% alt=效果图></p><p>全局变量</p><ul><li>runtime.gcphase 是垃圾收集器当前处于的阶段，可能处于 _GCoff、_GCmark 和 _GCmarktermination，Goroutine 在读取或者修改该阶段时需要保证原子性；</li><li>runtime.gcBlackenEnabled 是一个布尔值，当垃圾收集处于标记阶段时，该变量会被置为 1，在这里辅助垃圾收集的用户程序和后台标记的任务可以将对象涂黑；</li><li>runtime.writeBarrier 是一个包含写屏障状态的结构体，其中的 enabled 字段表示写屏障的开启与关闭；</li><li>runtime.worldsema 是全局的信号量，获取该信号量的线程有权利暂停当前应用程序；</li></ul><h3 id=321-第一次stw>3.2.1 第一次STW
<a class=anchor href=#321-%e7%ac%ac%e4%b8%80%e6%ac%a1stw>#</a></h3><p>垃圾收集在启动过程一定会调用<code>runtime.gcStart</code>函数，主要在标记工作之前做一些准备工作，其工作阶段对应垃圾回收总体流程的<strong>第一次STW</strong>。我们根据这个函数流程图来介绍该函数的实现：</p><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240803150624.png width=30% height=30% alt=效果图></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gcStart</span>(<span style=color:#a6e22e>trigger</span> <span style=color:#a6e22e>gcTrigger</span>) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>//并发地处理剩余的未清扫/正在清扫的span(完成上一个垃圾收集的收尾工作)。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>     <span style=color:#75715e>// 如果我们是在后台模式下调用的，这种情况不应该发生，因为比例清扫应该刚刚完成了所有清扫工作，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>     <span style=color:#75715e>// 但四舍五入误差等可能会留下一些未清扫的 span。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>     <span style=color:#75715e>// 在强制模式下，这是必要的，因为GC可以在清扫周期的任何点被强制触发。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>trigger</span>.<span style=color:#a6e22e>test</span>() <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>sweepone</span>() <span style=color:#f92672>!=</span> ^uintptr(<span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sweep</span>.<span style=color:#a6e22e>nbgsweep</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>//加锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>semacquire</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>worldsema</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//启动与P的个数相同的标记协程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>gcBgMarkStartWorkers</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>//1.切换到g0后执行Stop the world操作
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>systemstack</span>(<span style=color:#a6e22e>stopTheWorldWithSema</span>)
</span></span><span style=display:flex><span>  <span style=color:#75715e>//2.在我们开始并发扫描之前完成清扫。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>systemstack</span>(<span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>finishsweep_m</span>()
</span></span><span style=display:flex><span>  })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//3.限制标记协程占用CPU时间片的比例为趋近25%
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>gcController</span>.<span style=color:#a6e22e>startCycle</span>(<span style=color:#a6e22e>now</span>, int(<span style=color:#a6e22e>gomaxprocs</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//4.进入并发标记阶段并启用写屏障。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>setGCPhase</span>(<span style=color:#a6e22e>_GCmark</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//5.标记所有活动的tinyalloc块。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//因为我们正在从这些块中分配内存，所以它们需要像其他分配一样被标记为黑色。另一种选择是在每次从tiny块分配时将其变黑，这会减慢tiny分配器的速度。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>gcMarkTinyAllocs</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Store</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>gcBlackenEnabled</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//6.切换至g0，重新start the world
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>systemstack</span>(<span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>now</span> = <span style=color:#a6e22e>startTheWorldWithSema</span>(<span style=color:#a6e22e>trace</span>.<span style=color:#a6e22e>enabled</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  })
</span></span><span style=display:flex><span>  <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>semrelease</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>worldsema</span>)
</span></span><span style=display:flex><span>  <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h4 id=预生成标记协程>预生成标记协程
<a class=anchor href=#%e9%a2%84%e7%94%9f%e6%88%90%e6%a0%87%e8%ae%b0%e5%8d%8f%e7%a8%8b>#</a></h4><p>gcBgMarkStartWorkers预先生成标记协程（数量对应于P的个数）</p><blockquote><p>其中通过 notesleepg与notewake的机制，使得for循环与gcBgMarkWorker内部形成联动节奏，主要是为了缩短当进入标记阶段后，标记携程可开始标记的时间间隔.</p><blockquote><p>note是go runtime实现的一次性睡眠和唤醒机制，一个线程可以通过调用<code>notesleep(*note)</code>进入睡眠状态，而另外一个线程则可以通过<code>notewakeup(*note)</code>把其唤醒。</p></blockquote></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gcBgMarkStartWorkers</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>gcBgMarkWorkerCount</span> &lt; <span style=color:#a6e22e>gomaxprocs</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>gcBgMarkWorker</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>notetsleepg</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>work</span>.<span style=color:#a6e22e>bgMarkReady</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>noteclear</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>work</span>.<span style=color:#a6e22e>bgMarkReady</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>gcBgMarkWorkerCount</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>gcBgMarkWorker方法中将g包装成一个node天添加到全局的gcBgMarkWorkerPool中，并调用 gopark 方法将当前g挂起，等待被唤醒.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gcBgMarkWorker</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> new(<span style=color:#a6e22e>gcBgMarkWorkerNode</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>preemptoff</span> = <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>gp</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>acquirem</span>())
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 唤醒外部的 for 循环
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>notewakeup</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>work</span>.<span style=color:#a6e22e>bgMarkReady</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 当前 g 阻塞至此，直到 gcController.findRunnableGCWorker 方法被调用，会将当前 g 唤醒
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>gopark</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>g</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>nodep</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>gcBgMarkWorkerNode</span>)(<span style=color:#a6e22e>nodep</span>)
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 将当前 g 包装成一个 node 添加到 gcBgMarkWorkerPool 中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>gcBgMarkWorkerPool</span>.<span style=color:#a6e22e>push</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>node</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>        }, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>node</span>), <span style=color:#a6e22e>waitReasonGCWorkerIdle</span>, <span style=color:#a6e22e>traceEvGoBlock</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=控制标记协程的cpu利用率>控制标记协程的CPU利用率
<a class=anchor href=#%e6%8e%a7%e5%88%b6%e6%a0%87%e8%ae%b0%e5%8d%8f%e7%a8%8b%e7%9a%84cpu%e5%88%a9%e7%94%a8%e7%8e%87>#</a></h4><p>GC默认的CPU目标使用率为25%，在初始化阶段，根据<code>gomaxprocs*0.25%</code>得出需要启动的标记协程个数，而这有时不为整数，所以需要进行四舍五入(+0.5，然后转化为整形)，但是这样的取整会和原目标产生误差，而误差大于0.3时就比较明显了。</p><blockquote><p><code>9*25%=2.25</code>然后再<code>+0.5</code>取整，等于<code>3</code></p><blockquote><p>误差为：<code>3/2.25-1=1/3=0.3333333333333</code></p></blockquote></blockquote><p>所以，GC把标记协程分成了以下几种工作模式:</p><ul><li>gcMarkWorkerDedicatedMode：专用标记模式。&ldquo;不会"被调度器抢占<ul><li>会先以可被抢占的模式尝试执行，倘若真的被用户协程抢占，再将标记模式改为不可抢占模式. (减少当前P下用户协程的等待时长，提高用户体验.)</li></ul></li><li>gcMarkWorkerFractionalMode：分时标记模式. 当标记协程执行时长达到一定比例后，可以被抢占</li><li>gcMarkWorkerIdleMode: 空闲模式. 随时可以被抢占</li></ul><p>记录在对应的P结构中，作为它的标记协程的工作模式。</p><p><code>startCycle</code>会根据全局处理器的个数以及垃圾收集的 CPU 利用率计算出 dedicatedMarkWorkersNeeded 和 fractionalUtilizationGoal 以决定不同模式的工作协程的数量。</p><p>还是以上面的例子来说明，fractionalUtilizationGoal等于<code>(2.25-2)/procs的个数</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gcControllerState</span>) <span style=color:#a6e22e>startCycle</span>(<span style=color:#a6e22e>markStartTime</span> <span style=color:#66d9ef>int64</span>, <span style=color:#a6e22e>procs</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 计算后台标记利用率目标。总的来说，这可能不会完全准确。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 我们四舍五入专用工作线程的数量(+0.5，然后强转换为整形)，使利用率尽可能接近 25%。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 对于小的 GOMAXPROCS，这会引入太多误差，因此在这种情况下我们添加分数工作线程。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>totalUtilizationGoal</span> <span style=color:#f92672>:=</span> float64(<span style=color:#a6e22e>procs</span>) <span style=color:#f92672>*</span> <span style=color:#a6e22e>gcBackgroundUtilization</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dedicatedMarkWorkersNeeded</span> = int64(<span style=color:#a6e22e>totalUtilizationGoal</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>utilError</span> <span style=color:#f92672>:=</span> float64(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dedicatedMarkWorkersNeeded</span>)<span style=color:#f92672>/</span><span style=color:#a6e22e>totalUtilizationGoal</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>maxUtilError</span> = <span style=color:#ae81ff>0.3</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>utilError</span> &lt; <span style=color:#f92672>-</span><span style=color:#a6e22e>maxUtilError</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>utilError</span> &gt; <span style=color:#a6e22e>maxUtilError</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 四舍五入使我们偏离目标超过 30%。对于 gcBackgroundUtilization 为 25%，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 这发生在 GOMAXPROCS&lt;=3 或 GOMAXPROCS=6 时。启用分数工作线程进行补偿。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> float64(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dedicatedMarkWorkersNeeded</span>) &gt; <span style=color:#a6e22e>totalUtilizationGoal</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 专用工作线程太多。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dedicatedMarkWorkersNeeded</span><span style=color:#f92672>--</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 计算出每个 P 需要额外执行标记任务的时间片比例
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>fractionalUtilizationGoal</span> = (<span style=color:#a6e22e>totalUtilizationGoal</span> <span style=color:#f92672>-</span> float64(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dedicatedMarkWorkersNeeded</span>)) <span style=color:#f92672>/</span> float64(<span style=color:#a6e22e>procs</span>)
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>fractionalUtilizationGoal</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>P会记录自己累计执行Fractional worker的时间，</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>P</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>gcFractionalMarkTime</span> <span style=color:#66d9ef>int64</span> <span style=color:#75715e>// Nanoseconds in fractional mark worker (atomic)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// gcMarkWorkerMode 是下一个标记工作线程运行的模式。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 也就是说，这用于与由 gcController.findRunnableGCWorker 选定用于立即执行的工作 Goroutine 进行通信。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 当调度其他 Goroutine 时，这个字段必须设置为 gcMarkWorkerNotWorker。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>gcMarkWorkerMode</span> <span style=color:#a6e22e>gcMarkWorkerMode</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// gcMarkWorkerStartTime 是最近一次标记工作线程开始运行的 nanotime() 时间。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>gcMarkWorkerStartTime</span> <span style=color:#66d9ef>int64</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>同时全局的gcControllerState会记录后台标记工作线程开始时间。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>gcControllerState</span> <span style=color:#66d9ef>struct</span>{
</span></span><span style=display:flex><span>  <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// markStartTime 是后台标记工作线程开始的绝对时间，以纳秒为单位。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>markStartTime</span> <span style=color:#66d9ef>int64</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>通过检查当前P累计在fractionalt模式下的工作时间与本轮GC已经执行的时间比值，跟<code>fractionalUtilizationGoal</code>相比较就能知道当前标记协程是否可以退出了,从而控制CPU的使用率。</p><h5 id=标记tinyalloc块>标记tinyalloc块
<a class=anchor href=#%e6%a0%87%e8%ae%b0tinyalloc%e5%9d%97>#</a></h5><p>在标记协程与工作协程并发执行时，工作协程每次申请小对象时，需将tiny块标记为黑色，这将会减慢tiny分配器的速度。所以在第一次STW时，直接把所有的<code>tinyalloc</code>块对应的span区域都标记为黑色，这样在标记阶段申请小对象就不需要做额外的标黑动作，加快了分配速度。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gcMarkTinyAllocs</span>() {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>assertWorldStopped</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>allp</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>mcache</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>tiny</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>span</span>, <span style=color:#a6e22e>objIndex</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>findObject</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>tiny</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>gcw</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>gcw</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>greyobject</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>tiny</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>span</span>, <span style=color:#a6e22e>gcw</span>, <span style=color:#a6e22e>objIndex</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=暂停与恢复程序stopstart-the-world>暂停与恢复程序(stop/start the world)
<a class=anchor href=#%e6%9a%82%e5%81%9c%e4%b8%8e%e6%81%a2%e5%a4%8d%e7%a8%8b%e5%ba%8fstopstart-the-world>#</a></h5><p>暂停程序会使用<code>runtime.preemptall</code>抢占所有的处理器，恢复程序时会使用<code>runtime.notewakeup</code>或者<code>runtime.newm</code>唤醒程序中的处理器。</p><p>暂停程序过程如下：</p><table><thead><tr><th>调用链</th><th>说明</th></tr></thead><tbody><tr><td>sched.gcwaiting标识置为1</td><td>后续的调度流程见其标识，都会阻塞挂起</td></tr><tr><td>调用preemptall()</td><td>发送抢占信息抢占所有 G，后将 p 状态置为 syscall</td></tr><tr><td>所有p的状态设置为stop(包括正在运行以及空闲的p)</td><td></td></tr><tr><td>倘若部分任务无法抢占，则等待其完成后再进行抢占</td><td></td></tr></tbody></table><p>恢复程序过程如下：</p><table><thead><tr><th>调用链</th><th>说明</th></tr></thead><tbody><tr><td>runtime.netpoll</td><td>从网络轮询器中获取待处理的任务并加入全局队列</td></tr><tr><td>runtime.procresize</td><td>扩容或者缩容全局的处理器</td></tr><tr><td>runtime.notewakeup或者runtime.newm</td><td>依次唤醒处理器或者为处理器创建新的线程；如果当前待处理的 Goroutine 数量过多，创建额外的处理器辅助完成任务；</td></tr></tbody></table><h3 id=322-标记阶段>3.2.2 标记阶段
<a class=anchor href=#322-%e6%a0%87%e8%ae%b0%e9%98%b6%e6%ae%b5>#</a></h3><blockquote><p>对内存中对象进行扫描和标记</p></blockquote><h4 id=调度标记协程>调度标记协程
<a class=anchor href=#%e8%b0%83%e5%ba%a6%e6%a0%87%e8%ae%b0%e5%8d%8f%e7%a8%8b>#</a></h4><p>调度器在调度循环<code>runtime.schedule</code>中还可以通过垃圾收集控制器的<code>runtime.gcControllerState.findRunnabledGCWorker</code>获取并执行用于后台标记任务goroutine。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>schedule</span>() {
</span></span><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 获取一个标记协程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gp</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>gcBlackenEnabled</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>gp</span> = <span style=color:#a6e22e>gcController</span>.<span style=color:#a6e22e>findRunnableGCWorker</span>(<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>())
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gp</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>tryWakeP</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 调度执行标记协程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>execute</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>inheritTime</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gcControllerState</span>) <span style=color:#a6e22e>findRunnableGCWorker</span>(<span style=color:#a6e22e>_p_</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>p</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    	<span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>gcBgMarkWorkerNode</span>)(<span style=color:#a6e22e>gcBgMarkWorkerPool</span>.<span style=color:#a6e22e>pop</span>())
</span></span><span style=display:flex><span>    	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    	}
</span></span><span style=display:flex><span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>ptr</span>()
</span></span><span style=display:flex><span>    	<span style=color:#a6e22e>casgstatus</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>_Gwaiting</span>, <span style=color:#a6e22e>_Grunnable</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>gp</span>
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>这里也就呼应了前文创建标记协程，放入后台标记协程池后，如何调度标记协程，继续执行的逻辑</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gcStart</span>(<span style=color:#a6e22e>trigger</span> <span style=color:#a6e22e>gcTrigger</span>) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>//启动与P的个数相同的标记协程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>gcBgMarkStartWorkers</span>()
</span></span><span style=display:flex><span>  <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gcBgMarkStartWorkers</span>() {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>gcBgMarkWorkerCount</span> &lt; <span style=color:#a6e22e>gomaxprocs</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>gcBgMarkWorker</span>()
</span></span><span style=display:flex><span>      <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gcBgMarkWorker</span>() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 将当前g包装成一个node，后续放入后台标记协程池(gcBgMarkWorkerPool)中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> new(<span style=color:#a6e22e>gcBgMarkWorkerNode</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>preemptoff</span> = <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>gp</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>acquirem</span>())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>gopark</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>g</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>nodep</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>gcBgMarkWorkerNode</span>)(<span style=color:#a6e22e>nodep</span>)
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// 添加后台标记协程池(gcBgMarkWorkerPool)中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#a6e22e>gcBgMarkWorkerPool</span>.<span style=color:#a6e22e>push</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>node</span>)
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>                }, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>node</span>), <span style=color:#a6e22e>waitReasonGCWorkerIdle</span>, <span style=color:#a6e22e>traceEvGoBlock</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            }
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><p>至此我们知道在调度标记协程后，它应该会继续执行<code>runtime.gcBgMarkWorker</code>函数中剩下的逻辑。</p><h4 id=标记协程>标记协程
<a class=anchor href=#%e6%a0%87%e8%ae%b0%e5%8d%8f%e7%a8%8b>#</a></h4><p>标记协程执行标记工作，是由<code>runtime.gcBgMarkWorker</code>来承接的，该函数的可分为三个部分：</p><table><thead><tr><th>阶段</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>初始化</td><td>将当前处理器和Goroutine打包成runtime.gcBgMarkWorkerNode类型的结构体，并主动进入休眠状态，等待被唤醒。</td><td>【预生成标记协程】一节已讨论</td></tr><tr><td>扫描&标记</td><td>根据处理器上设置的gcMarkWorkerMode模式，决定采用哪种策略来执行内存中对象图的扫描和标记任务，最终在gcDrain中进行扫描标记。</td><td>标记协程工作模式已在【控制标记协程的CPU利用率】一节已讨论</td></tr><tr><td>标记完成</td><td>当所有标记任务都完成后，调用runtime.gcMarkDone方法，以结束标记阶段的工作。</td><td>将在后续【第二次STW】一节中讨论</td></tr></tbody></table><p>标记完成，会重新进入STW，这里我们后面再分析，当前聚焦于扫描&标记。</p><p>标记协程被唤醒后，主线又重新拉回到<code>gcBgMarkWorker</code>方法中，此时会根据<code>控制标记协程的CPU利用率</code>一节中讨论的标记模式，调用<code>gcDrain</code>方法开始执行并发标记工作.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gcBgMarkWorker</span>() {
</span></span><span style=display:flex><span><span style=color:#75715e>// 1.预生成标记协程一节已讨论
</span></span></span><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span><span style=color:#75715e>// 1.预生成标记协程一节已讨论
</span></span></span><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>systemstack</span>(<span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将我们的 goroutine 标记为可抢占状态，以便其堆栈可以被扫描。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 这让两个标记工作者可以相互扫描（否则，它们将死锁）。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 我们不能修改 G 堆栈上的任何内容。然而，标记工作者的堆栈收缩是禁用的，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 因此读取 G 堆栈是安全的。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>casgstatus</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>_Grunning</span>, <span style=color:#a6e22e>_Gwaiting</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>gcMarkWorkerMode</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>default</span>:
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;gcBgMarkWorker: unexpected gcMarkWorkerMode&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>gcMarkWorkerDedicatedMode</span>:
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 先按照可抢占模式执行标记协程，倘若被抢占，则将抢占协程添加到全局队列中，之后再以不可抢占模式执行标记协程。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>gcDrain</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>gcw</span>, <span style=color:#a6e22e>gcDrainUntilPreempt</span>|<span style=color:#a6e22e>gcDrainFlushBgCredit</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>preempt</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 我们被抢占了。这是一个有用的信号，可以将所有g
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// 从运行队列中踢出，以便它可以在其他地方运行。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>drainQ</span>, <span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>runqdrain</span>(<span style=color:#a6e22e>pp</span>); <span style=color:#a6e22e>n</span> &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>globrunqputbatch</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>drainQ</span>, int32(<span style=color:#a6e22e>n</span>))
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 重新进入，这次没有抢占。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>gcDrain</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>gcw</span>, <span style=color:#a6e22e>gcDrainFlushBgCredit</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>gcMarkWorkerFractionalMode</span>:
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>gcDrain</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>gcw</span>, <span style=color:#a6e22e>gcDrainFractional</span>|<span style=color:#a6e22e>gcDrainUntilPreempt</span>|<span style=color:#a6e22e>gcDrainFlushBgCredit</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>gcMarkWorkerIdleMode</span>:
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>gcDrain</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>gcw</span>, <span style=color:#a6e22e>gcDrainIdle</span>|<span style=color:#a6e22e>gcDrainUntilPreempt</span>|<span style=color:#a6e22e>gcDrainFlushBgCredit</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>casgstatus</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>_Gwaiting</span>, <span style=color:#a6e22e>_Grunning</span>)
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span> <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看到都是继续调用了<code>gcDrain</code>函数，由它来扫描根和工作缓冲区中的对象，将灰色对象变黑，直到无法获得更多工作为止。
它可能在GC完成之前返回, 具体根据入参中传递的不同模式来决定;目的是为了平衡其他处理器的工作。</p><table><thead><tr><th>标记模式</th><th>说明</th></tr></thead><tbody><tr><td>gcDrainUntilPreempt</td><td>当 Goroutine 的 preempt 字段被设置成 true 时返回<br>(If flags&amp;gcDrainUntilPreempt != 0, gcDrain returns when g.preempt is set.)</td></tr><tr><td>gcDrainIdle</td><td>调用 runtime.pollWork，当处理器上包含其他待执行 Goroutine 时返回；<br>(If flags&amp;gcDrainIdle != 0, gcDrain returns when there is other work to do.)</td></tr><tr><td>gcDrainFractional</td><td>调用 runtime.pollFractionalWorkerExit，当 CPU 的占用率超过 fractionalUtilizationGoal 的 20% 时返回；<br>(If flags&amp;gcDrainFractional != 0, gcDrain self-preempts when pollFractionalWorkerExit() returns true. This implies gcDrainNoBlock.)</td></tr><tr><td>gcDrainFlushBgCredit</td><td>调用 runtime.gcFlushBgCredit 计算后台完成的标记任务量以减少并发标记期间的辅助垃圾收集的用户程序的工作量；<br>(If flags&amp;gcDrainFlushBgCredit != 0, gcDrain flushes scan work credit to gcController.bgScanCredit every gcCreditSlack units of scan work.)</td></tr></tbody></table><p>标记主流程</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gcDrain</span>(<span style=color:#a6e22e>gcw</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gcWork</span>, <span style=color:#a6e22e>flags</span> <span style=color:#a6e22e>gcDrainFlags</span>) {
</span></span><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 1. 在空闲模式（gcDrainIdle）和分时模式（gcDrainFractional）下，会提前设好检查函数（pollWork 和 pollFractionalWorkerExit）在执行下一个自我抢占检查之前的扫描工作量。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 2. 标记根对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>markroot</span>(<span style=color:#a6e22e>gcw</span>, <span style=color:#a6e22e>job</span>, <span style=color:#a6e22e>flushBgCredit</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 3. for循环标记堆对象，直到达到退出条件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> !(<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>preempt</span> <span style=color:#f92672>&amp;&amp;</span> (<span style=color:#a6e22e>preemptible</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>gcwaiting</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>)) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 尽量保持全局队列上有可用的工作。我们过去常常检查是否有等待的工作者，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 但最好是保持工作可用，而不是让工作者等待。在最坏的情况下，我们将进行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// O(log(_WorkbufSize)) 不必要的平衡。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>work</span>.<span style=color:#a6e22e>full</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>gcw</span>.<span style=color:#a6e22e>balance</span>()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 4. 循环从gcw缓存队列中取出灰色对象，执行scanObject方法进行扫描标记
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gcw</span>.<span style=color:#a6e22e>tryGetFast</span>()
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>gcw</span>.<span style=color:#a6e22e>tryGet</span>()
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>				<span style=color:#75715e>// 刷新写屏障缓冲区；这可能会创建更多的工作。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#a6e22e>wbBufFlush</span>(<span style=color:#66d9ef>nil</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>gcw</span>.<span style=color:#a6e22e>tryGet</span>()
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// 无法获得工作。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>scanobject</span>(<span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>gcw</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 如果我们在本地积累了足够的背景扫描工作信誉，则将其刷新到全局账户中，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// 以便变异体辅助可以从中提取。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gcw</span>.<span style=color:#a6e22e>heapScanWork</span> <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>gcCreditSlack</span> {
</span></span><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>checkWork</span> <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>checkWork</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>drainCheckThreshold</span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>check</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>check</span>() {
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h4 id=3221-中止标记协程>3.2.2.1 中止标记协程
<a class=anchor href=#3221-%e4%b8%ad%e6%ad%a2%e6%a0%87%e8%ae%b0%e5%8d%8f%e7%a8%8b>#</a></h4><p>对应于idle模式的check函数是pollwork，方法中判断P本地队列存在就绪的g或者存在就绪的网络写成，就会对当前标记协程进行中断：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gcDrain</span>(<span style=color:#a6e22e>gcw</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gcWork</span>, <span style=color:#a6e22e>flags</span> <span style=color:#a6e22e>gcDrainFlags</span>) {
</span></span><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 1. 在空闲模式（gcDrainIdle）和分时模式（gcDrainFractional）下，会提前设好检查函数（pollWork 和 pollFractionalWorkerExit）在执行下一个自我抢占检查之前的扫描工作量。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>checkWork</span> <span style=color:#f92672>:=</span> int64(<span style=color:#ae81ff>1</span><span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>63</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>check</span> <span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>flags</span><span style=color:#f92672>&amp;</span>(<span style=color:#a6e22e>gcDrainIdle</span>|<span style=color:#a6e22e>gcDrainFractional</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>checkWork</span> = <span style=color:#a6e22e>initScanWork</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>drainCheckThreshold</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>idle</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>check</span> = <span style=color:#a6e22e>pollWork</span>
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>flags</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>gcDrainFractional</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>check</span> = <span style=color:#a6e22e>pollFractionalWorkerExit</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>pollWork</span>() <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>runqsize</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>().<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>runqempty</span>(<span style=color:#a6e22e>p</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>netpollinited</span>() <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>netpollWaiters</span>) &gt; <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lastpoll</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>list</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>netpoll</span>(<span style=color:#ae81ff>0</span>); !<span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>empty</span>() {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>injectglist</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>list</span>)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>对应于 fractional 模式的check函数是pollFractionalWorkerExit，倘若当前标记协程执行的时间比例大于 1.2 倍的 fractionalUtilizationGoal 阈值（3.4小节中设置），就会中止标记协程.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>pollFractionalWorkerExit</span>() <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>now</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>nanotime</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>delta</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>now</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>gcController</span>.<span style=color:#a6e22e>markStartTime</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>delta</span> <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>().<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>selfTime</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>gcFractionalMarkTime</span> <span style=color:#f92672>+</span> (<span style=color:#a6e22e>now</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>gcMarkWorkerStartTime</span>)
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> float64(<span style=color:#a6e22e>selfTime</span>)<span style=color:#f92672>/</span>float64(<span style=color:#a6e22e>delta</span>) &gt; <span style=color:#ae81ff>1.2</span><span style=color:#f92672>*</span><span style=color:#a6e22e>gcController</span>.<span style=color:#a6e22e>fractionalUtilizationGoal</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=3221-扫描根对象>3.2.2.1 扫描根对象
<a class=anchor href=#3221-%e6%89%ab%e6%8f%8f%e6%a0%b9%e5%af%b9%e8%b1%a1>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gcDrain</span>(<span style=color:#a6e22e>gcw</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gcWork</span>, <span style=color:#a6e22e>flags</span> <span style=color:#a6e22e>gcDrainFlags</span>) {
</span></span><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 1. 在空闲模式（gcDrainIdle）和分时模式（gcDrainFractional）下，会提前设好检查函数（pollWork 和 pollFractionalWorkerExit）在执行下一个自我抢占检查之前的扫描工作量。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 2. 标记根对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>work</span>.<span style=color:#a6e22e>markrootNext</span> &lt; <span style=color:#a6e22e>work</span>.<span style=color:#a6e22e>markrootJobs</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果我们是可抢占的或者有人想要STW，则停止。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> !(<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>preempt</span> <span style=color:#f92672>&amp;&amp;</span> (<span style=color:#a6e22e>preemptible</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>gcwaiting</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>)) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>markroot</span>(<span style=color:#a6e22e>gcw</span>, <span style=color:#a6e22e>job</span>, <span style=color:#a6e22e>flushBgCredit</span>)
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>check</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>check</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>done</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>从<code>gcDrain</code>函数中继续可以看到，使用<code>runtime.markroot</code>扫描根对象，</p><p>主要有以下几项：</p><ol><li>.bss段内存中的未初始化全局变量</li><li>.data段内存中的已初始化的变量</li><li>span中的finalizer</li><li>协程栈</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>markroot</span>(<span style=color:#a6e22e>gcw</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gcWork</span>, <span style=color:#a6e22e>i</span> <span style=color:#66d9ef>uint32</span>, <span style=color:#a6e22e>flushBgCredit</span> <span style=color:#66d9ef>bool</span>) <span style=color:#66d9ef>int64</span> {
</span></span><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>switch</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//1. 处理已初始化的全局变量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>work</span>.<span style=color:#a6e22e>baseData</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>work</span>.<span style=color:#a6e22e>baseBSS</span>:
</span></span><span style=display:flex><span>          <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>workDone</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>markrootBlock</span>(<span style=color:#a6e22e>datap</span>.<span style=color:#a6e22e>data</span>, <span style=color:#a6e22e>datap</span>.<span style=color:#a6e22e>edata</span><span style=color:#f92672>-</span><span style=color:#a6e22e>datap</span>.<span style=color:#a6e22e>data</span>, <span style=color:#a6e22e>datap</span>.<span style=color:#a6e22e>gcdatamask</span>.<span style=color:#a6e22e>bytedata</span>, <span style=color:#a6e22e>gcw</span>, int(<span style=color:#a6e22e>i</span><span style=color:#f92672>-</span><span style=color:#a6e22e>work</span>.<span style=color:#a6e22e>baseData</span>))
</span></span><span style=display:flex><span>          <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//2. 处理未初始化的全局变量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>work</span>.<span style=color:#a6e22e>baseBSS</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>work</span>.<span style=color:#a6e22e>baseSpans</span>:
</span></span><span style=display:flex><span>          <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>workDone</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>markrootBlock</span>(<span style=color:#a6e22e>datap</span>.<span style=color:#a6e22e>bss</span>, <span style=color:#a6e22e>datap</span>.<span style=color:#a6e22e>ebss</span><span style=color:#f92672>-</span><span style=color:#a6e22e>datap</span>.<span style=color:#a6e22e>bss</span>, <span style=color:#a6e22e>datap</span>.<span style=color:#a6e22e>gcbssmask</span>.<span style=color:#a6e22e>bytedata</span>, <span style=color:#a6e22e>gcw</span>, int(<span style=color:#a6e22e>i</span><span style=color:#f92672>-</span><span style=color:#a6e22e>work</span>.<span style=color:#a6e22e>baseBSS</span>))
</span></span><span style=display:flex><span>          <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//3. 处理finalizer队列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>fixedRootFinalizers</span>:
</span></span><span style=display:flex><span>          <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>scanblock</span>(uintptr(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>fb</span>.<span style=color:#a6e22e>fin</span>[<span style=color:#ae81ff>0</span>])), <span style=color:#a6e22e>cnt</span><span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Sizeof</span>(<span style=color:#a6e22e>fb</span>.<span style=color:#a6e22e>fin</span>[<span style=color:#ae81ff>0</span>]), <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>finptrmask</span>[<span style=color:#ae81ff>0</span>], <span style=color:#a6e22e>gcw</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>          <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//4. 释放已终止的g的栈
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>fixedRootFreeGStacks</span>:
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>systemstack</span>(<span style=color:#a6e22e>markrootFreeGStacks</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>//5. 扫描mspan中的special
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>work</span>.<span style=color:#a6e22e>baseSpans</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>work</span>.<span style=color:#a6e22e>baseStacks</span>:
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>markrootSpans</span>(<span style=color:#a6e22e>gcw</span>, int(<span style=color:#a6e22e>i</span><span style=color:#f92672>-</span><span style=color:#a6e22e>work</span>.<span style=color:#a6e22e>baseSpans</span>))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>default</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 获取需要扫描的g
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>work</span>.<span style=color:#a6e22e>stackRoots</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>-</span><span style=color:#a6e22e>work</span>.<span style=color:#a6e22e>baseStacks</span>]
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 切回到 g0执行工作，扫描 g 的栈
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>systemstack</span>(<span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//6. 栈扫描
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>workDone</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>scanstack</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>gcw</span>)
</span></span><span style=display:flex><span>           <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        })
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>workDone</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>其中全局变量（已初始化/未初始化）主要由<code>markrootBlock</code>来承接，而它最终会调用<code>scanblock</code>函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>markrootBlock</span>(<span style=color:#a6e22e>b0</span>, <span style=color:#a6e22e>n0</span> <span style=color:#66d9ef>uintptr</span>, <span style=color:#a6e22e>ptrmask0</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint8</span>, <span style=color:#a6e22e>gcw</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gcWork</span>, <span style=color:#a6e22e>shard</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int64</span> {
</span></span><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>scanblock</span>(<span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>n</span>, <span style=color:#a6e22e>ptrmask</span>, <span style=color:#a6e22e>gcw</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>同样栈上最终也会调用到<code>scanblock</code>函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>scanstack</span>(<span style=color:#a6e22e>gp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>gcw</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gcWork</span>) <span style=color:#66d9ef>int64</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>scanframe</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>frame</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>stkframe</span>, <span style=color:#a6e22e>unused</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>scanframeworker</span>(<span style=color:#a6e22e>frame</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>state</span>, <span style=color:#a6e22e>gcw</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>scanframeworker</span>(<span style=color:#a6e22e>frame</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>stkframe</span>, <span style=color:#a6e22e>state</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>stackScanState</span>, <span style=color:#a6e22e>gcw</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gcWork</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 扫描局部变量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>locals</span>.<span style=color:#a6e22e>n</span> &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>scanblock</span>(<span style=color:#a6e22e>frame</span>.<span style=color:#a6e22e>varp</span><span style=color:#f92672>-</span><span style=color:#a6e22e>size</span>, <span style=color:#a6e22e>size</span>, <span style=color:#a6e22e>locals</span>.<span style=color:#a6e22e>bytedata</span>, <span style=color:#a6e22e>gcw</span>, <span style=color:#a6e22e>state</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 扫描函数参数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>n</span> &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>scanblock</span>(<span style=color:#a6e22e>frame</span>.<span style=color:#a6e22e>argp</span>, uintptr(<span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>n</span>)<span style=color:#f92672>*</span><span style=color:#a6e22e>goarch</span>.<span style=color:#a6e22e>PtrSize</span>, <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>bytedata</span>, <span style=color:#a6e22e>gcw</span>, <span style=color:#a6e22e>state</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span></code></pre></div><p>接下来我们来细看下<code>scanblock</code>函数:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>scanblock</span>(<span style=color:#a6e22e>b0</span>, <span style=color:#a6e22e>n0</span> <span style=color:#66d9ef>uintptr</span>, <span style=color:#a6e22e>ptrmask</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint8</span>, <span style=color:#a6e22e>gcw</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gcWork</span>, <span style=color:#a6e22e>stk</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>stackScanState</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 使用原始参数的本地副本，便于调试时查看原始块的基址和范围
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b0</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>n0</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#ae81ff>0</span>); <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>n</span>; {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 获取下一个字的位图
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>bits</span> <span style=color:#f92672>:=</span> uint32(<span style=color:#f92672>*</span><span style=color:#a6e22e>addb</span>(<span style=color:#a6e22e>ptrmask</span>, <span style=color:#a6e22e>i</span><span style=color:#f92672>/</span>(<span style=color:#a6e22e>goarch</span>.<span style=color:#a6e22e>PtrSize</span><span style=color:#f92672>*</span><span style=color:#ae81ff>8</span>)))
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>bits</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>i</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>goarch</span>.<span style=color:#a6e22e>PtrSize</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>j</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>j</span> &lt; <span style=color:#ae81ff>8</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>n</span>; <span style=color:#a6e22e>j</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>bits</span><span style=color:#f92672>&amp;</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>				<span style=color:#75715e>// 与 scanobject 中的工作相同；参见那里的注释
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>uintptr</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>i</span>))
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>obj</span>, <span style=color:#a6e22e>span</span>, <span style=color:#a6e22e>objIndex</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>findObject</span>(<span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>i</span>); <span style=color:#a6e22e>obj</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>						<span style=color:#a6e22e>greyobject</span>(<span style=color:#a6e22e>obj</span>, <span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>span</span>, <span style=color:#a6e22e>gcw</span>, <span style=color:#a6e22e>objIndex</span>)
</span></span><span style=display:flex><span>            <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				}
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>bits</span> <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>i</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>goarch</span>.<span style=color:#a6e22e>PtrSize</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>ptrmask存储着位图信息, 用于指示哪些位置是指针,一个bit位对应了一个指针大小（8B）的位置的标识信息，指明当前位置是否是指针，
当指示的位置非指针(ptrmask中存储的是0)，则直接跳过扫描，加速扫描的进度。</p><ul><li><ol><li>变量初始化:使用本地变量b和n来保存原始块的基址和长度，这样可以在调试时更容易查看这些值。</li></ol></li><li><ol start=2><li>主循环:</li></ol><ul><li>外层循环通过i遍历整个内存块，步长为<code>goarch.PtrSize * 8</code>。</li><li>内层循环通过j遍历每个字的位图，步长为<code>goarch.PtrSize</code>。</li></ul></li><li><ol start=3><li>位图处理，从位图中提取每个字的位信息bits:</li></ol><ul><li>如果bits为0，表示这一字没有指针，直接跳过。</li><li>如果bits不为0，进一步检查每个位是否为1，如果是，表示对应位置是指针。</li></ul></li></ul><p>当找到了指针对象，就进行标记工作。关于greyobject，在<code>3.1 三色标记法</code>一节已经进行过讨论了。</p><h4 id=3223-标记堆对象>3.2.2.3 标记堆对象
<a class=anchor href=#3223-%e6%a0%87%e8%ae%b0%e5%a0%86%e5%af%b9%e8%b1%a1>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gcDrain</span>(<span style=color:#a6e22e>gcw</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gcWork</span>, <span style=color:#a6e22e>flags</span> <span style=color:#a6e22e>gcDrainFlags</span>) {
</span></span><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 1. 在空闲模式（gcDrainIdle）和分时模式（gcDrainFractional）下，会提前设好检查函数（pollWork 和 pollFractionalWorkerExit）在执行下一个自我抢占检查之前的扫描工作量。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 2. 标记根对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 3. for循环标记堆对象，直到达到退出条件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> !(<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>preempt</span> <span style=color:#f92672>&amp;&amp;</span> (<span style=color:#a6e22e>preemptible</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>gcwaiting</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>)) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 4. 循环从gcw缓存队列中取出灰色对象，执行scanObject方法进行扫描标记
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 刷新写屏障缓冲区；这可能会创建更多的工作。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>          <span style=color:#a6e22e>wbBufFlush</span>(<span style=color:#66d9ef>nil</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>scanobject</span>(<span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>gcw</span>)
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 如果我们在本地积累了足够的背景扫描工作信誉，则将其刷新到全局账户中，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>//...
</span></span></span></code></pre></div><p><code>scanobject</code>从入参(必须指向堆对象或对象片段的开始位置)开始扫描对象，将指针添加到gcw。
扫描过程中，通过heapArena中的bitmap记录的信息，加速遍历过程，并将遍历到的对象，将其置灰，并添加到队列中。</p><p>关于位图标记前面已有讨论，这里不再赘述。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>scanobject</span>(<span style=color:#a6e22e>b</span> <span style=color:#66d9ef>uintptr</span>, <span style=color:#a6e22e>gcw</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gcWork</span>) {
</span></span><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 找到 b 的位图信息和 b 处对象的大小。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// b 要么是对象的开始，要么指向对象片段的开始，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 在这种情况下，我们会在下面计算扫描的大小。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>hbits</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>heapBitsForAddr</span>(<span style=color:#a6e22e>b</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>spanOfUnchecked</span>(<span style=color:#a6e22e>b</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>elemsize</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>i</span> <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> = <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>n</span>; <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>hbits</span> = <span style=color:#a6e22e>i</span><span style=color:#f92672>+</span><span style=color:#a6e22e>goarch</span>.<span style=color:#a6e22e>PtrSize</span>, <span style=color:#a6e22e>hbits</span>.<span style=color:#a6e22e>next</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 加载一次位图信息。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>bits</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hbits</span>.<span style=color:#a6e22e>bits</span>()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>bits</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>bitScan</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span> <span style=color:#75715e>// 这个对象中没有更多指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>bits</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>bitPointer</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span> <span style=color:#75715e>// 不是指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>obj</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>uintptr</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>i</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 此时我们已经提取了下一个可能的指针。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 快速筛选出空指针和指向当前对象的指针。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>obj</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>obj</span><span style=color:#f92672>-</span><span style=color:#a6e22e>b</span> <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>n</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 检查 obj 是否指向 Go 堆中，如果是，则标记对象。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 注意，如果 obj 指向一个刚分配的堆对象，findObject 可能会失败，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 因为与增加堆空间的操作存在竞争。在这种情况下，我们知道对象刚刚分配，因此会在分配时标记对象。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>obj</span>, <span style=color:#a6e22e>span</span>, <span style=color:#a6e22e>objIndex</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>findObject</span>(<span style=color:#a6e22e>obj</span>, <span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>i</span>); <span style=color:#a6e22e>obj</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>greyobject</span>(<span style=color:#a6e22e>obj</span>, <span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>span</span>, <span style=color:#a6e22e>gcw</span>, <span style=color:#a6e22e>objIndex</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h4 id=置黑新分配对象>置黑新分配对象
<a class=anchor href=#%e7%bd%ae%e9%bb%91%e6%96%b0%e5%88%86%e9%85%8d%e5%af%b9%e8%b1%a1>#</a></h4><p>分配黑色对象：在垃圾收集期间分配内存时，将对象标记为黑色。(黑色对象表示已经扫描过的对象，在当前GC周期不会再次扫描)</p><blockquote><p>当系统分配一块新的内存时，所有新分配的内存槽位都被初始化为nil，这意味着这些槽位中没有有效的指针。初始化为nil的目的是为了确保新分配的内存不会包含垃圾数据或悬空指针。</p></blockquote><p>不需要扫描的原因为：所有新分配的内存槽位都被初始化为nil，我们可以确定这些槽位中不包含任何指针。因此，GC不需要对这些槽位进行扫描。这可以减少GC的工作量，提高内存分配和垃圾收集的效率。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 在垃圾回收期间分配黑色对象。
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 所有槽位都持有 nil，因此不需要扫描。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>size</span> <span style=color:#66d9ef>uintptr</span>, <span style=color:#a6e22e>typ</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>, <span style=color:#a6e22e>needzero</span> <span style=color:#66d9ef>bool</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gcphase</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>_GCoff</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>gcmarknewobject</span>(<span style=color:#a6e22e>span</span>, uintptr(<span style=color:#a6e22e>x</span>), <span style=color:#a6e22e>size</span>, <span style=color:#a6e22e>scanSize</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>gcmarknewobject将一个新分配的对象标记为黑色。待标记的对象必须不包含任何非nil的指针。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gcmarknewobject</span>(<span style=color:#a6e22e>span</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span>, <span style=color:#a6e22e>obj</span>, <span style=color:#a6e22e>size</span>, <span style=color:#a6e22e>scanSize</span> <span style=color:#66d9ef>uintptr</span>) {
</span></span><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 标记对象。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>objIndex</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>objIndex</span>(<span style=color:#a6e22e>obj</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>markBitsForIndex</span>(<span style=color:#a6e22e>objIndex</span>).<span style=color:#a6e22e>setMarked</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 标记跨度。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>arena</span>, <span style=color:#a6e22e>pageIdx</span>, <span style=color:#a6e22e>pageMask</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>pageIndexOf</span>(<span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>base</span>())
</span></span><span style=display:flex><span>  <span style=color:#75715e>//pageMarks指示哪些跨度（spans）上有任何已标记的对象。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 像pageInUse 一样，只有每个跨度的第一个页面对应的位被使用。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>arena</span>.<span style=color:#a6e22e>pageMarks</span>[<span style=color:#a6e22e>pageIdx</span>]<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>pageMask</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Or8</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>arena</span>.<span style=color:#a6e22e>pageMarks</span>[<span style=color:#a6e22e>pageIdx</span>], <span style=color:#a6e22e>pageMask</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gcw</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>getg</span>().<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>().<span style=color:#a6e22e>gcw</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gcw</span>.<span style=color:#a6e22e>bytesMarked</span> <span style=color:#f92672>+=</span> uint64(<span style=color:#a6e22e>size</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h4 id=辅助标记>辅助标记
<a class=anchor href=#%e8%be%85%e5%8a%a9%e6%a0%87%e8%ae%b0>#</a></h4><p>在并发标记阶段，由于用户协程和标记协程共同工作，可能存在用户协程分配对象的速度快于标记协程标记对象的速度，从而导致标记阶段无法结束的极端场景。为了规避这个问题，Golang 引入了辅助标记策略，建立了一个兜底机制：在最坏情况下，一个用户协程分配了多少内存，就需要完成对应量的标记任务。</p><p>信用值的存取模型如下：</p><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240817201326.png width=50% height=50% alt=效果图></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>size</span> <span style=color:#66d9ef>uintptr</span>, <span style=color:#a6e22e>typ</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>, <span style=color:#a6e22e>needzero</span> <span style=color:#66d9ef>bool</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>assistG</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gcBlackenEnabled</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {       
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>assistG</span> = <span style=color:#a6e22e>getg</span>()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>assistG</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>curg</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>assistG</span> = <span style=color:#a6e22e>assistG</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>curg</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 每个 g 会有资产
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>assistG</span>.<span style=color:#a6e22e>gcAssistBytes</span> <span style=color:#f92672>-=</span> int64(<span style=color:#a6e22e>size</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>assistG</span>.<span style=color:#a6e22e>gcAssistBytes</span> &lt; <span style=color:#ae81ff>0</span> {           
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>gcAssistAlloc</span>(<span style=color:#a6e22e>assistG</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gcAssistAlloc</span>(<span style=color:#a6e22e>gp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Step 1: 确定负债额度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>debtBytes</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>-</span><span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>gcAssistBytes</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Step 2: 计算预期需要扫描的大小
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>scanWork</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>debtBytes</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>assistWorkPerByte</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Step 3: 检查预期扫描工作量是否低于最小扫描工作量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>scanWork</span> &lt; <span style=color:#a6e22e>gcOverAssistWork</span> {
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>scanWork</span> = <span style=color:#a6e22e>gcOverAssistWork</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 后续代码：执行实际的扫描工作
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span></code></pre></div><ol><li>信用兑换比率</li></ol><p>这里详细解释下<code>assistWorkPerByte</code>和<code>assistBytesPerWork</code>:在 Go 的垃圾收集器（GC）中，辅助标记策略是确保用户协程分配内存时能够按预期完成相应的标记任务。两个关键比率 assistWorkPerByte 和 assistBytesPerWork 在这一过程中起到了重要作用。</p><ul><li>assistWorkPerByte<ul><li>定义：assistWorkPerByte 是一个 float64 类型的值，表示每分配一字节内存空间应该相应地执行多少扫描工作。</li><li>意义：它是一个比率，用于计算在分配一定量的内存时需要完成的扫描工作量。</li><li>存取：尽管是 float64 类型，gcController 会将其转换为 uint64 进行原子性存取，以确保线程安全。</li></ul></li><li>assistBytesPerWork<ul><li>定义：assistBytesPerWork 是 assistWorkPerByte 的倒数，表示完成一字节的扫描工作后可以分配多大的内存空间。</li><li>意义：它也是一个比率，用于计算在完成一定量的扫描工作后可以分配的内存量。</li></ul></li></ul><p>这两个比率在每轮垃圾收集开始时计算，并随着堆扫描的进度一起更新。</p><ol start=2><li>计算预期扫描工作量的步骤</li></ol><ul><li>确定负债额度</li></ul><p>在 mallocgc 函数中，如果 gp.gcAssistBytes 小于 0，说明当前协程有标记负债，需要进行辅助标记。这时会调用 gcAssistAlloc 来执行辅助标记。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>gcAssistBytes</span> &lt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>debtBytes</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>-</span><span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>gcAssistBytes</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里，debtBytes 是负债额度，等于 gp.gcAssistBytes 的绝对值。</p><ul><li>计算预期需要扫描的大小</li></ul><p>预期需要扫描的大小等于 debtBytes 乘以 assist WorkPerByte。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>scanWork</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>debtBytes</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>assistWorkPerByte</span>
</span></span></code></pre></div><p>debtBytes：负债额度，表示需要补偿的内存分配量。
assistWorkPerByte：每分配一字节内存空间应该相应地做多少扫描工作，这是一个比率。</p><ul><li>检查预期扫描工作量是否低于最小扫描工作量</li></ul><p>如果预期的扫描工作量小于 gcOverAssist Work，则取 gcOverAssist Work 的值。gcOverAssist Work 是一个预定义的最小扫描工作量，目前被定义为 64KB。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>scanWork</span> &lt; <span style=color:#a6e22e>gcOverAssistWork</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>scanWork</span> = <span style=color:#a6e22e>gcOverAssistWork</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>gcOverAssistWork：最小扫描工作量，被定义为 64KB。</p><ol start=3><li>信用窃取</li></ol><p>如果全局信用额度足够抵消当前协程的扫描工作量，那么当前协程就不需要进行实际的扫描任务。这在垃圾收集器（GC）的实现中非常重要，因为它可以提高内存分配和扫描工作的效率。
如果信用资产不够，则会通过systemstack方法切换至g0，并在gcAssistAlloc1方法内调用 gcDrainN方法，进行并发标记。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gcAssistAlloc</span>(<span style=color:#a6e22e>gp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>) {
</span></span><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Step 4: 尝试从全局的可用资产中偷取信用额度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>bgScanCredit</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Loadint64</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>gcController</span>.<span style=color:#a6e22e>bgScanCredit</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>stolen</span> <span style=color:#f92672>:=</span> int64(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>bgScanCredit</span> &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>bgScanCredit</span> &lt; <span style=color:#a6e22e>scanWork</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>stolen</span> = <span style=color:#a6e22e>bgScanCredit</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>gcAssistBytes</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> int64(<span style=color:#a6e22e>assistBytesPerWork</span><span style=color:#f92672>*</span>float64(<span style=color:#a6e22e>stolen</span>))
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>stolen</span> = <span style=color:#a6e22e>scanWork</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>gcAssistBytes</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>debtBytes</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Xaddint64</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>gcController</span>.<span style=color:#a6e22e>bgScanCredit</span>, <span style=color:#f92672>-</span><span style=color:#a6e22e>stolen</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>scanWork</span> <span style=color:#f92672>-=</span> <span style=color:#a6e22e>stolen</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 全局资产够用，则无需辅助标记，直接返回
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>scanWork</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=323-第二次stw>3.2.3 第二次STW
<a class=anchor href=#323-%e7%ac%ac%e4%ba%8c%e6%ac%a1stw>#</a></h3><p>让我们继续回到<code>gcBgMarkWorker</code>函数:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gcBgMarkWorker</span>() {
</span></span><span style=display:flex><span><span style=color:#75715e>// 1.预生成标记协程一节已讨论
</span></span></span><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span><span style=color:#75715e>// 1.预生成标记协程一节已讨论
</span></span></span><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 2.标记协程
</span></span></span><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 3.标记终止
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>incnwait</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>work</span>.<span style=color:#a6e22e>nproc</span> <span style=color:#f92672>&amp;&amp;</span> !<span style=color:#a6e22e>gcMarkWorkAvailable</span>(<span style=color:#66d9ef>nil</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>gcMarkDone</span>()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>gcMarkDone函数的主要作用是确定是否已完成所有可达对象的标记，并在合适的时间点将GC状态从标记阶段转换到标记终止阶段。这个函数负责确保所有灰色对象（未完全标记的对象）都已被处理，并且没有新的灰色对象在此过程中产生。一旦确认所有对象都已被正确标记，它将进入标记终止阶段，准备进行垃圾回收。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gcMarkDone</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 确保只有一个线程在运行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>semacquire</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>work</span>.<span style=color:#a6e22e>markDoneSema</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>top</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 重新检查过渡条件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 获取 worldsema 信号量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>semacquire</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>worldsema</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 刷新所有本地缓冲区并收集flushedWork标志
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>systemstack</span>(<span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>().<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>curg</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>casgstatus</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>_Grunning</span>, <span style=color:#a6e22e>_Gwaiting</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>forEachP</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>_p_</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>p</span>) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>wbBufFlush1</span>(<span style=color:#a6e22e>_p_</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>gcw</span>.<span style=color:#a6e22e>dispose</span>()
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>gcw</span>.<span style=color:#a6e22e>flushedWork</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Xadd</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>gcMarkDoneFlushed</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>gcw</span>.<span style=color:#a6e22e>flushedWork</span> = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>casgstatus</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>_Gwaiting</span>, <span style=color:#a6e22e>_Grunning</span>)
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 重新检查过渡条件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>gcMarkDoneFlushed</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>semrelease</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>worldsema</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>top</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 进入标记终止阶段
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e>//第二次STW
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>systemstack</span>(<span style=color:#a6e22e>stopTheWorldWithSema</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 检查是否有残留工作需要处理，如果有，返回，重新STW
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 禁用GC助力和后台工作线程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Store</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>gcBlackenEnabled</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 唤醒所有被阻塞的线程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>gcWakeAllAssists</span>()
</span></span><span style=display:flex><span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 允许用户goroutine重新执行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>schedEnableUser</span>(<span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 结束GC周期并进行标记终止
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>gcMarkTermination</span>(<span style=color:#a6e22e>nextTriggerRatio</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>&#171;&#171;&#171;&lt; HEAD</p><ol><li>确保单线程执行并检查过渡条件;
=======</li></ol><ul><li><ol><li>确保单线程执行并检查过渡条件</li></ol><ul><li>首先，通过获取信号量markDoneSema，确保只有一个线程能够执行标记完成的操作，避免竞争条件。然后，检查是否满足从标记阶段过渡到标记终止阶段的条件。如果条件不满足，释放markDoneSema信号量并返回。</li></ul></li><li><ol start=2><li>刷新本地工作缓冲区并处理残留工作</li></ol><ul><li>通过调用forEachP函数，遍历所有处理器（P），刷新写屏障缓冲区和GC工作缓冲区。如果发现有新的工作被刷新出来，增加gcMarkDoneFlushed计数。然后，重新检查条件，如果有新的灰色对象被发现，则释放worldsema信号量并跳回到top，重新开始检查。</li></ul></li><li><ol start=3><li>进入标记终止阶段并结束GC周期</li></ol><ul><li>记录当前时间，更新相关的工作变量，并调用stopTheWorldWithSema停止所有用户goroutine的执行。再次检查所有处理器的GC工作缓冲区，如果发现有残留工作，则重新启动世界并返回顶部重新检查。禁唤醒所有被阻塞的助力线程，并允许用户goroutine重新执行。最后，进行标记终止。</li></ul></li></ul><h4 id=标记终止>标记终止
<a class=anchor href=#%e6%a0%87%e8%ae%b0%e7%bb%88%e6%ad%a2>#</a></h4><p>gcMarkTermination方法包括几个核心步骤:</p><ul><li>设置GC标志为:标记终止(<code>_GCmarktermination</code>)。</li><li>设置GC标志为:标记关闭(<code>_GCoff</code>)。</li><li>唤醒后台清扫协程,开始进行标记清扫(<code>gcSweep</code>函数)。</li><li>切换至g0，执行gcControllerCommit方法，设置触发下一轮GC的内存阈值。</li><li>切换至g0，调用startTheWorldWithSema方法，恢复运行。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gcMarkTermination</span>() {
</span></span><span style=display:flex><span>  <span style=color:#75715e>//1.设置GC标志为:标记终止
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>setGCPhase</span>(<span style=color:#a6e22e>_GCmarktermination</span>)
</span></span><span style=display:flex><span>  <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>systemstack</span>(<span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>     <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>//2.设置GC标志为:标记关闭
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>setGCPhase</span>(<span style=color:#a6e22e>_GCoff</span>)  
</span></span><span style=display:flex><span>  <span style=color:#75715e>//3.唤醒后台清扫协程,开始进行标记清扫
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>gcSweep</span>(<span style=color:#a6e22e>work</span>.<span style=color:#a6e22e>mode</span>)
</span></span><span style=display:flex><span>  })
</span></span><span style=display:flex><span>  <span style=color:#75715e>//4.提交下一轮GC的内存阈值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>systemstack</span>(<span style=color:#a6e22e>gcControllerCommit</span>)
</span></span><span style=display:flex><span>  <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>systemstack</span>(<span style=color:#66d9ef>func</span>() { <span style=color:#a6e22e>startTheWorldWithSema</span>(<span style=color:#66d9ef>true</span>) })
</span></span><span style=display:flex><span>  <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h4 id=3231唤醒清扫协程>3.2.3.1.唤醒清扫协程
<a class=anchor href=#3231%e5%94%a4%e9%86%92%e6%b8%85%e6%89%ab%e5%8d%8f%e7%a8%8b>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gcSweep</span>(<span style=color:#a6e22e>mode</span> <span style=color:#a6e22e>gcMode</span>) {
</span></span><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Background sweep.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sweep</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sweep</span>.<span style=color:#a6e22e>parked</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>weep</span>.<span style=color:#a6e22e>parked</span> = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ready</span>(<span style=color:#a6e22e>sweep</span>.<span style=color:#a6e22e>g</span>, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sweep</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>gcenable</span>()
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gcenable</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>bgsweep</span>(<span style=color:#a6e22e>c</span>)
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>c</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>bgsweep</span>(<span style=color:#a6e22e>c</span> <span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span><span style=color:#75715e>// 1. 获取g对象存入sweep中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>sweep</span>.<span style=color:#a6e22e>g</span> = <span style=color:#a6e22e>getg</span>()
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>lockInit</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sweep</span>.<span style=color:#a6e22e>lock</span>, <span style=color:#a6e22e>lockRankSweep</span>)
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sweep</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>sweep</span>.<span style=color:#a6e22e>parked</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>c</span> <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 2. 进行休眠
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>goparkunlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sweep</span>.<span style=color:#a6e22e>lock</span>, <span style=color:#a6e22e>waitReasonGCSweepWait</span>, <span style=color:#a6e22e>traceEvGoBlock</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>// 3. 唤醒后继续执行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 3.1. 进行循环中持续清扫对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>sweepone</span>() <span style=color:#f92672>!=</span> ^uintptr(<span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>sweep</span>.<span style=color:#a6e22e>nbgsweep</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 3.2. 每轮完成一个mspan的清扫工作后调用Gosched方法,主动让渡P的执行权
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>Gosched</span>()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=3231-清扫工作>3.2.3.1. 清扫工作
<a class=anchor href=#3231-%e6%b8%85%e6%89%ab%e5%b7%a5%e4%bd%9c>#</a></h4><p>sweepone方法每次清扫一个协程，清扫逻辑核心位于sweepLocked.sweep方法中，正是将mspan的gcmarkBits赋给allocBits，并创建出一个空白的bitmap作为新的gcmarkBits。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sweepone</span>() <span style=color:#66d9ef>uintptr</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sl</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sweep</span>.<span style=color:#a6e22e>active</span>.<span style=color:#a6e22e>begin</span>()
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 查找到一个待清扫的 mspan
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mheap_</span>.<span style=color:#a6e22e>nextSpanForSweep</span>()
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sl</span>.<span style=color:#a6e22e>tryAcquire</span>(<span style=color:#a6e22e>s</span>); <span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>npages</span> = <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>npages</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 对一个 mspan 进行清扫
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>sweep</span>(<span style=color:#66d9ef>false</span>) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Whole span was freed. Count it toward the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// page reclaimer credit since these pages can
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// now be used for span allocation.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#a6e22e>mheap_</span>.<span style=color:#a6e22e>reclaimCredit</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#a6e22e>npages</span>)
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Span is still in-use, so this returned no
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// pages to the heap and the span needs to
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// move to the swept in-use list.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#a6e22e>npages</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sweep</span>.<span style=color:#a6e22e>active</span>.<span style=color:#a6e22e>end</span>(<span style=color:#a6e22e>sl</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>npages</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>sl</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sweepLocked</span>) <span style=color:#a6e22e>sweep</span>(<span style=color:#a6e22e>preserve</span> <span style=color:#66d9ef>bool</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>allocBits</span> = <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>gcmarkBits</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>gcmarkBits</span> = <span style=color:#a6e22e>newMarkBits</span>(<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>nelems</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><ol start=2><li><p>刷新本地工作缓冲区并处理残留工作</p></li><li><p>进入标记终止阶段并结束GC周期</p></li></ol><h3 id=324-清扫阶段>3.2.4 清扫阶段
<a class=anchor href=#324-%e6%b8%85%e6%89%ab%e9%98%b6%e6%ae%b5>#</a></h3><h3 id=xx>xx
<a class=anchor href=#xx>#</a></h3><ul><li>gc开始：<ul><li>将所有的对象设置为<strong>白色</strong></li></ul></li><li>扫描阶段（scan）<ul><li>把全局变量和goroutine栈上的指针对象，标记为<strong>灰色</strong>, 而且收集起来（比如放入一个先入先出队列中）</li></ul></li><li>标记阶段(mark)<ul><li>从队列中弹出一个<strong>灰色</strong>指针对象</li><li>访问这个<strong>灰色</strong>对象所指向的对象，如果此对象是<strong>白色</strong>，则将它转变为<strong>灰色</strong>，并加入到队列中</li><li>将这个<strong>灰色</strong>对象标记为黑色，表示访问完毕</li><li>重复上述过程，直到队列为空(没有灰色对象了)</li></ul></li><li>清扫阶段(sweep)<ul><li>剩余的<strong>白色</strong>对象,说明不可达，可进行垃圾回收。</li></ul></li></ul><h2 id=并发标记的分工问题写屏障记录集的竞争问题>并发标记的分工问题？写屏障记录集的竞争问题？
<a class=anchor href=#%e5%b9%b6%e5%8f%91%e6%a0%87%e8%ae%b0%e7%9a%84%e5%88%86%e5%b7%a5%e9%97%ae%e9%a2%98%e5%86%99%e5%b1%8f%e9%9a%9c%e8%ae%b0%e5%bd%95%e9%9b%86%e7%9a%84%e7%ab%9e%e4%ba%89%e9%97%ae%e9%a2%98>#</a></h2><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210121134453.png alt=20210121134453></p><blockquote><p>这里的竞争问题，我怀疑是： 一个是gc从root Object到一直遍历，打标记(从上到下)，同时另一个用户程序也在更新Object的关联（比如从从一个灰色到白色节点断开）</p><blockquote><p>其中用户程序的写到每个P中的写屏障缓冲区。</p></blockquote></blockquote><ul><li>前面提到了全局变量work中存储着全局工作队列缓存（work.full），其实每个P都有<strong>一个本地工作队列（p.gcw）和一个写屏障缓冲（p.wbBuf）</strong>。</li><li>p.gcw中有两个workbuf：wbuf1和wbuf2，添加任务时总是从wbuf1添加，wbuf1满了就交换wbuf1和wbuf2，如果还是满的，就把当前wbuf1的工作flush到全局工作缓存中去。</li></ul><p>知道分工了，不可能占用很多CPU进行gc,这样会限制用户程序。</p><hr><hr><hr><h1 id=fqa>FQA
<a class=anchor href=#fqa>#</a></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>p的个数是固定的吗</span><span style=color:#960050;background-color:#1e0010>，</span><span style=color:#a6e22e>可以比机器CPU个数多吗</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>知道为什么一个gcWorker一个p了</span><span style=color:#960050;background-color:#1e0010>，</span><span style=color:#a6e22e>因为gcWorker不会被抢占</span><span style=color:#960050;background-color:#1e0010>，</span><span style=color:#a6e22e>它会一直占有一个p</span><span style=color:#960050;background-color:#1e0010>?</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>如果有多个P</span><span style=color:#960050;background-color:#1e0010>，</span><span style=color:#a6e22e>那么会不会存在有一个p一直不回被执行的</span><span style=color:#960050;background-color:#1e0010>？</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>新申请的对象是标记为黑色还是标记为灰色呢</span><span style=color:#960050;background-color:#1e0010>？</span>
</span></span></code></pre></div><h2 id=为什么gc也要扫描栈不是都在堆上面吗>为什么gc也要扫描栈，不是都在堆上面吗？
<a class=anchor href=#%e4%b8%ba%e4%bb%80%e4%b9%88gc%e4%b9%9f%e8%a6%81%e6%89%ab%e6%8f%8f%e6%a0%88%e4%b8%8d%e6%98%af%e9%83%bd%e5%9c%a8%e5%a0%86%e4%b8%8a%e9%9d%a2%e5%90%97>#</a></h2><p>因为堆上的地址，可能保存在栈上某个变量里，所以需要扫描。</p><h2 id=混合写屏障>混合写屏障
<a class=anchor href=#%e6%b7%b7%e5%90%88%e5%86%99%e5%b1%8f%e9%9a%9c>#</a></h2><p>问：我就是觉得混合写屏障好像也没法 解决重新扫描栈的问题</p><p>现在有 A, B, C三个对象，A(黑色，栈上)，B（灰色，栈上），C（白色，堆上）；
当前引用关系是：</p><pre tabindex=0><code>A（黑） -&gt; nil
B（灰） -&gt; C（白）
</code></pre><p>现在应用程序赋值修改，把A指向C：</p><pre tabindex=0><code>A（黑） -&gt; C（白）
B（灰） -&gt; nil
</code></pre><p>由于A，B是栈上的对象，栈上对象赋值这里可是没有写屏障的；那么岂不是黑色对象指向白色对象了，C会回收了，就悬挂指针了？</p><hr><p>答：Goroutine 栈扫描的过程需要 STW，所以你描述的这种状况是不存在的，<strong>栈上的对象要么全白要么全黑</strong></p><blockquote><ul><li>你说的“栈上的对象要么全白，要么全黑“ ，这个只是对一个 goroutine 栈来说的（golang 暂停业务扫描栈也是一个一个来的）。如果场景是 A 在 Goroutine1，B在Goroutine2呢？这种情况就是A是黑色，B是白色或者灰色。这样会不会就有我说的原本那个问题呢？<ul><li><a href=https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md#channel-operations-and-go-statements>The hybrid barrier assumes a goroutine cannot write to another goroutine&rsquo;s stack.(混合写屏障假设一个goroutine,不能写到另一个goroutine的栈)</a></li></ul></li><li>除了从一个Goroutine通过chan发送/生成一个新Goroutine<ul><li>如果两个Goroutine 栈只要有一个是灰色的，那么就会有<code>shade(ptr)</code></li><li>新生成的Goroutine栈都是黑色的（由前面的条件保证）,如果父Goroutine是灰色的，那么需使用<code>shade(ptr)</code></li></ul></li></ul></blockquote><h2 id=golang中gc支持增量与并发式回收怎么理解>Golang中GC支持增量与并发式回收怎么理解
<a class=anchor href=#golang%e4%b8%adgc%e6%94%af%e6%8c%81%e5%a2%9e%e9%87%8f%e4%b8%8e%e5%b9%b6%e5%8f%91%e5%bc%8f%e5%9b%9e%e6%94%b6%e6%80%8e%e4%b9%88%e7%90%86%e8%a7%a3>#</a></h2><p>增量和并发，一个是横向一个是纵向，gc与mutator交替与运行。</p><ul><li>横向：增量垃圾收集（增量地标记和清除垃圾，降低应用程序暂停的最长时间）</li><li>纵向：并发垃圾收集（利用多核的计算资源，在用户程序执行时并发标记和清除垃圾）<ul><li>因为增量和并发两种方式都可以与用户程序交替运行，所以我们需要使用屏障技术保证垃圾收集的正确性.</li></ul></li></ul><hr><ul><li><p>使用混合写屏障的原因是缩短gc暂停的时间。</p><ul><li>因为栈上使用写屏障，会导致耗时太多。但是如果栈上不使用写屏障，等到第二次STW重新扫描栈空间，goroutine数目多，需要扫描的stack耗时也多。
忽略协程栈的写屏障;其他的使用删除写屏障，插入写屏障。</li></ul></li><li><p>如果没有任何STW的时间，也就是说垃圾回收程序与用户程序完全并发执行，其代价与实现难度可能都会高于短暂的STW。例如标记——清扫回收器中，若完全抛弃STW，那么垃圾回收开始的消息便很难准确及时地通知到所有线程，可能导致<strong>某些线程</strong>开启<strong>写屏障</strong>的动作有所延迟而无法保障双方执行的正确性。</p></li></ul><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210113105703.png alt=gc></p><h2 id=为什么清扫阶段不需要屏障了呢>为什么清扫阶段不需要屏障了呢？
<a class=anchor href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%b8%85%e6%89%ab%e9%98%b6%e6%ae%b5%e4%b8%8d%e9%9c%80%e8%a6%81%e5%b1%8f%e9%9a%9c%e4%ba%86%e5%91%a2>#</a></h2><p>当标记完成了，那么它白色的对象都是不可达的对象，是可以删除的对象，程序不可能再找到已经不可达的对象。所以放心的清除。</p><h4 id=todo-并发gc如何缓解内存分配压力>TODO: 并发GC如何缓解内存分配压力？
<a class=anchor href=#todo-%e5%b9%b6%e5%8f%91gc%e5%a6%82%e4%bd%95%e7%bc%93%e8%a7%a3%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%8e%8b%e5%8a%9b>#</a></h4><ul><li>借贷偿还机制。也可以偷。</li></ul><h1 id=总结>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93>#</a></h1><h2 id=为什么golang需要gc>为什么golang需要GC
<a class=anchor href=#%e4%b8%ba%e4%bb%80%e4%b9%88golang%e9%9c%80%e8%a6%81gc>#</a></h2><blockquote><h3 id=what>what:
<a class=anchor href=#what>#</a></h3></blockquote><ul><li>gc主要是释放那些不再需要的分配在堆（heap）上的数据</li></ul><blockquote><h3 id=why>why:
<a class=anchor href=#why>#</a></h3></blockquote><ul><li>降低人的心智负担，从堆（heap）中申请的内存，不需要手动的释放。</li></ul><blockquote><h3 id=how>how:
<a class=anchor href=#how>#</a></h3></blockquote><ul><li>一般判断对象是否存活是使用：是把可达性近视的认为存活性.<ul><li>可把栈（stack），数据段（data segment? bss?）的数据对象作为root</li></ul></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><script src=https://giscus.app/client.js data-repo=zput/utterances-comments data-repo-id=R_kgDOHhATGQ data-category=Announcements data-category-id=DIC_kwDOHhATGc4CPxca data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=1 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#1-前言变量的存放区>1 前言：变量的存放区</a></li><li><a href=#2-定义>2 定义</a><ul><li><a href=#21-垃圾识别>2.1 垃圾识别</a><ul><li><a href=#211-双色标记法>2.1.1 双色标记法</a></li><li><a href=#212-三色标记法>2.1.2 三色标记法</a></li></ul></li></ul></li><li><a href=#3-golang垃圾回收>3 golang垃圾回收</a><ul><li><a href=#31-三色标记法>3.1 三色标记法</a></li><li><a href=#32-总体流程>3.2 总体流程</a><ul><li><a href=#321-第一次stw>3.2.1 第一次STW</a><ul><li><a href=#预生成标记协程>预生成标记协程</a></li><li><a href=#控制标记协程的cpu利用率>控制标记协程的CPU利用率</a></li></ul></li><li><a href=#322-标记阶段>3.2.2 标记阶段</a><ul><li><a href=#调度标记协程>调度标记协程</a></li><li><a href=#标记协程>标记协程</a></li><li><a href=#3221-中止标记协程>3.2.2.1 中止标记协程</a></li><li><a href=#3221-扫描根对象>3.2.2.1 扫描根对象</a></li><li><a href=#3223-标记堆对象>3.2.2.3 标记堆对象</a></li><li><a href=#置黑新分配对象>置黑新分配对象</a></li><li><a href=#辅助标记>辅助标记</a></li></ul></li><li><a href=#323-第二次stw>3.2.3 第二次STW</a><ul><li><a href=#标记终止>标记终止</a></li><li><a href=#3231唤醒清扫协程>3.2.3.1.唤醒清扫协程</a></li><li><a href=#3231-清扫工作>3.2.3.1. 清扫工作</a></li></ul></li><li><a href=#324-清扫阶段>3.2.4 清扫阶段</a></li><li><a href=#xx>xx</a></li></ul></li><li><a href=#并发标记的分工问题写屏障记录集的竞争问题>并发标记的分工问题？写屏障记录集的竞争问题？</a></li></ul></li><li><a href=#fqa>FQA</a><ul><li><a href=#为什么gc也要扫描栈不是都在堆上面吗>为什么gc也要扫描栈，不是都在堆上面吗？</a></li><li><a href=#混合写屏障>混合写屏障</a></li><li><a href=#golang中gc支持增量与并发式回收怎么理解>Golang中GC支持增量与并发式回收怎么理解</a></li><li><a href=#为什么清扫阶段不需要屏障了呢>为什么清扫阶段不需要屏障了呢？</a><ul><li><ul><li><a href=#todo-并发gc如何缓解内存分配压力>TODO: 并发GC如何缓解内存分配压力？</a></li></ul></li></ul></li></ul></li><li><a href=#总结>总结</a><ul><li><a href=#为什么golang需要gc>为什么golang需要GC</a><ul><li><a href=#what>what:</a></li><li><a href=#why>why:</a></li><li><a href=#how>how:</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html><script type=text/javascript src=https://cdn.bootcss.com/viz.js/1.8.2/viz.js></script><script type=text/javascript>(function(){var e="language-viz-";Array.prototype.forEach.call(document.querySelectorAll("[class^="+e+"]"),function(t){console.log(t),t.getAttribute("class").split(" ").forEach(function(t){t.startsWith(e)&&(s=t.substr(e.length))}),console.log("------------MIDDLE--------");var s,o=Viz(t.innerText,{format:"svg",engine:s}),n=(new DOMParser).parseFromString(o,"image/svg+xml");n.documentElement.setAttribute("style","max-width:100%; max-height:100%;"),t.parentNode.insertBefore(n.documentElement,t),t.style.display="none",t.parentNode.style.backgroundColor="white",t.style.width=n.documentElement.getAttribute("width")+"px",t.style.height=n.documentElement.getAttribute("height")+"px",console.log("--------------END------")})})()</script>