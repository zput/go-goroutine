<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>堆分配原理 on go调度源码分析</title><link>https://zput.github.io/go-goroutine/docs/runtime/heap/</link><description>Recent content in 堆分配原理 on go调度源码分析</description><generator>Hugo -- gohugo.io</generator><language>zh</language><atom:link href="https://zput.github.io/go-goroutine/docs/runtime/heap/index.xml" rel="self" type="application/rss+xml"/><item><title>概述</title><link>https://zput.github.io/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/1_summarize/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/1_summarize/</guid><description>分配一个对象，mutator -&amp;gt; Allocator -&amp;gt; heap分类，从横向来看，可分为线性与链表形式;其中链表又可以分为：首次适应，循环首次适应，最优适应和预先隔离适应。 从纵向来看，可以分为单级与多级。
而golang混合纵向的多级,而各级横向结构有线性形式，也有链表的形式。分配某一对象，按照其大小涉及到的层级不同，可分为微小对象，小对象，大对象三类。
当需要分配这三类对象时，从下面的对应的结构中开始分配
tiny --&amp;gt; 微小对象 mcache ---&amp;gt; 小对象 mcentralList heapArenasList ---&amp;gt; 大对象 sequential allocation 的实现方式非常简单，只需要把维护的空间直接分配出去就好，每次分配以后挪动指针，指向剩余空闲的位置的首地址，runtime off-heap object allocator一节中介绍的persistent allocator采用的就是sequential allocation这个方式。sequential allocation这种分配方式的缺点是不能直接回收，得配合特定的垃圾回收算法，比如semispace copying collection，这种垃圾回收算法把堆划分成两份，当一份分配完以后，把仍然有用的对象拷贝到另外半个堆中，这样没有用的对象的空间就被回收了，分配空间继续在另外半个堆进行，当满了以后再拷贝有用的对象回到原来的半个堆中。
free list allocation 这种分配方式相对sequential allocation这种方式没能更好的利用上缓存的空间局部性原理，并且分配的时候速度慢，虽然有first fit 、next fit、best fit三种寻找空闲块的策略 ，但是多少还是会造成外部碎片。但是free list allocation 可以支持立马把释放的空间放到list中用于后续的分配。
segregated-fix allocation 是属于fee list allocation的一种细分
func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer { //... if size &amp;lt;= maxSmallSize { if noscan &amp;amp;&amp;amp; size &amp;lt; maxTinySize { // 微对象分配 } else { // 小对象分配 } } else { // 大对象分配 largeAlloc } //.</description></item><item><title>分配大对象</title><link>https://zput.github.io/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_big_object/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_big_object/</guid><description>分配大对象会涉及到的三个部分：栈/块/区</description></item><item><title>概述</title><link>https://zput.github.io/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_middle_object/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_middle_object/</guid><description>看下这个调用图
digraph cacheSpan { rankdir=TB; node[shape=box]; start[label=&amp;#34;开始&amp;#34;]; end[label=&amp;#34;结束&amp;#34;]; sg[label=&amp;#34;获取当前 sweepgen 值&amp;#34;]; nonempty[label=&amp;#34;遍历非空 span 列表&amp;#34;]; sweepgen[label=&amp;#34;如果内存单元的 sweepgen 等于 mheap.sweepgen - 2， 那么意味着当前单元需要清理 \n如果等于 mheap.sweepgen - 1，那么当前管理单元就正在清理&amp;#34;;shape=plain; ] empty[label=&amp;#34;遍历空 span 列表&amp;#34;]; sweep[label=&amp;#34;清理 span 并将其添加到空 span 列表&amp;#34;]; free[label=&amp;#34;释放部分空间&amp;#34;]; grow[label=&amp;#34;创建新的 span 并添加到空 span 列表&amp;#34;]; cache[label=&amp;#34;重新填充 span 的分配缓存&amp;#34;]; have[label=&amp;#34;返回 span 指针&amp;#34;]; // 处理mspan subgraph cluster_span { style = dotted margin = 10 &amp;#34;块(span)&amp;#34; [shape = plaintext;fontsize = 24] &amp;#34;mheap.alloc_m&amp;#34; &amp;#34;notice1&amp;#34; [shape=plain;label=&amp;#34;在这里才设置mspan中的spanclass&amp;#34;] {rank=same; &amp;#34;notice1&amp;#34; -&amp;gt; &amp;#34;mheap.alloc_m&amp;#34;[dir=none]; } } start -&amp;gt; sg; {rank=same; sweepgen -&amp;gt; nonempty[style=invis];} sg -&amp;gt; nonempty -&amp;gt; sweep -&amp;gt; empty -&amp;gt; free -&amp;gt; have; nonempty -&amp;gt; empty; empty -&amp;gt; grow -&amp;gt; cache -&amp;gt; have; have-&amp;gt;end; } mcentral中有六个mspan列表，分别是:</description></item><item><title>概述</title><link>https://zput.github.io/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_small_object/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_small_object/</guid><description>off是tiny Allocator的偏移指针，根据将要分配的内存大小，需调整off。如果size是8的倍数，则调用round(off,8)函数将off向上舍入到8的倍数。否则，如果size是4的倍数，则调用round(off,4)函数将off向上舍入到4的倍数。最后，如果size是2的倍数，则调用round(off,2)函数将off舍入到2的倍数。
off := c.tinyoffset // Align tiny pointer for required (conservative) alignment. if size&amp;amp;7 == 0 { off = round(off, 8) } else if size&amp;amp;3 == 0 { off = round(off, 4) } else if size&amp;amp;1 == 0 { off = round(off, 2) } 验证如下，需要调整的都会打印出来
===&amp;gt;原始: off:1, size:2 | 调整后: off:2, size:2 &amp;lt;===2倍数 // https://go.dev/play/p/1fl_cnJNwD- package main import ( &amp;#34;fmt&amp;#34; ) func main() { for i := 0; i &amp;lt; 16; i++ { for j := 1; j &amp;lt; 16; j++ { tmpOff, tmpSize := Size(i, j) if i !</description></item><item><title>概述</title><link>https://zput.github.io/go-goroutine/docs/runtime/heap/ch1_prespective_of_system_buttom/off_heap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/heap/ch1_prespective_of_system_buttom/off_heap/</guid><description/></item><item><title>概述</title><link>https://zput.github.io/go-goroutine/docs/runtime/heap/ch1_prespective_of_system_buttom/on_heap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/heap/ch1_prespective_of_system_buttom/on_heap/</guid><description/></item></channel></rss>