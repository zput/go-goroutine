<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>堆分配原理 on go调度源码分析</title><link>https://zput.github.io/go-goroutine/docs/runtime/heap/</link><description>Recent content in 堆分配原理 on go调度源码分析</description><generator>Hugo -- gohugo.io</generator><language>zh</language><atom:link href="https://zput.github.io/go-goroutine/docs/runtime/heap/index.xml" rel="self" type="application/rss+xml"/><item><title>概述</title><link>https://zput.github.io/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/1_summarize/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/1_summarize/</guid><description>分配一个对象，mutator -&amp;gt; Allocator -&amp;gt; heap分类，从横向来看，可分为线性与链表形式;其中链表又可以分为：首次适应，循环首次适应，最优适应和预先隔离适应。 从纵向来看，可以分为单级与多级。
而golang混合纵向的多级,而各级横向结构有线性形式，也有链表的形式。分配某一对象，按照其大小涉及到的层级不同，可分为微小对象，小对象，大对象三类。
当需要分配这三类对象时，从下面的对应的结构中开始分配
tiny --&amp;gt; 微小对象 mcache ---&amp;gt; 小对象 mcentralList heapArenasList ---&amp;gt; 大对象 sequential allocation 的实现方式非常简单，只需要把维护的空间直接分配出去就好，每次分配以后挪动指针，指向剩余空闲的位置的首地址，runtime off-heap object allocator一节中介绍的persistent allocator采用的就是sequential allocation这个方式。sequential allocation这种分配方式的缺点是不能直接回收，得配合特定的垃圾回收算法，比如semispace copying collection，这种垃圾回收算法把堆划分成两份，当一份分配完以后，把仍然有用的对象拷贝到另外半个堆中，这样没有用的对象的空间就被回收了，分配空间继续在另外半个堆进行，当满了以后再拷贝有用的对象回到原来的半个堆中。
free list allocation 这种分配方式相对sequential allocation这种方式没能更好的利用上缓存的空间局部性原理，并且分配的时候速度慢，虽然有first fit 、next fit、best fit三种寻找空闲块的策略 ，但是多少还是会造成外部碎片。但是free list allocation 可以支持立马把释放的空间放到list中用于后续的分配。
segregated-fix allocation 是属于fee list allocation的一种细分
func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer { //... if size &amp;lt;= maxSmallSize { if noscan &amp;amp;&amp;amp; size &amp;lt; maxTinySize { // 微对象分配 } else { // 小对象分配 } } else { // 大对象分配 } //.</description></item><item><title>概述</title><link>https://zput.github.io/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_big_object/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_big_object/</guid><description>https://miloyip.github.io/graphvizuml/graphvizuml.pdf
rankdir确定整个图的layout走向，在其他位置不生效
https://graphviz.org/docs/attrs/rankdir/ 如果想要在layout中的走向是TOP-BUTTOM，中指定从左到右的效果，使用rank{rank=same; growS1-&amp;gt;growS2; growS2-&amp;gt;growS3;}
constraint=false在不同级别中起作用；作用范围edges
在等级分配期间，边的头部节点被约束为比尾节点处于更高的等级。但是，如果边具有constraint=false，则不会强制执行此要求。 基于上面的陈述，(我猜) constraint = false选项在不同的等级之间生效，而不是在同一等级中生效。 简言之它作用与边，当为false，就相当于这条边的两个节点没有连接在一起，它们的顺序(rank)被其他的边关系影响。 https://cloud.tencent.com/developer/ask/sof/60940 https://www.coder.work/article/6490069 https://graphviz.org/docs/attrs/constraint/ Mrecord
对我来说，子图和集群是非常不同的东西 集群本身更像是迷你图 子图更像是具有共同属性的节点集，这些节点可能（也可能不）定位在一起 仅供参考，将节点定位在您想要的位置（而不是点想要的位置）可能具有挑战性，但通常您可以做到。将集群定位在您想要的位置通常~是不可能的。我通常使用 gvpr 程序对点输出进行后处理以定位集群。
https://graphviz.org/doc/char.html digraph { compound=true fontsize=10 margin=&amp;#34;0,0&amp;#34; ranksep = .15 nodesep = .06 node [shape=ellipse fontname=&amp;#34;Inconsolata, Consolas&amp;#34;, fontsize=12, penwidth=0.5; constraint=false] edge [fontname=&amp;#34;Inconsolata, Consolas&amp;#34;, fontsize=10, arrowhead=normal] // 栈区 subgraph cluster_stack { style = dotted margin = 10 &amp;#34;栈(包括系统栈)&amp;#34; [shape = plaintext; fontsize = 24;] &amp;#34;largeAlloc&amp;#34;; &amp;#34;Alloc&amp;#34;; &amp;#34;notice2&amp;#34; [shape=plain;label=&amp;#34;系统栈执行;\n初始化申请的内存&amp;#34;] {rank=same; &amp;#34;notice2&amp;#34; -&amp;gt; &amp;#34;Alloc&amp;#34;[dir=none]; } } // 处理mspan subgraph cluster_span { style = dotted margin = 10 &amp;#34;块(span)&amp;#34; [shape = plaintext;fontsize = 24] &amp;#34;mheap.</description></item><item><title>概述</title><link>https://zput.github.io/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_middle_object/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_middle_object/</guid><description> stateDiagram-v2 State1: The state with a note note right of State1 Important information! You can write notes. end note State1 --> State2 note left of State2 : This is the note to the left.</description></item><item><title>概述</title><link>https://zput.github.io/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_small_object/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_small_object/</guid><description/></item><item><title>概述</title><link>https://zput.github.io/go-goroutine/docs/runtime/heap/ch1_prespective_of_system_buttom/off_heap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/heap/ch1_prespective_of_system_buttom/off_heap/</guid><description/></item><item><title>概述</title><link>https://zput.github.io/go-goroutine/docs/runtime/heap/ch1_prespective_of_system_buttom/on_heap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/heap/ch1_prespective_of_system_buttom/on_heap/</guid><description/></item></channel></rss>