<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="struct mm_struct: memory manage struct vm_area_struct: vma: Virtual memory area
#include <fcntl.h> #include <stdio.h> #include <stdlib.h> #include <sys/mman.h> #include <sys/stat.h> #include <unistd.h> #define handle_error(msg) \ do { perror(msg); exit(EXIT_FAILURE); } while (0) int main(int argc, char *argv[]) { int fd; char *addr; off_t offset, pa_offset; size_t length; ssize_t s; struct stat sb; if (argc < 3 || argc > 4) { fprintf(stderr, &#34;%s file offset [length]\n&#34;, argv[0]); exit(EXIT_FAILURE); } fd = open(argv[1], O_RDONLY); if (fd == -1) handle_error(&#34;open&#34;); if (fstat(fd, &amp;sb) == -1) /* To obtain file size */ handle_error(&#34;fstat&#34;); offset = atoi(argv[2]); pa_offset = offset & ~(sysconf(_SC_PAGE_SIZE) - 1); /* offset for mmap() must be page aligned */ if (offset >= sb."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="内存分配器"><meta property="og:description" content="struct mm_struct: memory manage struct vm_area_struct: vma: Virtual memory area
#include <fcntl.h> #include <stdio.h> #include <stdlib.h> #include <sys/mman.h> #include <sys/stat.h> #include <unistd.h> #define handle_error(msg) \ do { perror(msg); exit(EXIT_FAILURE); } while (0) int main(int argc, char *argv[]) { int fd; char *addr; off_t offset, pa_offset; size_t length; ssize_t s; struct stat sb; if (argc < 3 || argc > 4) { fprintf(stderr, &#34;%s file offset [length]\n&#34;, argv[0]); exit(EXIT_FAILURE); } fd = open(argv[1], O_RDONLY); if (fd == -1) handle_error(&#34;open&#34;); if (fstat(fd, &amp;sb) == -1) /* To obtain file size */ handle_error(&#34;fstat&#34;); offset = atoi(argv[2]); pa_offset = offset & ~(sysconf(_SC_PAGE_SIZE) - 1); /* offset for mmap() must be page aligned */ if (offset >= sb."><meta property="og:type" content="article"><meta property="og:url" content="https://zput.github.io/go-goroutine/docs/runtime/golang_memery/"><meta property="article:section" content="docs"><title>内存分配器 | go调度源码分析</title><link rel=manifest href=/go-goroutine/manifest.json><link rel=icon href=/go-goroutine/favicon.png type=image/x-icon><link rel=stylesheet href=/go-goroutine/book.min.76f6dbe75c94e688c018dd8b54e7f880916b14ab4cf3881b81f75d6bb916603c.css integrity="sha256-dvbb51yU5ojAGN2LVOf4gJFrFKtM84gbgfdda7kWYDw=" crossorigin=anonymous><script defer src=/go-goroutine/flexsearch.min.js></script>
<script defer src=/go-goroutine/en.search.min.e1a4b554d223f90296fe2920e09f6b6a92f2d5a6bf583a1d66005a682c8f0a1f.js integrity="sha256-4aS1VNIj+QKW/ikg4J9rapLy1aa/WDodZgBaaCyPCh8=" crossorigin=anonymous></script>
<script defer src=/go-goroutine/sw.min.ec96d6e09af3075a94dd4de723a2edddf2ef138381c7e1e5b5a1f2c0578ee8bd.js integrity="sha256-7JbW4JrzB1qU3U3nI6Lt3fLvE4OBx+HltaHywFeO6L0=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/go-goroutine/><span>go调度源码分析</span></a></h2><div class=magic><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><div class=book-switch><label class=switch><input id=dark-mode-checkbox type=checkbox onchange=darkmode()>
<span class=slider></span></label></div></div><ul><li><a href=https://zput.github.io target=_blank rel=noopener>Zput博客</a></li><li><a href=https://github.com/zput target=_blank rel=noopener>GitHub</a></li></ul><hr><ul><li><span>基础知识</span><ul><li><a href=/go-goroutine/docs/foundation/golang_basic/>基本用法</a></li><li><a href=/go-goroutine/docs/foundation/slice/>slice</a></li><li><a href=/go-goroutine/docs/foundation/map/>map</a></li><li><a href=/go-goroutine/docs/foundation/sort/>sort</a></li><li><a href=/go-goroutine/docs/foundation/directory/>Directory</a></li></ul></li><li><span>鲁棒和性能</span><ul><li><a href=/go-goroutine/docs/robustness_and_performance/golang_test/>测试相关函数</a></li></ul></li><li><span>运行时</span><ul><li><a href=/go-goroutine/docs/runtime/golang_gmp/>GMP</a></li><li><span>堆分配原理</span><ul><li><a href=/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/1_summarize/>概述</a></li><li><a href=/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_big_object/>概述</a></li></ul></li><li><a href=/go-goroutine/docs/runtime/complement-source-reverse/>源码-反码-补码</a></li><li><a href=/go-goroutine/docs/runtime/golang_memery/ class=active>内存分配器</a></li><li><a href=/go-goroutine/docs/runtime/golang_gc/>垃圾回收</a></li><li><a href=/go-goroutine/docs/runtime/schedule/>调度</a><ul><li><span>前置知识</span><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/memory/>内存大小端</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/register_functionstack/>伪寄存器与函数栈帧</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/similar_assemble/>类汇编</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/go_underlying_struct/>底层重要结构</a></li></ul></li><li><a href=/go-goroutine/docs/runtime/schedule/2_init_before_enter_main_function/>初始化</a></li><li><a href=/go-goroutine/docs/runtime/schedule/3_exit_goroutine/>退出</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/>调度挑选策略</a><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/take_goroutine_from_globalorlocal_p/>从全局/本P队列</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/steal_goroutine_from_other_p/>从其他P队列</a></li></ul></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/>调度到达时机</a><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/active_scheduling/>主动调度</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/passive_scheduling/>被动调度</a></li><li><input type=checkbox id=section-99f41010918d678e89a7af90330cabe1 class=toggle>
<label for=section-99f41010918d678e89a7af90330cabe1 class="flex justify-between"><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/>剥夺调度</a></label><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/start_sysmon/>开启系统监控</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/user_code_preemption/>代码执行过久</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/system_call_preemption/>陷入系统调用</a></li></ul></li></ul></li></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script><script src=/go-goroutine/magic.js></script>
<script src=/go-goroutine/dark.js></script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/go-goroutine/svg/menu.svg class=book-icon alt=Menu></label>
<strong>内存分配器</strong>
<label for=toc-control><img src=/go-goroutine/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#treap>treap</a></li><li><a href=#p>P</a></li><li><a href=#areahint>areaHint</a></li><li><a href=#areas>areas</a></li><li><a href=#nextfreefast>nextFreeFast</a></li><li><a href=#arm64>arm64</a></li><li><a href=#结构>结构</a></li><li><a href=#堆内存的数据结构>堆内存的数据结构</a><ul><li><a href=#mheap>mheap</a></li></ul></li><li><a href=#heaparena>heaparena</a><ul><li><a href=#mspan>mspan</a><ul><li><a href=#heaparena-1>heapArena</a></li><li><a href=#span>span</a></li></ul></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><p>struct mm_struct: memory manage
struct vm_area_struct: vma: Virtual memory area</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;fcntl.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/mman.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/stat.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define handle_error(msg) \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    do { perror(msg); exit(EXIT_FAILURE); } while (0)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>argv[])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span>          fd;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span>         <span style=color:#f92672>*</span>addr;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>off_t</span>        offset, pa_offset;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span>       length;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>ssize_t</span>      s;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> stat  sb;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>||</span> argc <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>4</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fprintf</span>(stderr, <span style=color:#e6db74>&#34;%s file offset [length]</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, argv[<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>exit</span>(EXIT_FAILURE);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    fd <span style=color:#f92672>=</span> <span style=color:#a6e22e>open</span>(argv[<span style=color:#ae81ff>1</span>], O_RDONLY);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (fd <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>handle_error</span>(<span style=color:#e6db74>&#34;open&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>fstat</span>(fd, <span style=color:#f92672>&amp;</span>sb) <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)           <span style=color:#75715e>/* To obtain file size */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>handle_error</span>(<span style=color:#e6db74>&#34;fstat&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    offset <span style=color:#f92672>=</span> <span style=color:#a6e22e>atoi</span>(argv[<span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>    pa_offset <span style=color:#f92672>=</span> offset <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>(<span style=color:#a6e22e>sysconf</span>(_SC_PAGE_SIZE) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* offset for mmap() must be page aligned */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (offset <span style=color:#f92672>&gt;=</span> sb.st_size) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fprintf</span>(stderr, <span style=color:#e6db74>&#34;offset is past end of file</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>exit</span>(EXIT_FAILURE);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>==</span> <span style=color:#ae81ff>4</span>) {
</span></span><span style=display:flex><span>        length <span style=color:#f92672>=</span> <span style=color:#a6e22e>atoi</span>(argv[<span style=color:#ae81ff>3</span>]);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (offset <span style=color:#f92672>+</span> length <span style=color:#f92672>&gt;</span> sb.st_size)
</span></span><span style=display:flex><span>            length <span style=color:#f92672>=</span> sb.st_size <span style=color:#f92672>-</span> offset;
</span></span><span style=display:flex><span>                <span style=color:#75715e>/* Can&#39;t display bytes past end of file */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {    <span style=color:#75715e>/* No length arg ==&gt; display to end of file */</span>
</span></span><span style=display:flex><span>        length <span style=color:#f92672>=</span> sb.st_size <span style=color:#f92672>-</span> offset;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    addr <span style=color:#f92672>=</span> <span style=color:#a6e22e>mmap</span>(NULL, length <span style=color:#f92672>+</span> offset <span style=color:#f92672>-</span> pa_offset, PROT_READ,
</span></span><span style=display:flex><span>                MAP_PRIVATE, fd, pa_offset);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (addr <span style=color:#f92672>==</span> MAP_FAILED)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>handle_error</span>(<span style=color:#e6db74>&#34;mmap&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    s <span style=color:#f92672>=</span> <span style=color:#a6e22e>write</span>(STDOUT_FILENO, addr <span style=color:#f92672>+</span> offset <span style=color:#f92672>-</span> pa_offset, length);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (s <span style=color:#f92672>!=</span> length) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (s <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>handle_error</span>(<span style=color:#e6db74>&#34;write&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fprintf</span>(stderr, <span style=color:#e6db74>&#34;partial write&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>exit</span>(EXIT_FAILURE);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>munmap</span>(addr, length <span style=color:#f92672>+</span> offset <span style=color:#f92672>-</span> pa_offset);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>close</span>(fd);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>exit</span>(EXIT_SUCCESS);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;fcntl.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/mman.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/stat.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define handle_error(msg) \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    do { perror(msg); exit(EXIT_FAILURE); } while (0)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>argv[])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>v<span style=color:#f92672>=</span><span style=color:#ae81ff>0x7f216f308000</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>
</span></span><span style=display:flex><span>	p :<span style=color:#f92672>=</span> <span style=color:#a6e22e>mmap</span>(v, n, PROT_NONE, MAP_ANON<span style=color:#f92672>|</span>MAP_PRIVATE, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (p <span style=color:#f92672>==</span> MAP_FAILED)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>handle_error</span>(<span style=color:#e6db74>&#34;mmap&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>munmap</span>(addr, <span style=color:#ae81ff>20</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>exit</span>(EXIT_SUCCESS);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=treap>treap
<a class=anchor href=#treap>#</a></h2><p><a href=https://go.dev/play/p/Ya7VlebyNw7>https://go.dev/play/p/Ya7VlebyNw7</a></p><h2 id=p>P
<a class=anchor href=#p>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/runtime2.go#L576
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>p</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>id</span>          <span style=color:#66d9ef>int32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>status</span>      <span style=color:#66d9ef>uint32</span> <span style=color:#75715e>// one of pidle/prunning/...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>link</span>        <span style=color:#a6e22e>puintptr</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>schedtick</span>   <span style=color:#66d9ef>uint32</span>     <span style=color:#75715e>// incremented on every scheduler call
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>syscalltick</span> <span style=color:#66d9ef>uint32</span>     <span style=color:#75715e>// incremented on every system call
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>sysmontick</span>  <span style=color:#a6e22e>sysmontick</span> <span style=color:#75715e>// last tick observed by sysmon
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>m</span>           <span style=color:#a6e22e>muintptr</span>   <span style=color:#75715e>// back-link to associated m (nil if idle)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>mcache</span>      <span style=color:#f92672>*</span><span style=color:#a6e22e>mcache</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pcache</span>      <span style=color:#a6e22e>pageCache</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>raceprocctx</span> <span style=color:#66d9ef>uintptr</span>
</span></span></code></pre></div><p>pageCache</p><p><a href=https://zhuanlan.zhihu.com/p/487455942>https://zhuanlan.zhihu.com/p/487455942</a></p><h2 id=areahint>areaHint
<a class=anchor href=#areahint>#</a></h2><p>src/runtime/malloc.go:434</p><p><a href=https://go.dev/play/p/brDHCCSwCoI>https://go.dev/play/p/brDHCCSwCoI</a></p><pre tabindex=0><code>0x00007FFF FFFFFFFF
</code></pre><pre tabindex=0><code>p:0x00007f0130000000
p:7e0130000000
===================10000000000
p:7d0130000000
===================10000000000
p:7c0130000000
</code></pre><p>从上面可以看出，系统是从下半段区域开始扩展的，至于原因：在 64 位机器上，Go 选择从内存地址空间的中间开始分配堆内存，目的是避免和其他映射冲突，并且使得在调试时 Go 堆内存地址更容易识别。同时，在 gccgo 等编译器中，栈扫描仍然是保守的，这意味着要确保内存地址与其他数据区分开来。</p><p><a href="https://go.dev/play/p/yuEbw87oeLP?v=goprev">https://go.dev/play/p/yuEbw87oeLP?v=goprev</a>
<a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;mid=2247486732&amp;idx=1&amp;sn=435d5e834e9751036c96384f6965b328&amp;chksm=ce77cb4bf900425d33d2adfa632a4684cf7a63beece166c1ffedc4fdacb807c9413e8c73f298&amp;scene=178&amp;cur_album_id=2559805446807928833#rd">https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247486732&idx=1&sn=435d5e834e9751036c96384f6965b328&chksm=ce77cb4bf900425d33d2adfa632a4684cf7a63beece166c1ffedc4fdacb807c9413e8c73f298&scene=178&cur_album_id=2559805446807928833#rd</a>
<img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20230817213504.png alt=20230817213504></p><h2 id=areas>areas
<a class=anchor href=#areas>#</a></h2><p>对于那些不由 Go 堆支持的地址空间区域，arena 映射表包含 nil</p><pre tabindex=0><code>arenas [1 &lt;&lt; arenaL1Bits]*[1 &lt;&lt; arenaL2Bits]*heapArena
</code></pre><hr><pre tabindex=0><code>
获取其所在 L2 映射； 如果 L2 映射不存在，则创建一个新的 L2 映射。
检查该 arena 是否已经初始化； 如果已经初始化，则抛出异常。
为该 arena 分配元数据； 如果从 heapArenaAlloc 分配失败，则使用 persistentalloc 进行分配。
将该 arena 添加到 allArenas 列表中； 如果 allArenas 列表已满，则分配一个新的更大的 backing array。
</code></pre><h2 id=nextfreefast>nextFreeFast
<a class=anchor href=#nextfreefast>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#75715e>// nextFreeFast returns the next free object if one is quickly available.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Otherwise it returns 0.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>nextFreeFast</span>(<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span>) <span style=color:#a6e22e>gclinkptr</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>theBit</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sys</span>.<span style=color:#a6e22e>Ctz64</span>(<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>allocCache</span>) <span style=color:#75715e>// Is there a free object in the allocCache?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>theBit</span> &lt; <span style=color:#ae81ff>64</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>result</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>freeindex</span> <span style=color:#f92672>+</span> uintptr(<span style=color:#a6e22e>theBit</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>result</span> &lt; <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>nelems</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>freeidx</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>result</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>freeidx</span><span style=color:#f92672>%</span><span style=color:#ae81ff>64</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>freeidx</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>nelems</span> {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>allocCache</span> <span style=color:#f92672>&gt;&gt;=</span> uint(<span style=color:#a6e22e>theBit</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>freeindex</span> = <span style=color:#a6e22e>freeidx</span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>allocCount</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>gclinkptr</span>(<span style=color:#a6e22e>result</span><span style=color:#f92672>*</span><span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>elemsize</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>base</span>())
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=https://go.dev/play/p/MrAAyDAassZ>https://go.dev/play/p/MrAAyDAassZ</a></p><h2 id=arm64>arm64
<a class=anchor href=#arm64>#</a></h2><p><a href=https://www.zhihu.com/question/28638698>https://www.zhihu.com/question/28638698</a></p><pre tabindex=0><code>16 8  4  2  1
1  1  1  1  1
</code></pre><p>5位的系统，只使用了4位的虚拟地址，所以虚拟空间只是占用两头，而中间没有使用到,总共占用<code>2^4=16</code>个地址空间。</p><pre tabindex=0><code>11111
11110
11101
11100
11011
11010
11001
11000
-----
10111
.....
01000
-----
00111
00110
00101
00100
00011
00010
00001
00000
</code></pre><pre tabindex=0><code>+--------------------+   111      
|                    |            
|                    |            
|                    |            
|                    |            
|                    |            
|                    |            
|                    |            
|--------------------| 11000      
|                    |            
|                    |            
|                    |            
|                    |            
|                    |            
|                    |            
|                    |            
|                    |            
|                    |            
|                    |            
|                    |            
|                    |            
|                    |            
|                    |            
|                    |            
|--------------------- 00111      
|                    |            
|                    |            
|                    |            
|                    |            
|                    |            
|                    |            
|                    |            
+--------------------+            
</code></pre><p>需要把这两块地址空间串联起来，高位地址空间距离<code>00000</code>的偏移量为<code>11000</code>，所以减去11000(非符号位取反+1,符号位不变;注意这里没有符号位，00111+1=01000);从而得到两块地址空间如下：</p><pre tabindex=0><code>00111
00110
00101
00100
00011
00010
00001
00000

01111
01110
01101
01100
01011
01010
01001
01000
</code></pre><p>其实我们应该换个角度来看问题，还记得计算机组成原理里面无处不在的局部性原理么？</p><p>每个进程都有 4GB 的虚拟地址空间，而显然对于大多数程序来说，其使用到的空间远未达到 4GB，因为会存在部分对应的页表项都是空的，根本没有分配，对于已分配的页表项，如果存在最近一定时间未访问的页表，在物理内存紧张的情况下，操作系统会将页面换出到硬盘，也就是说不会占用物理内存。</p><p>如果使用了二级分页，一级页表就可以覆盖整个 4GB 虚拟地址空间，但如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表。做个简单的计算，假设只有 20% 的一级页表项被用到了，那么页表占用的内存空间就只有 4KB（一级页表） + 20% * 4MB（二级页表）= 0.804MB，这对比单级页表的 4MB 是不是一个巨大的节约？</p><p>那么为什么不分级的页表就做不到这样节约内存呢？</p><p>我们从页表的性质来看，保存在内存中的页表承担的职责是将虚拟地址翻译成物理地址。假如虚拟地址在页表中找不到对应的页表项，计算机系统就不能工作了。所以页表一定要覆盖全部虚拟地址空间，不分级的页表就需要有 100 多万个页表项来映射，而二级分页则只需要 1024 个页表项（此时一级页表覆盖到了全部虚拟地址空间，二级页表在需要时创建）。</p><h2 id=结构>结构
<a class=anchor href=#%e7%bb%93%e6%9e%84>#</a></h2><p>on-heap 和 off-heap 的区别是这个对象占用的内存是否支持垃圾自动回收</p><p>off-heap的对象，必须只能手动管理，比如heapArena，mspan等runtime中的数据结构</p><pre tabindex=0><code>type mheap struct {
	_ sys.NotInHeap

	// lock must only be acquired on the system stack, otherwise a g
	// could self-deadlock if its stack grows with the lock held.
	lock mutex

	pages pageAlloc // page allocation data structure
</code></pre><p>pageAlloc：页面分配器把<strong>整个虚拟地址空间</strong>划分（假想的）成一个个8KB对齐的大小为8KB的页面，分配器采用位图管理页面分配情况。因为虚拟地址空间过于庞大，所以对位图做了划分，每512个页面，使用一个位图。</p><p><a href=https://github.com/golang/go/blob/fe10464358057778732e9c958683039beb64e61a/src/runtime/mpagealloc.go#L179>https://github.com/golang/go/blob/fe10464358057778732e9c958683039beb64e61a/src/runtime/mpagealloc.go#L179</a></p><hr><pre tabindex=0><code>2^13 * sizeof(pallocData)
</code></pre><pre tabindex=0><code>2^13*(16*8)=2^13*128=2^(13+7)=2^20=1M
</code></pre><pre tabindex=0><code>2^13*2^13*512*8*2^10=256*2^40=2^48=256T
</code></pre><p>由于每个 runtime.heapArena 都会管理 64MB 的内存，整个堆区最多可以管理 256TB 的内存，这比之前的 512GB 多好几个数量级。</p><p>mheap.allocSpan函数利用pageAlloc来分配mspan
都是在mspan的基础之上来进一步分配的;</p><p>golang对象分配采用的是:</p><ul><li>sequential allocation<ul><li>sequential allocation 的实现方式非常简单，只需要把维护的空间直接分配出去就好，每次分配以后挪动指针，指向剩余空闲的位置的首地址，runtime off-heap object allocator一节中介绍的<code>persistent allocator</code>采用的就是sequential allocation这个方式。</li></ul></li><li>free-list allocation<ul><li>free list allocation 这种分配方式相对sequential allocation这种方式没能更好的利用上缓存的空间局部性原理，并且分配的时候速度慢，虽然有first fit 、next fit、best fit三种寻找空闲块的策略 ，但是多少还是会造成外部碎片。但是free list allocation 可以支持立马把释放的空间放到list中用于后续的分配。</li></ul></li><li>segregated-fit allocator<ul><li>设置K个size class ，各自的大小是s1,s2&mldr;sk (从小到大排队)，当程序需要S大小空间的时候，给其分配sn这么多的空间(<code>sn&lt;=S&lt;sn+1</code>)，每种size class都有一个分配器，专门分配这个大小，这样相比 free list allocation 可以免去寻找合适内存块的过程。但是会造成更多的浪费，因为对象的大小不一定正好等于slot的大小。调整size class 的个数和每个的大小是减少浪费的关键。</li><li>segregated-fit allocation 还有一个好处是可以非常方便的处理指向对象内部的指针，这可以为垃圾回收提供便利，对于任何一个指针，可以很轻松的找到这个指针所指向的对象的首地址。</li></ul></li></ul><h2 id=堆内存的数据结构>堆内存的数据结构
<a class=anchor href=#%e5%a0%86%e5%86%85%e5%ad%98%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84>#</a></h2><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/gc_heap.png alt=gc_heap></p><h3 id=mheap>mheap
<a class=anchor href=#mheap>#</a></h3><p>Go语言的runtime将堆内存用数据结构mheap来管理。
它的主要字段如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>//go:notinheap
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>mheap</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span><span style=color:#75715e>//...    
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// arenas is the heap arena map. It points to the metadata for
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// the heap for every arena frame of the entire usable virtual
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// address space.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Use arenaIndex to compute indexes into this array.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// For regions of the address space that are not backed by the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Go heap, the arena map contains nil.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Modifications are protected by mheap_.lock. Reads can be
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// performed without locking; however, a given entry can
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// transition from nil to non-nil at any time when the lock
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// isn&#39;t held. (Entries never transitions back to nil.)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// In general, this is a two-level mapping consisting of an L1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// map and possibly many L2 maps. This saves space when there
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// are a huge number of arena frames. However, on many
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// platforms (even 64-bit), arenaL1Bits is 0, making this
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// effectively a single-level map. In this case, arenas[0]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// will never be nil.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>arenas</span> [<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#a6e22e>arenaL1Bits</span>]<span style=color:#f92672>*</span>[<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#a6e22e>arenaL2Bits</span>]<span style=color:#f92672>*</span><span style=color:#a6e22e>heapArena</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p><a href=https://github.com/golang/go/blob/e7f9e17b7927cad7a93c5785e864799e8d9b4381/src/runtime/mheap.go#L152>mheap</a></p><p>可以看到将地址空间划分为多个arena。</p><h2 id=heaparena>heaparena
<a class=anchor href=#heaparena>#</a></h2><p>而每个arena是由heaparena结构来管理</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>//A heapArena stores metadata for a heap arena.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 每一个heapArena管理一个heap arena.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>heapArena</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bitmap</span> [<span style=color:#a6e22e>heapArenaBitmapBytes</span>]<span style=color:#66d9ef>byte</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>spans</span> [<span style=color:#a6e22e>pagesPerArena</span>]<span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pageInUse</span> [<span style=color:#a6e22e>pagesPerArena</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>8</span>]<span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pageMarks</span> [<span style=color:#a6e22e>pagesPerArena</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>8</span>]<span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>zeroedBase</span> <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=https://github.com/golang/go/blob/e7f9e17b7927cad7a93c5785e864799e8d9b4381/src/runtime/mheap.go#L217>heapArena</a></p><h3 id=mspan>mspan
<a class=anchor href=#mspan>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>	<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>mspan</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>next</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>prev</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>startAddr</span> <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// 起始地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>npages</span>    <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// 页数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>freeindex</span> <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>allocBits</span>  <span style=color:#f92672>*</span><span style=color:#a6e22e>gcBits</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>gcmarkBits</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gcBits</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>allocCache</span> <span style=color:#66d9ef>uint64</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    <span style=color:#75715e>//startAddr 和 npages — 确定该结构体管理的多个页所在的内存，每个页的大小都是 8KB；
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	    <span style=color:#75715e>//freeindex — 扫描页中空闲对象的初始索引；
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	    <span style=color:#75715e>//allocBits 和 gcmarkBits — 分别用于标记内存的占用和回收情况；
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	    <span style=color:#75715e>//allocCache — allocBits 的补码，可以用于快速查找内存中未被使用的内存；
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span></code></pre></div><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210408201124.png alt=20210408201124></p><h4 id=heaparena-1>heapArena
<a class=anchor href=#heaparena-1>#</a></h4><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210120104547.png alt=20210120104547></p><ul><li>mheap中每个arena对应一个HeapArena，记录arena的元数据信息。HeapArena中有一个<strong>bitmap和一个spans</strong>字段。<ul><li>1.bitmap<ul><li>bitmap中每两个bit对应标记arena中一个指针大小的word，也就是说bitmap中<strong>一个byte</strong>可以标记<strong>arena中连续四个指针大小</strong>的内存。<ul><li>每个word对应的两个bit中，<strong>低位bit用于标记是否为指针</strong>，0为非指针，1为指针；<strong>高位bit用于标记是否要继续扫描</strong>，<code>高位bit为1</code>就代表扫描完当前word并不能完成当前数据对象的扫描。</li></ul></li></ul></li><li>2.spans<ul><li>spans是一个*mspan类型的数组，用于记录当前arena中每一页对应到哪一个mspan。(看这个mspan的结构可以知道，它有startAddr与npages,说明一个mspan管理多个page)</li></ul></li></ul></li></ul><blockquote><p>基于HeapArena记录的元数据信息，我们只要知道一个对象的地址，</p><blockquote><p>就可以根据HeapArena.bitmap信息扫描它内部是否含有指针；
也可以根据对象地址计算出它在哪一页，然后通过HeapArena.spans信息查到该对象存在哪一个mspan中。</p></blockquote></blockquote><h4 id=span>span
<a class=anchor href=#span>#</a></h4><ul><li>而每个span都对应两个位图标记：mspan.allocBits和mspan.gcmarkBits。<ul><li>（1）allocBits中每一位用于标记一个对象存储单元是否已分配。<ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210113202836.png alt=20210113202836></li></ul></li><li>（2）<code>gcmarkBits</code>中每一位用于标记<strong>一个对象是否存活</strong>。<ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210113202858.png alt=20210113202858></li></ul></li></ul></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><script src=https://giscus.app/client.js data-repo=zput/utterances-comments data-repo-id=R_kgDOHhATGQ data-category=Announcements data-category-id=DIC_kwDOHhATGc4CPxca data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=1 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#treap>treap</a></li><li><a href=#p>P</a></li><li><a href=#areahint>areaHint</a></li><li><a href=#areas>areas</a></li><li><a href=#nextfreefast>nextFreeFast</a></li><li><a href=#arm64>arm64</a></li><li><a href=#结构>结构</a></li><li><a href=#堆内存的数据结构>堆内存的数据结构</a><ul><li><a href=#mheap>mheap</a></li></ul></li><li><a href=#heaparena>heaparena</a><ul><li><a href=#mspan>mspan</a><ul><li><a href=#heaparena-1>heapArena</a></li><li><a href=#span>span</a></li></ul></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>