<!doctype html><html lang=zh dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="1 前言 # 从程序的角度来看， 我们定义个变量，需要知道存储此变量所需的内存大小，以及申请一块内存，并返回内存的首地址；后续变量名与此地址就绑定起来，方便后续操作。
细化下上述所说的内容，主要包含如下：
怎么评估变量所需的内存大小? 如何申请一块内存。是每次申请时都向操作系统直接申请吗？还是先向操作系统申请一大块内存，在程序内部进行管理，当都用完时，才继续向操作系统进行申请呢？ 如果第二点都使用后者的方式，那么如何进行管理？ 2 评估内存大小 # 2.1 内存对齐 # what 什么是内存对齐呢？官方解释是：xxxx
why 为什么需要进行内存对齐呢? 主要是当前的内存限制的原因。 3 分配内存 # 没有内存管理，每次申请都直接向操作系统申请
通过程序级别的内存管理
因程序运行起来所需要分配的内存块有大有小，而分散的、大小不一的碎片化内存，一方面会降低内存的使用率，另一方面要找到大小合适的内存块的代价会因碎片化而增加，为降低碎片化内存给程序性能造成的不良影响，
3.1 Tcmalloc # golang采用了类似谷歌的Tcmalloc算法来解决碎片化问题：
Tcmalloc：
按照一组预置的大小规格把内存页划分成块，相同的块串联在一个空闲链表中。 程序申请内存时，会先根据要申请的内存大小，找到最匹配的规格，然后从对应空闲链表中分配一个空闲块。 4 golang内存管理 # 4.1 内存结构 # golang把内存大小分为四种级别，分别为:Arena, Page, Span，内存块。
注：下文讨论的都是在amd64架构的Linux环境下.
Arena：golang将堆地址空间划分为一个个arena区，arena区域起始地址定义在arenaBaseOffset，每个arena的大小是64MB，起始地址也对齐到64MB
Page：每个arena包含8192个page，所以每个page大小为8KB。
Span：包含一个或多个页大小的内存。golang给出了67种预置的大小规格，最小8Byte，最大32KB，所以在划分整整齐齐的arena中，又会按需划分出不同的Span,每个Span包含一组连续的Page，
类别(class) 内存块对象大小(bytes/obj) Span大小(bytes/span) Span中内存块对象个数(objects) 尾部浪费(tail waste) 最大浪费百分比(max waste) 1 8 8192 1024 0 87.50% 2 16 8192 512 0 43.75% 3 24 8192 341 8 29."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://zput.github.io/go-goroutine/docs/runtime/golang_memery/"><meta property="og:site_name" content="go调度源码分析"><meta property="og:title" content="内存分配器"><meta property="og:description" content="1 前言 # 从程序的角度来看， 我们定义个变量，需要知道存储此变量所需的内存大小，以及申请一块内存，并返回内存的首地址；后续变量名与此地址就绑定起来，方便后续操作。
细化下上述所说的内容，主要包含如下：
怎么评估变量所需的内存大小? 如何申请一块内存。是每次申请时都向操作系统直接申请吗？还是先向操作系统申请一大块内存，在程序内部进行管理，当都用完时，才继续向操作系统进行申请呢？ 如果第二点都使用后者的方式，那么如何进行管理？ 2 评估内存大小 # 2.1 内存对齐 # what 什么是内存对齐呢？官方解释是：xxxx
why 为什么需要进行内存对齐呢? 主要是当前的内存限制的原因。 3 分配内存 # 没有内存管理，每次申请都直接向操作系统申请
通过程序级别的内存管理
因程序运行起来所需要分配的内存块有大有小，而分散的、大小不一的碎片化内存，一方面会降低内存的使用率，另一方面要找到大小合适的内存块的代价会因碎片化而增加，为降低碎片化内存给程序性能造成的不良影响，
3.1 Tcmalloc # golang采用了类似谷歌的Tcmalloc算法来解决碎片化问题：
Tcmalloc：
按照一组预置的大小规格把内存页划分成块，相同的块串联在一个空闲链表中。 程序申请内存时，会先根据要申请的内存大小，找到最匹配的规格，然后从对应空闲链表中分配一个空闲块。 4 golang内存管理 # 4.1 内存结构 # golang把内存大小分为四种级别，分别为:Arena, Page, Span，内存块。
注：下文讨论的都是在amd64架构的Linux环境下.
Arena：golang将堆地址空间划分为一个个arena区，arena区域起始地址定义在arenaBaseOffset，每个arena的大小是64MB，起始地址也对齐到64MB
Page：每个arena包含8192个page，所以每个page大小为8KB。
Span：包含一个或多个页大小的内存。golang给出了67种预置的大小规格，最小8Byte，最大32KB，所以在划分整整齐齐的arena中，又会按需划分出不同的Span,每个Span包含一组连续的Page，
类别(class) 内存块对象大小(bytes/obj) Span大小(bytes/span) Span中内存块对象个数(objects) 尾部浪费(tail waste) 最大浪费百分比(max waste) 1 8 8192 1024 0 87.50% 2 16 8192 512 0 43.75% 3 24 8192 341 8 29."><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>内存分配器 | go调度源码分析</title>
<link rel=manifest href=/go-goroutine/manifest.json><link rel=icon href=/go-goroutine/favicon.png><link rel=stylesheet href=/go-goroutine/book.min.a7d3a43391e1f7eb43ae94bcae6354b739c49cba56473620924ec707afe0864d.css integrity="sha256-p9OkM5Hh9+tDrpS8rmNUtznEnLpWRzYgkk7HB6/ghk0=" crossorigin=anonymous><script defer src=/go-goroutine/flexsearch.min.js></script><script defer src=/go-goroutine/en.search.min.7aa8f6ba29cc1cea57c470bbfe1eb91c523936bb33fcbafa08abf2f7cc240e96.js integrity="sha256-eqj2uinMHOpXxHC7/h65HFI5Nrsz/Lr6CKvy98wkDpY=" crossorigin=anonymous></script><script defer src=/go-goroutine/sw.min.ec96d6e09af3075a94dd4de723a2edddf2ef138381c7e1e5b5a1f2c0578ee8bd.js integrity="sha256-7JbW4JrzB1qU3U3nI6Lt3fLvE4OBx+HltaHywFeO6L0=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/go-goroutine/><span>go调度源码分析</span></a></h2><div class=magic><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><div class=book-switch><label class=switch><input id=dark-mode-checkbox type=checkbox onchange=darkmode()>
<span class=slider></span></label></div></div><ul><li><a href=https://zput.github.io target=_blank rel=noopener>Zput博客</a></li><li><a href=https://github.com/zput target=_blank rel=noopener>GitHub</a></li></ul><hr><ul><li><span>基础知识</span><ul><li><a href=/go-goroutine/docs/foundation/golang_basic/>基本用法</a></li><li><a href=/go-goroutine/docs/foundation/slice/>slice</a></li><li><a href=/go-goroutine/docs/foundation/map/>map</a></li><li><a href=/go-goroutine/docs/foundation/sort/>sort</a></li><li><a href=/go-goroutine/docs/foundation/directory/>Directory</a></li></ul></li><li><span>鲁棒和性能</span><ul><li><a href=/go-goroutine/docs/robustness_and_performance/golang_test/>测试相关函数</a></li></ul></li><li><span>运行时</span><ul><li><a href=/go-goroutine/docs/runtime/golang_gmp/>GMP</a></li><li><span>堆分配原理</span><ul><li><a href=/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/1_summarize/>概述</a></li><li><a href=/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_big_object/>分配大对象</a></li><li><a href=/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_middle_object/>概述</a></li><li><a href=/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_small_object/>概述</a></li></ul></li><li><a href=/go-goroutine/docs/runtime/complement-source-reverse/>源码-反码-补码</a></li><li><a href=/go-goroutine/docs/runtime/golang_memery/ class=active>内存分配器</a></li><li><a href=/go-goroutine/docs/runtime/golang_gc/>垃圾回收</a></li><li><a href=/go-goroutine/docs/runtime/schedule/>调度</a><ul><li><span>前置知识</span><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/memory/>内存大小端</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/register_functionstack/>伪寄存器与函数栈帧</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/similar_assemble/>类汇编</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/go_underlying_struct/>底层重要结构</a></li></ul></li><li><a href=/go-goroutine/docs/runtime/schedule/2_init_before_enter_main_function/>初始化</a></li><li><a href=/go-goroutine/docs/runtime/schedule/3_exit_goroutine/>退出</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/>调度挑选策略</a><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/take_goroutine_from_globalorlocal_p/>从全局/本P队列</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/steal_goroutine_from_other_p/>从其他P队列</a></li></ul></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/>调度到达时机</a><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/active_scheduling/>主动调度</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/passive_scheduling/>被动调度</a></li><li><input type=checkbox id=section-740657f38f0c4de9a986bda642ff0388 class=toggle>
<label for=section-740657f38f0c4de9a986bda642ff0388 class="flex justify-between"><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/>剥夺调度</a></label><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/start_sysmon/>开启系统监控</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/user_code_preemption/>代码执行过久</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/system_call_preemption/>陷入系统调用</a></li></ul></li></ul></li></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script><script src=/go-goroutine/magic.js></script><script src=/go-goroutine/dark.js></script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/go-goroutine/svg/menu.svg class=book-icon alt=Menu>
</label><strong>内存分配器</strong>
<label for=toc-control><img src=/go-goroutine/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#1-前言>1 前言</a></li><li><a href=#2-评估内存大小>2 评估内存大小</a><ul><li><a href=#21-内存对齐>2.1 内存对齐</a></li></ul></li><li><a href=#3-分配内存>3 分配内存</a><ul><li><a href=#31-tcmalloc>3.1 Tcmalloc</a></li></ul></li><li><a href=#4-golang内存管理>4 golang内存管理</a><ul><li><a href=#41-内存结构>4.1 内存结构</a></li><li><a href=#42-内存管理结构>4.2 内存管理结构</a><ul><li><a href=#421-mspan>4.2.1 mspan</a></li><li><a href=#422-heaparena>4.2.2 heapArena</a></li><li><a href=#422-mheap>4.2.2 mheap</a></li><li><a href=#4221-mcentral>4.2.2.1 mcentral</a></li><li><a href=#423-mcache>4.2.3 mcache</a></li></ul></li><li><a href=#42-内存申请流程>4.2 内存申请流程</a><ul><li><a href=#421-宏观流程>4.2.1 宏观流程</a></li><li><a href=#422-微观流程>4.2.2 微观流程</a><ul><li><a href=#4221-步骤一mcachetiny分配>4.2.2.1 步骤一：mcache.tiny分配</a></li><li><a href=#4222-步骤二mcachealloc分配>4.2.2.2 步骤二：mcache.alloc分配</a></li><li><a href=#4223-步骤三mheapmcentral分配>4.2.2.3 步骤三：mheap.mcentral分配</a></li><li><a href=#4224-步骤四mheappagealloc分配>4.2.2.4 步骤四：mheap.pageAlloc分配</a></li><li><a href=#4225-步骤五mheapsysalloc分配>4.2.2.5 步骤五：mheap.sysAlloc分配</a></li></ul></li></ul></li></ul></li><li><a href=#5-对象的位图标记>5 对象的位图标记</a><ul><li><a href=#treap>treap</a></li><li><a href=#nextfreeindex>nextfreeindex</a></li><li><a href=#p>P</a></li><li><a href=#areahint>areaHint</a></li><li><a href=#areas>areas</a></li><li><a href=#nextfreefast>nextFreeFast</a></li><li><a href=#arm64>arm64</a></li><li><a href=#结构>结构</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=1-前言>1 前言
<a class=anchor href=#1-%e5%89%8d%e8%a8%80>#</a></h1><p>从程序的角度来看，
我们定义个变量，需要知道存储此变量所需的内存大小，以及申请一块内存，并返回内存的首地址；后续变量名与此地址就绑定起来，方便后续操作。</p><p>细化下上述所说的内容，主要包含如下：</p><ol><li>怎么评估变量所需的内存大小?</li><li>如何申请一块内存。是每次申请时都向操作系统直接申请吗？还是先向操作系统申请一大块内存，在程序内部进行管理，当都用完时，才继续向操作系统进行申请呢？</li><li>如果第二点都使用后者的方式，那么如何进行管理？</li></ol><h1 id=2-评估内存大小>2 评估内存大小
<a class=anchor href=#2-%e8%af%84%e4%bc%b0%e5%86%85%e5%ad%98%e5%a4%a7%e5%b0%8f>#</a></h1><h2 id=21-内存对齐>2.1 内存对齐
<a class=anchor href=#21-%e5%86%85%e5%ad%98%e5%af%b9%e9%bd%90>#</a></h2><ol><li>what</li></ol><p>什么是内存对齐呢？官方解释是：xxxx</p><blockquote></blockquote><ol start=2><li>why
为什么需要进行内存对齐呢? 主要是当前的内存限制的原因。</li></ol><h1 id=3-分配内存>3 分配内存
<a class=anchor href=#3-%e5%88%86%e9%85%8d%e5%86%85%e5%ad%98>#</a></h1><ol><li><p>没有内存管理，每次申请都直接向操作系统申请</p></li><li><p>通过程序级别的内存管理</p></li></ol><p>因程序运行起来所需要分配的内存块有大有小，而分散的、大小不一的碎片化内存，一方面会降低内存的使用率，另一方面要找到大小合适的内存块的代价会因碎片化而增加，为降低碎片化内存给程序性能造成的不良影响，</p><h2 id=31-tcmalloc>3.1 Tcmalloc
<a class=anchor href=#31-tcmalloc>#</a></h2><p>golang采用了类似谷歌的Tcmalloc算法来解决碎片化问题：</p><blockquote><p>Tcmalloc：</p><ol><li>按照一组预置的大小规格把内存页划分成块，相同的块串联在一个空闲链表中。</li><li>程序申请内存时，会先根据要申请的内存大小，找到最匹配的规格，然后从对应空闲链表中分配一个空闲块。</li></ol></blockquote><h1 id=4-golang内存管理>4 golang内存管理
<a class=anchor href=#4-golang%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86>#</a></h1><h2 id=41-内存结构>4.1 内存结构
<a class=anchor href=#41-%e5%86%85%e5%ad%98%e7%bb%93%e6%9e%84>#</a></h2><p>golang把内存大小分为四种级别，分别为:Arena, Page, Span，内存块。</p><blockquote><p>注：下文讨论的都是在amd64架构的Linux环境下.</p></blockquote><ol><li><p>Arena：golang将堆地址空间划分为一个个arena区，arena区域起始地址定义在arenaBaseOffset，每个arena的大小是64MB，起始地址也对齐到64MB</p></li><li><p>Page：每个arena包含8192个page，所以每个page大小为8KB。</p></li><li><p>Span：包含一个或多个页大小的内存。golang给出了67种预置的大小规格，最小8Byte，最大32KB，所以在划分整整齐齐的arena中，又会按需划分出不同的Span,每个Span包含一组连续的Page，</p></li></ol><table><thead><tr><th>类别(class)</th><th>内存块对象大小(bytes/obj)</th><th>Span大小(bytes/span)</th><th>Span中内存块对象个数(objects)</th><th>尾部浪费(tail waste)</th><th>最大浪费百分比(max waste)</th></tr></thead><tbody><tr><td>1</td><td>8</td><td>8192</td><td>1024</td><td>0</td><td>87.50%</td></tr><tr><td>2</td><td>16</td><td>8192</td><td>512</td><td>0</td><td>43.75%</td></tr><tr><td>3</td><td>24</td><td>8192</td><td>341</td><td>8</td><td>29.24%</td></tr><tr><td>4</td><td>32</td><td>8192</td><td>256</td><td>0</td><td>21.88%</td></tr><tr><td>&mldr;</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>66</td><td>28672</td><td>57344</td><td>2</td><td>0</td><td>4.91%</td></tr><tr><td>67</td><td>32768</td><td>32768</td><td>1</td><td>0</td><td>12.50%</td></tr></tbody></table><ol start=4><li>内存块：并且按照特定规格划，在Span中分成了等大的内存块。</li></ol><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240601173403.png width=50% height=50% alt=效果图></p><p>arena，span，page，内存块就组成了堆内存。</p><p>创造span的概念从业务和代码隔离的角度来看，这样做是有意义的。当与外部系统（操作系统可以看作Go程序的外部系统）交互时，创建独立的业务概念可以隔离外部概念（例如Page）对后续业务带来的影响。即使Page的业务形态发生变化，也只需要修改Span与Page之间的交互即可。</p><p>因Span中最终存储的是程序要求分配的对象，它们有大有小，如果不在其上划分逻辑等级，会增加分配时的竞争压力，而把对象划分为一定的等级，将相近大小的对象存储到同一级别的Span中,这样在分配时就能分散竞争压力，也尽量避免了空间的浪费。</p><h2 id=42-内存管理结构>4.2 内存管理结构
<a class=anchor href=#42-%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e7%bb%93%e6%9e%84>#</a></h2><p>golang堆内存由上述的内存结构组成，同样也有对应的管理结构。</p><ol><li>mheap管理整个golang堆内存。</li><li>heapArena管理一个arena。</li><li>mspan管理一个span。</li></ol><h3 id=421-mspan>4.2.1 mspan
<a class=anchor href=#421-mspan>#</a></h3><p>mspan管理着span中一组连续的page。</p><blockquote><p>mspan 类的源码位于 runtime/mheap.go 文件中</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>mspan</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>next</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>prev</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// next和prev是指定后续和前导的Span。这代表Span的存在形式并非孤立的一个对象，而是一个双向链表。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>nelems</span> <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//当前Span中存储的对象数量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>startAddr</span> <span style=color:#66d9ef>uintptr</span> 
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>npages</span>    <span style=color:#66d9ef>uintptr</span> 
</span></span><span style=display:flex><span>    <span style=color:#75715e>//startAddr(页数) 和 npages(起始地址) — 确定该结构体管理的多个页所在的内存，每个页的大小都是 8KB；
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>freeindex</span> <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//freeindex — 扫描页中&#34;空闲对象&#34;的初始索引；
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>allocCache</span> <span style=color:#66d9ef>uint64</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//allocCache — allocBits 的补码，可以用于快速查找内存中未被使用的内存；
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>allocBits</span>  <span style=color:#f92672>*</span><span style=color:#a6e22e>gcBits</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gcmarkBits</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gcBits</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//allocBits 和 gcmarkBits — 分别用于标记内存块的占用和回收情况；
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>spanclass</span> <span style=color:#a6e22e>spanClass</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 标识 mspan 等级，包含 class 和 noscan 两部分信息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// type spanClass uint8
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><ol><li>nelem记录着当前Span共划分成了多少个内存块</li><li>freelndex记录着下个空闲内存块的索引</li></ol><p>mspan这里的位图标记，面向的是划分好的内存块单元</p><ol start=3><li>allocBits用于标记哪些内存块已经被分配了</li><li>gcmarkBits是当前Span的标记位图，在GC标记阶段会对这个位图进行标记，一个二进制位对应Span中的一个内存块，到gc清扫阶段会释放掉旧的allocBits，然后把标记好的gcmarkBits用作allocBits，这样未被gc标记的内存块就能回收利用了，当然会重新分配一段清零的内存给gcmarkBits位图</li></ol><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240601192549.png width=50% height=50% alt=效果图></p><ol start=5><li>spanclass</li></ol><p>前面提到Span被划分为 67 种等级（1-67，实际上还有一种隐藏的 0 级，用于处理更大的对象，上不封顶）</p><table><thead><tr><th>类别(class)</th><th>内存块对象大小(bytes/obj)</th><th>Span大小(bytes/span)</th><th>Span中内存块对象个数(objects)</th><th>尾部浪费(tail waste)</th><th>最大浪费百分比(max waste)</th></tr></thead><tbody><tr><td>1</td><td>8</td><td>8192</td><td>1024</td><td>0</td><td>87.50%</td></tr><tr><td>2</td><td>16</td><td>8192</td><td>512</td><td>0</td><td>43.75%</td></tr><tr><td>3</td><td>24</td><td>8192</td><td>341</td><td>8</td><td>29.24%</td></tr><tr><td>4</td><td>32</td><td>8192</td><td>256</td><td>0</td><td>21.88%</td></tr><tr><td>&mldr;</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>66</td><td>28672</td><td>57344</td><td>2</td><td>0</td><td>4.91%</td></tr><tr><td>67</td><td>32768</td><td>32768</td><td>1</td><td>0</td><td>12.50%</td></tr></tbody></table><p>对上表各列进行解释：</p><p>（1）class：标识了Span的级别。级别的值可以是1～67的整数
（2）bytes/obj：指定了该级别的Span中对象的最大大小，例如第1行的8代表1～8字节的对象大小；第2行的16代表9～16字节的对象大小。
（3）bytes/span：指定了该级别的Span中的存储空间大小。例如8192代表了8KB，即1个Page。需要注意的是，多个级别的Span可能有着相同的大小。
（4）object：指定可以在Span中存储多少个对象。Span在分配时，首先会将整个Span切分为objects个数的元素，每个元素存储一个对象。<code>等于 （3）/（2）</code>
（5）tail waste：尾部浪费。理想情况下，Span被全部填满，但在尾部仍然无法避免内存空间浪费。例如，class为1时，单个元素为8字节，单个Span为8KB，8字节可以被8KB整除（8192%8=0），此时不会产生浪费；但当class为3时，单个元素大小为24字节，单个Span为8KB，8192%24=8，代表会产生8字节的尾部浪费。<code>（3）/（2）可能除不尽，于是该项值为（3）%（2）</code>
(6)max waste：最大浪费率。当一个对象的大小刚好超过某个级别的最大值时，该对象将会被存储到下个级别的Span中，此时便容易产生浪费。例如1字节大小的对象会被存入class为1的Span中，但是可能会产生7字节的浪费，此时浪费率为7/8×100%=87.5%；而17字节的对象会被存储到class为3的Span中，产生的最大浪费率为（24−17）/24×100%=29.24%。</p><p>再来看看spanclass的实现：</p><blockquote><p>runtime/mheap.go</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>spanClass</span> <span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// uint8 左 7 位为 mspan 等级，最右一位标识是否为 noscan
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makeSpanClass</span>(<span style=color:#a6e22e>sizeclass</span> <span style=color:#66d9ef>uint8</span>, <span style=color:#a6e22e>noscan</span> <span style=color:#66d9ef>bool</span>) <span style=color:#a6e22e>spanClass</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>spanClass</span>(<span style=color:#a6e22e>sizeclass</span><span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>1</span>) | <span style=color:#a6e22e>spanClass</span>(<span style=color:#a6e22e>bool2int</span>(<span style=color:#a6e22e>noscan</span>))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>sc</span> <span style=color:#a6e22e>spanClass</span>) <span style=color:#a6e22e>sizeclass</span>() <span style=color:#66d9ef>int8</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> int8(<span style=color:#a6e22e>sc</span> <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>sc</span> <span style=color:#a6e22e>spanClass</span>) <span style=color:#a6e22e>noscan</span>() <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>sc</span><span style=color:#f92672>&amp;</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>spanclass其实是<code>uint8</code>，也就是8bit，高7位表示了上表的span等级（总共67+1个等级，7个bit足够用了），最低位表示nocan信息（区分是否是否需要扫描）。</p><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240601192155.png width=50% height=50% alt=效果图></p><h3 id=422-heaparena>4.2.2 heapArena
<a class=anchor href=#422-heaparena>#</a></h3><p>mheap中每个arena对应一个HeapArena，记录arena的元数据信息。</p><blockquote><p>代码位于 runtime/mheap.go</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>heapArena</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>spans</span> [<span style=color:#a6e22e>pagesPerArena</span>]<span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 实现page到mspan的映射
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// const pagesPerArena = 8192
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bitmap</span> [<span style=color:#a6e22e>heapArenaBitmapBytes</span>]<span style=color:#66d9ef>byte</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pageInUse</span> [<span style=color:#a6e22e>pagesPerArena</span> <span style=color:#f92672>/</span><span style=color:#ae81ff>8</span>]<span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pageMarks</span> [<span style=color:#a6e22e>pagesPerArena</span><span style=color:#f92672>/</span><span style=color:#ae81ff>8</span>]<span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pageSpecials</span> [<span style=color:#a6e22e>pagesPerArena</span><span style=color:#f92672>/</span><span style=color:#ae81ff>8</span>]<span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>checkmarks</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>checkmarksMap</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>zeroedBase</span> <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol><li><p>bitmap：用一位标记这个arena中，一个指针大小的内存单元，到底是指针还是标量(0表示标量，1表示指针)，再用一位标记这块内存空间的后续单元，是否包含指针（方便gc时判断是否继续扫描；0表示终止，1表示扫描）。bitmap中用一字节标记Arena中4个指针大小的内存空间。</p></li><li><p>pagelnUse：是个uint8类型的数组，长度为1024，所以一共8192位，但不是标记哪些页面被使用了，只标记处于使用状态(mSpanInUse)的Span的<strong>第一个page</strong>。</p></li><li><p>pageMarks：只标记每个Span的第一个page，在gc标记阶段才修改此位图。在gc清扫阶段会根据这个位图，来释放不含标记对像的span</p></li><li><p>spans是一个<code>*mspan</code>类型的数组（大小为8192），用于记录当前arena中每一页对应到哪一个mspan。(看这个mspan的结构可以知道，它有startAddr与npages,说明一个mspan管理多个page)</p></li></ol><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240601203444.png width=50% height=50% alt=效果图></p><blockquote><p>基于HeapArena记录的元数据信息，我们只要知道一个对象的地址，</p><blockquote><p>就可以根据HeapArena.bitmap信息扫描它内部是否含有指针；
也可以根据对象地址计算出它在哪一页，然后通过HeapArena.spans信息查到该对象存在哪一个mspan中。</p></blockquote></blockquote><h3 id=422-mheap>4.2.2 mheap
<a class=anchor href=#422-mheap>#</a></h3><p>Go语言的runtime将堆内存用数据结构mheap来管理。
它的主要字段如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>mheap</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>lock</span> <span style=color:#a6e22e>mutex</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 堆的全局锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>allspans</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 记录了所有的 mspan. 需要知道，所有 mspan 都是经由 mheap，使用连续空闲页组装生成的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>arenas</span> [<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#a6e22e>arenaL1Bits</span>]<span style=color:#f92672>*</span>[<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#a6e22e>arenaL2Bits</span>]<span style=color:#f92672>*</span><span style=color:#a6e22e>heapArena</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 在linux 64位系统下
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 每个heapArena管理的64M大小空间
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 一级数组大小为1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 二级数组大小为2^22
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 因此理论上，Golang堆上限为2^22*64M=256T
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>central</span> [<span style=color:#a6e22e>numSpanClasses</span>]<span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>mcentral</span> <span style=color:#a6e22e>mcentral</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 用于内存地址对齐
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>pad</span>      [<span style=color:#a6e22e>cpu</span>.<span style=color:#a6e22e>CacheLinePadSize</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Sizeof</span>(<span style=color:#a6e22e>mcentral</span>{})<span style=color:#f92672>%</span><span style=color:#a6e22e>cpu</span>.<span style=color:#a6e22e>CacheLinePadSize</span>]<span style=color:#66d9ef>byte</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 多个 mcentral，总个数为 spanClass 的个数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>//...    
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240601205453.png width=80% height=80% alt=效果图></p><h3 id=4221-mcentral>4.2.2.1 mcentral
<a class=anchor href=#4221-mcentral>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>mcentral</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>spanclass</span> <span style=color:#a6e22e>spanClass</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>partial</span> [<span style=color:#ae81ff>2</span>]<span style=color:#a6e22e>spanSet</span> 
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 没有空闲对象（已用尽）的mspan列表
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>full</span>    [<span style=color:#ae81ff>2</span>]<span style=color:#a6e22e>spanSet</span> 
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 有空闲对象（未用尽）的mspan列表
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240601210232.png width=50% height=50% alt=效果图></p><h3 id=423-mcache>4.2.3 mcache
<a class=anchor href=#423-mcache>#</a></h3><p>全局mspan管理中心，方便取用各种规格类型的mspan，但是为保障多个P之间并发安全，需要频繁加锁、解锁。
为降低多个P之间的竞争性，每个P都有一个本地小对像缓存(mcache)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>mcache</span> <span style=color:#66d9ef>struct</span>{
</span></span><span style=display:flex><span>  <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>alloc</span> [<span style=color:#a6e22e>numSpanclasses</span>]<span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// numSpanClasses =_NumSizeClasses &lt;&lt; 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// _NumSizeClasses为Span级别的个数是68，那么numSpanClasses的实际值为136
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>tiny</span> <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>tinyoffset</span> <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>tinyAllocs</span> <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol><li><p>alloc：是指已经分配到当前mcache（线程级别）的mspan对象。每个级别都会保存两个Span链表（带有指针和不带指针）。带有指针的Span链表会参与垃圾回收的扫描过程，而不带指针的Span链表则无须进行垃圾回收，从而提高了垃圾回收的效率。</p></li><li><p>mcache中还有一个处理微小对象（小于16B对象）分配器tiny allocator</p></li></ol><p>(1)tiny，指向当前正在使用的微对象内存块的地址。
(2)tinyoffset，指向为新的微对象分配内存时的起始地址。
(3)tinyAllocs，已经存储了多少微对象。</p><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240601211602.png width=50% height=50% alt=效果图></p><h2 id=42-内存申请流程>4.2 内存申请流程
<a class=anchor href=#42-%e5%86%85%e5%ad%98%e7%94%b3%e8%af%b7%e6%b5%81%e7%a8%8b>#</a></h2><p>Go语言将内存对象的大小分为3类：微对象、小对象和大对象。其大小范围如下：
(1)微对象：（0,16）字节。
(2)小对象：[16, 32K]字节。
(3)大对象：32K字节以上。</p><p>这3种对象的分配策略不同。大于32KB的对象毕竟是少数，因此会直接在堆内存进行分配。而对于占据程序绝大多数的微对象和小对象，</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>size</span> <span style=color:#66d9ef>uintptr</span>, <span style=color:#a6e22e>typ</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>, <span style=color:#a6e22e>needzero</span> <span style=color:#66d9ef>bool</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>size</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>maxSmallSize</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 小于 32KB 的微、小对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>noscan</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>size</span> &lt; <span style=color:#a6e22e>maxTinySize</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 微对象（小于16B且无指针）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// (1) tiny allocator
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 小对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// (2) mcache.allocator
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 大对象（大于32KB）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// (3) large span
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=421-宏观流程>4.2.1 宏观流程
<a class=anchor href=#421-%e5%ae%8f%e8%a7%82%e6%b5%81%e7%a8%8b>#</a></h3><p>从申请过程来看，是直接通过本地mcache与全局mheap配合工作来进行申请：</p><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240602154946.png width=30% height=30% alt=效果图></p><p>其申请过程由上而下，每一步只要成功则直接返回. 若失败，则由下层方法进行兜底。</p><p>整体的分配流程如下：</p><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240602154919.png width=90% height=90% alt=效果图></p><ul><li>微对象：</li></ul><ol><li>P本地mcache.tiny分配器获取</li><li>P本地mcache.alloc缓存的mspan中获取（根据申请的spanClass）</li><li>全局mheap.mcentral取mspan填充到对应P本地mcache.alloc，然后从中获取（根据申请的spanClass）</li><li>全局mheap.pageAlloc(页分配器)取得足够数量连续空闲页组装成mspan填充到mcache</li><li>全局mheap向操作系统申请内存，更新mheap.pageAlloc(页分配器)的索引信息，然后重复步骤4</li></ol><blockquote><p>第3步需加spanClass粒度锁
第4步需加mheap全局锁</p></blockquote><ul><li><p>小对象
分配流程只执行第2到第5步骤。</p></li><li><p>大对象
分配流程只执行第4到第5步骤。</p></li></ul><h3 id=422-微观流程>4.2.2 微观流程
<a class=anchor href=#422-%e5%be%ae%e8%a7%82%e6%b5%81%e7%a8%8b>#</a></h3><h4 id=4221-步骤一mcachetiny分配>4.2.2.1 步骤一：mcache.tiny分配
<a class=anchor href=#4221-%e6%ad%a5%e9%aa%a4%e4%b8%80mcachetiny%e5%88%86%e9%85%8d>#</a></h4><p>每个P独有的mache会有个微对象分配器Tiny allocator，它可以将多个较小的内存分配请求（小于16字节的）合并存入同一个内存块中，只有当内存块中的所有对象都需要被回收时，整片内存才可能被回收。这样做主要是为了减少浪费，例如：如果需要连续分配16次1字节的内存，每次分配时匹配预置的内存规格8字节（最小的spanclass），那么每次都会浪费7字节。</p><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240602165008.png width=90% height=90% alt=效果图></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>size</span> <span style=color:#66d9ef>uintptr</span>, <span style=color:#a6e22e>typ</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>, <span style=color:#a6e22e>needzero</span> <span style=color:#66d9ef>bool</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>size</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>maxSmallSize</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 小于 32KB 的微、小对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>noscan</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>size</span> &lt; <span style=color:#a6e22e>maxTinySize</span> {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// --------------------------------------------------------------------------------------------------
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// 获取mcache的变量tinyoffset，表示Tiny空间空闲的位移
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>off</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>tinyoffset</span>
</span></span><span style=display:flex><span>			<span style=color:#75715e>// 内存对齐
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>size</span><span style=color:#f92672>&amp;</span><span style=color:#ae81ff>7</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {  <span style=color:#75715e>// size 在 (0, 16) 范围，如果低三位是0，则跟8位对齐
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#a6e22e>off</span> = <span style=color:#a6e22e>alignUp</span>(<span style=color:#a6e22e>off</span>, <span style=color:#ae81ff>8</span>)
</span></span><span style=display:flex><span>			} <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>goarch</span>.<span style=color:#a6e22e>PtrSize</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>4</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>size</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>12</span> {
</span></span><span style=display:flex><span>				<span style=color:#75715e>// 地址长度是4，字节数是12，也是跟8位对齐
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#a6e22e>off</span> = <span style=color:#a6e22e>alignUp</span>(<span style=color:#a6e22e>off</span>, <span style=color:#ae81ff>8</span>)
</span></span><span style=display:flex><span>			} <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>size</span><span style=color:#f92672>&amp;</span><span style=color:#ae81ff>3</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> { <span style=color:#75715e>// size低二位是0，跟4位对齐
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#a6e22e>off</span> = <span style=color:#a6e22e>alignUp</span>(<span style=color:#a6e22e>off</span>, <span style=color:#ae81ff>4</span>)
</span></span><span style=display:flex><span>			} <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>size</span><span style=color:#f92672>&amp;</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> { <span style=color:#75715e>// size低一位是0，跟2位对齐
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#a6e22e>off</span> = <span style=color:#a6e22e>alignUp</span>(<span style=color:#a6e22e>off</span>, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>off</span><span style=color:#f92672>+</span><span style=color:#a6e22e>size</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>maxTinySize</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>tiny</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>				<span style=color:#75715e>// 如果对象的大小和off偏移量加起来仍然比16B小，且Tiny空间存在，则当前对象可以从已有的Tiny空间分配
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// 在当前的Tiny空间分配，增加相关变量大小 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#a6e22e>x</span> = <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>tiny</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>off</span>)
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>tinyoffset</span> = <span style=color:#a6e22e>off</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>size</span>
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>tinyAllocs</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>mallocing</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>releasem</span>(<span style=color:#a6e22e>mp</span>)
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>x</span>    <span style=color:#75715e>// 分配后直接返回
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			}
</span></span><span style=display:flex><span>			<span style=color:#75715e>// 从当前P的mcache的spanClass为5的mspan中，申请一个新的16B Object的Tiny空间
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>span</span> = <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>alloc</span>[<span style=color:#a6e22e>tinySpanClass</span>]
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>nextFreeFast</span>(<span style=color:#a6e22e>span</span>)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>v</span>, <span style=color:#a6e22e>span</span>, <span style=color:#a6e22e>shouldhelpgc</span> = <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>nextFree</span>(<span style=color:#a6e22e>tinySpanClass</span>)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>x</span> = <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>v</span>)
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 将申请的16B内存空间置0，16B由两个长度为uint64地址指向
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			(<span style=color:#f92672>*</span>[<span style=color:#ae81ff>2</span>]<span style=color:#66d9ef>uint64</span>)(<span style=color:#a6e22e>x</span>)[<span style=color:#ae81ff>0</span>] = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>			(<span style=color:#f92672>*</span>[<span style=color:#ae81ff>2</span>]<span style=color:#66d9ef>uint64</span>)(<span style=color:#a6e22e>x</span>)[<span style=color:#ae81ff>1</span>] = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>			<span style=color:#75715e>// 非竞态下，如果申请的内存块分配了新对象后，剩余的空间比当前tiny所持有的空间少，那么需要进行替换
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>raceenabled</span> <span style=color:#f92672>&amp;&amp;</span> (<span style=color:#a6e22e>size</span> &lt; <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>tinyoffset</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>tiny</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>tiny</span> = uintptr(<span style=color:#a6e22e>x</span>)
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>tinyoffset</span> = <span style=color:#a6e22e>size</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>size</span> = <span style=color:#a6e22e>maxTinySize</span>
</span></span><span style=display:flex><span>			<span style=color:#75715e>// --------------------------------------------------------------------------------------------------
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 小对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// (2) mcache.allocator
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 大对象（大于32KB）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// (3) large span
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=4222-步骤二mcachealloc分配>4.2.2.2 步骤二：mcache.alloc分配
<a class=anchor href=#4222-%e6%ad%a5%e9%aa%a4%e4%ba%8cmcachealloc%e5%88%86%e9%85%8d>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>size</span> <span style=color:#66d9ef>uintptr</span>, <span style=color:#a6e22e>typ</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>, <span style=color:#a6e22e>needzero</span> <span style=color:#66d9ef>bool</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>size</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>maxSmallSize</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 小于 32KB 的微、小对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>noscan</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>size</span> &lt; <span style=color:#a6e22e>maxTinySize</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 微对象（小于16B且无指针）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// (1) tiny allocator
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>	      <span style=color:#75715e>//--------------------------------------------------------------------------------------------------
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>          <span style=color:#75715e>//根据对象大小，映射到其所属的 span 的等级(0~66）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>          <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>sizeclass</span> <span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>size</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>smallSizeMax</span><span style=color:#f92672>-</span><span style=color:#ae81ff>8</span> {
</span></span><span style=display:flex><span>              <span style=color:#a6e22e>sizeclass</span> = <span style=color:#a6e22e>size_to_class8</span>[<span style=color:#a6e22e>divRoundUp</span>(<span style=color:#a6e22e>size</span>, <span style=color:#a6e22e>smallSizeDiv</span>)]
</span></span><span style=display:flex><span>          } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>              <span style=color:#a6e22e>sizeclass</span> = <span style=color:#a6e22e>size_to_class128</span>[<span style=color:#a6e22e>divRoundUp</span>(<span style=color:#a6e22e>size</span><span style=color:#f92672>-</span><span style=color:#a6e22e>smallSizeMax</span>, <span style=color:#a6e22e>largeSizeDiv</span>)]
</span></span><span style=display:flex><span>          }        
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>size</span> = uintptr(<span style=color:#a6e22e>class_to_size</span>[<span style=color:#a6e22e>sizeclass</span>])
</span></span><span style=display:flex><span>          <span style=color:#75715e>//创建spanClass 标识，其中前7位(span 的等级(0~66))，最后一位(标识对象是否是指针，方便后续gc判断是否需要扫描)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>          <span style=color:#a6e22e>spc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>makeSpanClass</span>(<span style=color:#a6e22e>sizeclass</span>, <span style=color:#a6e22e>noscan</span>) 
</span></span><span style=display:flex><span>          <span style=color:#75715e>//获取 mcache 中的 span
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>          <span style=color:#a6e22e>span</span> = <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>alloc</span>[<span style=color:#a6e22e>spc</span>]  
</span></span><span style=display:flex><span>          <span style=color:#75715e>//从mcache的span中尝试获取空间
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>          <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>nextFreeFast</span>(<span style=color:#a6e22e>span</span>)
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>          <span style=color:#75715e>//mcache分配空间失败，则通过mheap兜底
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>             <span style=color:#a6e22e>v</span>, <span style=color:#a6e22e>span</span>, <span style=color:#a6e22e>shouldhelpgc</span> = <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>nextFree</span>(<span style=color:#a6e22e>spc</span>)
</span></span><span style=display:flex><span>          }     
</span></span><span style=display:flex><span>          <span style=color:#75715e>// 分配空间
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>          <span style=color:#a6e22e>x</span> = <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>v</span>)
</span></span><span style=display:flex><span>          <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	      <span style=color:#75715e>// --------------------------------------------------------------------------------------------------
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       }  
</span></span><span style=display:flex><span>   } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 大对象（大于32KB）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// (3) large span
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>nextFreeFast: 这个函数返回Span上可用的地址，如果找不到则返回0</p><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240602180508.png width=90% height=90% alt=效果图></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>nextFreeFast</span>(<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span>) <span style=color:#a6e22e>gclinkptr</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 计算s.allocCache从低位起有多少个0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>theBit</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sys</span>.<span style=color:#a6e22e>Ctz64</span>(<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>allocCache</span>) <span style=color:#75715e>// Is there a free object in the allocCache?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>theBit</span> &lt; <span style=color:#ae81ff>64</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>result</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>freeindex</span> <span style=color:#f92672>+</span> uintptr(<span style=color:#a6e22e>theBit</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>result</span> &lt; <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>nelems</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>freeidx</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>result</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>freeidx</span><span style=color:#f92672>%</span><span style=color:#ae81ff>64</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>freeidx</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>nelems</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>//更新bitmap、可用的slot索引
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>allocCache</span> <span style=color:#f92672>&gt;&gt;=</span> uint(<span style=color:#a6e22e>theBit</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>freeindex</span> = <span style=color:#a6e22e>freeidx</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>allocCount</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>//返回找到的内存的地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>gclinkptr</span>(<span style=color:#a6e22e>result</span><span style=color:#f92672>*</span><span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>elemsize</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>base</span>())
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>nextFree:如果在cached span里面找到未使用的object，则返回，否则调用refill 函数，从mheap.central中获取对应classsize的span，然后重新查找</p><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240602182220.png width=90% height=90% alt=效果图></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mcache</span>) <span style=color:#a6e22e>nextFree</span>(<span style=color:#a6e22e>spc</span> <span style=color:#a6e22e>spanClass</span>) (<span style=color:#a6e22e>v</span> <span style=color:#a6e22e>gclinkptr</span>, <span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span>, <span style=color:#a6e22e>shouldhelpgc</span> <span style=color:#66d9ef>bool</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//先查找mcache中对应规格的span
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>s</span> = <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>alloc</span>[<span style=color:#a6e22e>spc</span>]
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>shouldhelpgc</span> = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//在当前span中找到合适的index索引
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>freeIndex</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>nextFreeIndex</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>freeIndex</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>nelems</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// freeIndex == nelems 时，表示当前span已满
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 调用refill函数，从 mcentral 中获取可用的span，并替换掉当前 mcache里面的span
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 再次到新的span里面查找合适的index
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>freeIndex</span> = <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>nextFreeIndex</span>()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//计算出来 内存地址，并更新span的属性
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>v</span> = <span style=color:#a6e22e>gclinkptr</span>(<span style=color:#a6e22e>freeIndex</span><span style=color:#f92672>*</span><span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>elemsize</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>base</span>())
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>allocCount</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=4223-步骤三mheapmcentral分配>4.2.2.3 步骤三：mheap.mcentral分配
<a class=anchor href=#4223-%e6%ad%a5%e9%aa%a4%e4%b8%89mheapmcentral%e5%88%86%e9%85%8d>#</a></h4><p>mcache中mspan空间不足，会调用mcache.refill，向更上层的mheap.mcentral获取mspan。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mcache</span>) <span style=color:#a6e22e>refill</span>(<span style=color:#a6e22e>spc</span> <span style=color:#a6e22e>spanClass</span>) {  
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>alloc</span>[<span style=color:#a6e22e>spc</span>]
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 从 mcentral 当中获取对应等级的 span
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>s</span> = <span style=color:#a6e22e>mheap_</span>.<span style=color:#a6e22e>central</span>[<span style=color:#a6e22e>spc</span>].<span style=color:#a6e22e>mcentral</span>.<span style=color:#a6e22e>cacheSpan</span>()
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 将新的 span 添加到 mcahe 当中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>alloc</span>[<span style=color:#a6e22e>spc</span>] = <span style=color:#a6e22e>s</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>mcentral.cacheSpan:会先加上sweepLocker锁（spanClass级别的），然后从partial和full中尝试获取有空间的mspan:</p><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240602183830.png width=50% height=50% alt=效果图></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mcentral</span>) <span style=color:#a6e22e>cacheSpan</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>sl</span> <span style=color:#a6e22e>sweepLocker</span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sl</span> = <span style=color:#a6e22e>sweep</span>.<span style=color:#a6e22e>active</span>.<span style=color:#a6e22e>begin</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sl</span>.<span style=color:#a6e22e>valid</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> ; <span style=color:#a6e22e>spanBudget</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>spanBudget</span><span style=color:#f92672>--</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>s</span> = <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>partialUnswept</span>(<span style=color:#a6e22e>sg</span>).<span style=color:#a6e22e>pop</span>()
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sl</span>.<span style=color:#a6e22e>tryAcquire</span>(<span style=color:#a6e22e>s</span>); <span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#a6e22e>sweep</span>.<span style=color:#a6e22e>active</span>.<span style=color:#a6e22e>end</span>(<span style=color:#a6e22e>sl</span>)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>havespan</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 通过 sweepLock，加锁尝试从 mcentral 的非空链表 full 中获取 mspan
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> ; <span style=color:#a6e22e>spanBudget</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>spanBudget</span><span style=color:#f92672>--</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>s</span> = <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>fullUnswept</span>(<span style=color:#a6e22e>sg</span>).<span style=color:#a6e22e>pop</span>()
</span></span><span style=display:flex><span>           <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sl</span>.<span style=color:#a6e22e>tryAcquire</span>(<span style=color:#a6e22e>s</span>); <span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#a6e22e>sweep</span>.<span style=color:#a6e22e>active</span>.<span style=color:#a6e22e>end</span>(<span style=color:#a6e22e>sl</span>)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>havespan</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// mcentral中也没有可用的mspan了，则需要从mheap中获取，最终会调用mheap_.alloc方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>s</span> = <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>grow</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 执行到此处时，s 已经指向一个存在 object 空位的 mspan 了
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>havespan</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=4224-步骤四mheappagealloc分配>4.2.2.4 步骤四：mheap.pageAlloc分配
<a class=anchor href=#4224-%e6%ad%a5%e9%aa%a4%e5%9b%9bmheappagealloc%e5%88%86%e9%85%8d>#</a></h4><p>当从mcentral中的partial和full链表中也找不到对应的mspan，则调用mcentral的grow方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mcentral</span>) <span style=color:#a6e22e>grow</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>npages</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#a6e22e>class_to_allocnpages</span>[<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>spanclass</span>.<span style=color:#a6e22e>sizeclass</span>()])
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#a6e22e>class_to_size</span>[<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>spanclass</span>.<span style=color:#a6e22e>sizeclass</span>()])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mheap_</span>.<span style=color:#a6e22e>alloc</span>(<span style=color:#a6e22e>npages</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>spanclass</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mheap</span>) <span style=color:#a6e22e>alloc</span>(<span style=color:#a6e22e>npages</span> <span style=color:#66d9ef>uintptr</span>, <span style=color:#a6e22e>spanclass</span> <span style=color:#a6e22e>spanClass</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>systemstack</span>(<span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>s</span> = <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>allocSpan</span>(<span style=color:#a6e22e>npages</span>, <span style=color:#a6e22e>spanAllocHeap</span>, <span style=color:#a6e22e>spanclass</span>)
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mheap</span>) <span style=color:#a6e22e>allocSpan</span>(<span style=color:#a6e22e>npages</span> <span style=color:#66d9ef>uintptr</span>, <span style=color:#a6e22e>typ</span> <span style=color:#a6e22e>spanAllocType</span>, <span style=color:#a6e22e>spanclass</span> <span style=color:#a6e22e>spanClass</span>) (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>base</span>, <span style=color:#a6e22e>scav</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#ae81ff>0</span>), uintptr(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 注意此处存在从每个P的页缓存pageCache中获取空闲页组装mspan
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 加上堆全局锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>base</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 通过基数树索引快速寻找满足条件的连续空闲页
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>base</span>, <span style=color:#a6e22e>scav</span> = <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>pages</span>.<span style=color:#a6e22e>alloc</span>(<span style=color:#a6e22e>npages</span>)
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>HaveSpan</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 把空闲页组装成 mspan
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>init</span>(<span style=color:#a6e22e>base</span>, <span style=color:#a6e22e>npages</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 将这批页添加到 heapArena 中，建立由页指向 mspan 的映射
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>setSpans</span>(<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>base</span>(), <span style=color:#a6e22e>npages</span>, <span style=color:#a6e22e>s</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=4225-步骤五mheapsysalloc分配>4.2.2.5 步骤五：mheap.sysAlloc分配
<a class=anchor href=#4225-%e6%ad%a5%e9%aa%a4%e4%ba%94mheapsysalloc%e5%88%86%e9%85%8d>#</a></h4><p>mheap也找不到所需的空闲page，调用mmap，向系统申请新内存空间：</p><h1 id=5-对象的位图标记>5 对象的位图标记
<a class=anchor href=#5-%e5%af%b9%e8%b1%a1%e7%9a%84%e4%bd%8d%e5%9b%be%e6%a0%87%e8%ae%b0>#</a></h1><p>通过上述的内存申请流程，知道如何为对象申请一块内存。假设我们已经知道了对象的地址，根据地址来串联golang的内存管理单元(heapArena、mspan)，进而窥探golang垃圾回收阶段-进行对象扫描所依赖的底层内存结构。</p><ol><li>根据堆内存地址找到管理它的heapArean</li></ol><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240611235837.png width=50% height=50% alt=效果图></p><p>此arena的编号等于：<code>(p-arenaBaseoffset)/heapArenaBytes</code></p><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240612000931.png width=70% height=70% alt=效果图></p><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240612001038.png width=70% height=70% alt=效果图></p><ol start=2><li>根据堆内存地址找到管理它的mspan结构</li></ol><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240612001120.png width=100% height=100% alt=效果图></p>当我们找到地址对应的mspan，就能知道这个地址的对象最大的空间是多少了（即mspan.elemsize）。<ol start=3><li>根据堆内存地址找到对象所对应的结构是否存在指针</li></ol><p>接着遍历这块内存对应的位图(heapArena.bitmap)，就可以知道对象是否存在引用着其他对象。</p><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240612001232.png width=80% height=80% alt=效果图></p><ol start=4><li>相关的标记位
span.gcmarkBits表示对应的obj是否被gc标记。
heapArena.pageMarks记录的是哪些span中存在被标记过的对象。</li></ol><p align=left><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20240727211054.png width=80% height=80% alt=效果图></p><hr><hr><hr><h2 id=treap>treap
<a class=anchor href=#treap>#</a></h2><p><a href=https://go.dev/play/p/Ya7VlebyNw7>https://go.dev/play/p/Ya7VlebyNw7</a></p><h2 id=nextfreeindex>nextfreeindex
<a class=anchor href=#nextfreeindex>#</a></h2><p><a href=https://go.dev/play/p/DCeEXbirbqe>https://go.dev/play/p/DCeEXbirbqe</a></p><h2 id=p>P
<a class=anchor href=#p>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/runtime2.go#L576
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>p</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>id</span>          <span style=color:#66d9ef>int32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>status</span>      <span style=color:#66d9ef>uint32</span> <span style=color:#75715e>// one of pidle/prunning/...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>link</span>        <span style=color:#a6e22e>puintptr</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>schedtick</span>   <span style=color:#66d9ef>uint32</span>     <span style=color:#75715e>// incremented on every scheduler call
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>syscalltick</span> <span style=color:#66d9ef>uint32</span>     <span style=color:#75715e>// incremented on every system call
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>sysmontick</span>  <span style=color:#a6e22e>sysmontick</span> <span style=color:#75715e>// last tick observed by sysmon
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>m</span>           <span style=color:#a6e22e>muintptr</span>   <span style=color:#75715e>// back-link to associated m (nil if idle)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>mcache</span>      <span style=color:#f92672>*</span><span style=color:#a6e22e>mcache</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pcache</span>      <span style=color:#a6e22e>pageCache</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>raceprocctx</span> <span style=color:#66d9ef>uintptr</span>
</span></span></code></pre></div><p>pageCache</p><p><a href=https://zhuanlan.zhihu.com/p/487455942>https://zhuanlan.zhihu.com/p/487455942</a></p><h2 id=areahint>areaHint
<a class=anchor href=#areahint>#</a></h2><p>src/runtime/malloc.go:434</p><p><a href=https://go.dev/play/p/brDHCCSwCoI>https://go.dev/play/p/brDHCCSwCoI</a></p><pre tabindex=0><code>0x00007FFF FFFFFFFF
</code></pre><pre tabindex=0><code>p:0x00007f0130000000
p:7e0130000000
===================10000000000
p:7d0130000000
===================10000000000
p:7c0130000000
</code></pre><p>从上面可以看出，系统是从下半段区域开始扩展的，至于原因：在 64 位机器上，Go 选择从内存地址空间的中间开始分配堆内存，目的是避免和其他映射冲突，并且使得在调试时 Go 堆内存地址更容易识别。同时，在 gccgo 等编译器中，栈扫描仍然是保守的，这意味着要确保内存地址与其他数据区分开来。</p><p><a href="https://go.dev/play/p/yuEbw87oeLP?v=goprev">https://go.dev/play/p/yuEbw87oeLP?v=goprev</a>
<a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;mid=2247486732&amp;idx=1&amp;sn=435d5e834e9751036c96384f6965b328&amp;chksm=ce77cb4bf900425d33d2adfa632a4684cf7a63beece166c1ffedc4fdacb807c9413e8c73f298&amp;scene=178&amp;cur_album_id=2559805446807928833#rd">https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247486732&idx=1&sn=435d5e834e9751036c96384f6965b328&chksm=ce77cb4bf900425d33d2adfa632a4684cf7a63beece166c1ffedc4fdacb807c9413e8c73f298&scene=178&cur_album_id=2559805446807928833#rd</a>
<img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20230817213504.png alt=20230817213504></p><h2 id=areas>areas
<a class=anchor href=#areas>#</a></h2><p>对于那些不由 Go 堆支持的地址空间区域，arena 映射表包含 nil</p><pre tabindex=0><code>arenas [1 &lt;&lt; arenaL1Bits]*[1 &lt;&lt; arenaL2Bits]*heapArena
</code></pre><hr><pre tabindex=0><code>
获取其所在 L2 映射； 如果 L2 映射不存在，则创建一个新的 L2 映射。
检查该 arena 是否已经初始化； 如果已经初始化，则抛出异常。
为该 arena 分配元数据； 如果从 heapArenaAlloc 分配失败，则使用 persistentalloc 进行分配。
将该 arena 添加到 allArenas 列表中； 如果 allArenas 列表已满，则分配一个新的更大的 backing array。
</code></pre><h2 id=nextfreefast>nextFreeFast
<a class=anchor href=#nextfreefast>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#75715e>// nextFreeFast returns the next free object if one is quickly available.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Otherwise it returns 0.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>nextFreeFast</span>(<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span>) <span style=color:#a6e22e>gclinkptr</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>theBit</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sys</span>.<span style=color:#a6e22e>Ctz64</span>(<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>allocCache</span>) <span style=color:#75715e>// Is there a free object in the allocCache?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>theBit</span> &lt; <span style=color:#ae81ff>64</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>result</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>freeindex</span> <span style=color:#f92672>+</span> uintptr(<span style=color:#a6e22e>theBit</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>result</span> &lt; <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>nelems</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>freeidx</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>result</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>freeidx</span><span style=color:#f92672>%</span><span style=color:#ae81ff>64</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>freeidx</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>nelems</span> {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>allocCache</span> <span style=color:#f92672>&gt;&gt;=</span> uint(<span style=color:#a6e22e>theBit</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>freeindex</span> = <span style=color:#a6e22e>freeidx</span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>allocCount</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>gclinkptr</span>(<span style=color:#a6e22e>result</span><span style=color:#f92672>*</span><span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>elemsize</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>base</span>())
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=https://go.dev/play/p/MrAAyDAassZ>https://go.dev/play/p/MrAAyDAassZ</a></p><h2 id=arm64>arm64
<a class=anchor href=#arm64>#</a></h2><p><a href=https://www.zhihu.com/question/28638698>https://www.zhihu.com/question/28638698</a></p><pre tabindex=0><code>16 8  4  2  1
1  1  1  1  1
</code></pre><p>5位的系统，只使用了4位的虚拟地址，所以虚拟空间只是占用两头，而中间没有使用到,总共占用<code>2^4=16</code>个地址空间。</p><pre tabindex=0><code>11111
11110
11101
11100
11011
11010
11001
11000
-----
10111
.....
01000
-----
00111
00110
00101
00100
00011
00010
00001
00000
</code></pre><pre tabindex=0><code>+--------------------+   111      
|                    |            
|                    |            
|                    |            
|                    |            
|                    |            
|                    |            
|                    |            
|--------------------| 11000      
|                    |            
|                    |            
|                    |            
|                    |            
|                    |            
|                    |            
|                    |            
|                    |            
|                    |            
|                    |            
|                    |            
|                    |            
|                    |            
|                    |            
|                    |            
|--------------------- 00111      
|                    |            
|                    |            
|                    |            
|                    |            
|                    |            
|                    |            
|                    |            
+--------------------+            
</code></pre><p>需要把这两块地址空间串联起来，高位地址空间距离<code>00000</code>的偏移量为<code>11000</code>，所以减去11000(非符号位取反+1,符号位不变;注意这里没有符号位，00111+1=01000);从而得到两块地址空间如下：</p><pre tabindex=0><code>00111
00110
00101
00100
00011
00010
00001
00000

01111
01110
01101
01100
01011
01010
01001
01000
</code></pre><p>其实我们应该换个角度来看问题，还记得计算机组成原理里面无处不在的局部性原理么？</p><p>每个进程都有 4GB 的虚拟地址空间，而显然对于大多数程序来说，其使用到的空间远未达到 4GB，因为会存在部分对应的页表项都是空的，根本没有分配，对于已分配的页表项，如果存在最近一定时间未访问的页表，在物理内存紧张的情况下，操作系统会将页面换出到硬盘，也就是说不会占用物理内存。</p><p>如果使用了二级分页，一级页表就可以覆盖整个 4GB 虚拟地址空间，但如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表。做个简单的计算，假设只有 20% 的一级页表项被用到了，那么页表占用的内存空间就只有 4KB（一级页表） + 20% * 4MB（二级页表）= 0.804MB，这对比单级页表的 4MB 是不是一个巨大的节约？</p><p>那么为什么不分级的页表就做不到这样节约内存呢？</p><p>我们从页表的性质来看，保存在内存中的页表承担的职责是将虚拟地址翻译成物理地址。假如虚拟地址在页表中找不到对应的页表项，计算机系统就不能工作了。所以页表一定要覆盖全部虚拟地址空间，不分级的页表就需要有 100 多万个页表项来映射，而二级分页则只需要 1024 个页表项（此时一级页表覆盖到了全部虚拟地址空间，二级页表在需要时创建）。</p><h2 id=结构>结构
<a class=anchor href=#%e7%bb%93%e6%9e%84>#</a></h2><p>on-heap 和 off-heap 的区别是这个对象占用的内存是否支持垃圾自动回收</p><p>off-heap的对象，必须只能手动管理，比如heapArena，mspan等runtime中的数据结构</p><pre tabindex=0><code>type mheap struct {
	_ sys.NotInHeap

	// lock must only be acquired on the system stack, otherwise a g
	// could self-deadlock if its stack grows with the lock held.
	lock mutex

	pages pageAlloc // page allocation data structure
</code></pre><p>pageAlloc：页面分配器把<strong>整个虚拟地址空间</strong>划分（假想的）成一个个8KB对齐的大小为8KB的页面，分配器采用位图管理页面分配情况。因为虚拟地址空间过于庞大，所以对位图做了划分，每512个页面，使用一个位图。</p><p><a href=https://github.com/golang/go/blob/fe10464358057778732e9c958683039beb64e61a/src/runtime/mpagealloc.go#L179>https://github.com/golang/go/blob/fe10464358057778732e9c958683039beb64e61a/src/runtime/mpagealloc.go#L179</a></p><hr><pre tabindex=0><code>2^13 * sizeof(pallocData)
</code></pre><pre tabindex=0><code>2^13*(16*8)=2^13*128=2^(13+7)=2^20=1M
</code></pre><pre tabindex=0><code>2^13*2^13*512*8*2^10=256*2^40=2^48=256T
</code></pre><p>由于每个 runtime.heapArena 都会管理 64MB 的内存，整个堆区最多可以管理 256TB 的内存，这比之前的 512GB 多好几个数量级。</p><p>mheap.allocSpan函数利用pageAlloc来分配mspan
都是在mspan的基础之上来进一步分配的;</p><p>golang对象分配采用的是:</p><ul><li>sequential allocation<ul><li>sequential allocation 的实现方式非常简单，只需要把维护的空间直接分配出去就好，每次分配以后挪动指针，指向剩余空闲的位置的首地址，runtime off-heap object allocator一节中介绍的<code>persistent allocator</code>采用的就是sequential allocation这个方式。</li></ul></li><li>free-list allocation<ul><li>free list allocation 这种分配方式相对sequential allocation这种方式没能更好的利用上缓存的空间局部性原理，并且分配的时候速度慢，虽然有first fit 、next fit、best fit三种寻找空闲块的策略 ，但是多少还是会造成外部碎片。但是free list allocation 可以支持立马把释放的空间放到list中用于后续的分配。</li></ul></li><li>segregated-fit allocator<ul><li>设置K个size class ，各自的大小是s1,s2&mldr;sk (从小到大排队)，当程序需要S大小空间的时候，给其分配sn这么多的空间(<code>sn&lt;=S&lt;sn+1</code>)，每种size class都有一个分配器，专门分配这个大小，这样相比 free list allocation 可以免去寻找合适内存块的过程。但是会造成更多的浪费，因为对象的大小不一定正好等于slot的大小。调整size class 的个数和每个的大小是减少浪费的关键。</li><li>segregated-fit allocation 还有一个好处是可以非常方便的处理指向对象内部的指针，这可以为垃圾回收提供便利，对于任何一个指针，可以很轻松的找到这个指针所指向的对象的首地址。</li></ul></li></ul><hr><p>struct mm_struct: memory manage
struct vm_area_struct: vma: Virtual memory area</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;fcntl.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/mman.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/stat.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define handle_error(msg) \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    do { perror(msg); exit(EXIT_FAILURE); } while (0)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>argv[])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span>          fd;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span>         <span style=color:#f92672>*</span>addr;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>off_t</span>        offset, pa_offset;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span>       length;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>ssize_t</span>      s;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> stat  sb;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>||</span> argc <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>4</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fprintf</span>(stderr, <span style=color:#e6db74>&#34;%s file offset [length]</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, argv[<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>exit</span>(EXIT_FAILURE);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    fd <span style=color:#f92672>=</span> <span style=color:#a6e22e>open</span>(argv[<span style=color:#ae81ff>1</span>], O_RDONLY);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (fd <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>handle_error</span>(<span style=color:#e6db74>&#34;open&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>fstat</span>(fd, <span style=color:#f92672>&amp;</span>sb) <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)           <span style=color:#75715e>/* To obtain file size */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>handle_error</span>(<span style=color:#e6db74>&#34;fstat&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    offset <span style=color:#f92672>=</span> <span style=color:#a6e22e>atoi</span>(argv[<span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>    pa_offset <span style=color:#f92672>=</span> offset <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>(<span style=color:#a6e22e>sysconf</span>(_SC_PAGE_SIZE) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* offset for mmap() must be page aligned */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (offset <span style=color:#f92672>&gt;=</span> sb.st_size) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fprintf</span>(stderr, <span style=color:#e6db74>&#34;offset is past end of file</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>exit</span>(EXIT_FAILURE);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>==</span> <span style=color:#ae81ff>4</span>) {
</span></span><span style=display:flex><span>        length <span style=color:#f92672>=</span> <span style=color:#a6e22e>atoi</span>(argv[<span style=color:#ae81ff>3</span>]);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (offset <span style=color:#f92672>+</span> length <span style=color:#f92672>&gt;</span> sb.st_size)
</span></span><span style=display:flex><span>            length <span style=color:#f92672>=</span> sb.st_size <span style=color:#f92672>-</span> offset;
</span></span><span style=display:flex><span>                <span style=color:#75715e>/* Can&#39;t display bytes past end of file */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {    <span style=color:#75715e>/* No length arg ==&gt; display to end of file */</span>
</span></span><span style=display:flex><span>        length <span style=color:#f92672>=</span> sb.st_size <span style=color:#f92672>-</span> offset;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    addr <span style=color:#f92672>=</span> <span style=color:#a6e22e>mmap</span>(NULL, length <span style=color:#f92672>+</span> offset <span style=color:#f92672>-</span> pa_offset, PROT_READ,
</span></span><span style=display:flex><span>                MAP_PRIVATE, fd, pa_offset);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (addr <span style=color:#f92672>==</span> MAP_FAILED)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>handle_error</span>(<span style=color:#e6db74>&#34;mmap&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    s <span style=color:#f92672>=</span> <span style=color:#a6e22e>write</span>(STDOUT_FILENO, addr <span style=color:#f92672>+</span> offset <span style=color:#f92672>-</span> pa_offset, length);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (s <span style=color:#f92672>!=</span> length) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (s <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>handle_error</span>(<span style=color:#e6db74>&#34;write&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fprintf</span>(stderr, <span style=color:#e6db74>&#34;partial write&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>exit</span>(EXIT_FAILURE);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>munmap</span>(addr, length <span style=color:#f92672>+</span> offset <span style=color:#f92672>-</span> pa_offset);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>close</span>(fd);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>exit</span>(EXIT_SUCCESS);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;fcntl.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/mman.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/stat.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define handle_error(msg) \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    do { perror(msg); exit(EXIT_FAILURE); } while (0)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>argv[])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>v<span style=color:#f92672>=</span><span style=color:#ae81ff>0x7f216f308000</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>
</span></span><span style=display:flex><span>	p :<span style=color:#f92672>=</span> <span style=color:#a6e22e>mmap</span>(v, n, PROT_NONE, MAP_ANON<span style=color:#f92672>|</span>MAP_PRIVATE, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (p <span style=color:#f92672>==</span> MAP_FAILED)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>handle_error</span>(<span style=color:#e6db74>&#34;mmap&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>munmap</span>(addr, <span style=color:#ae81ff>20</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>exit</span>(EXIT_SUCCESS);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><script src=https://giscus.app/client.js data-repo=zput/utterances-comments data-repo-id=R_kgDOHhATGQ data-category=Announcements data-category-id=DIC_kwDOHhATGc4CPxca data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=1 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#1-前言>1 前言</a></li><li><a href=#2-评估内存大小>2 评估内存大小</a><ul><li><a href=#21-内存对齐>2.1 内存对齐</a></li></ul></li><li><a href=#3-分配内存>3 分配内存</a><ul><li><a href=#31-tcmalloc>3.1 Tcmalloc</a></li></ul></li><li><a href=#4-golang内存管理>4 golang内存管理</a><ul><li><a href=#41-内存结构>4.1 内存结构</a></li><li><a href=#42-内存管理结构>4.2 内存管理结构</a><ul><li><a href=#421-mspan>4.2.1 mspan</a></li><li><a href=#422-heaparena>4.2.2 heapArena</a></li><li><a href=#422-mheap>4.2.2 mheap</a></li><li><a href=#4221-mcentral>4.2.2.1 mcentral</a></li><li><a href=#423-mcache>4.2.3 mcache</a></li></ul></li><li><a href=#42-内存申请流程>4.2 内存申请流程</a><ul><li><a href=#421-宏观流程>4.2.1 宏观流程</a></li><li><a href=#422-微观流程>4.2.2 微观流程</a><ul><li><a href=#4221-步骤一mcachetiny分配>4.2.2.1 步骤一：mcache.tiny分配</a></li><li><a href=#4222-步骤二mcachealloc分配>4.2.2.2 步骤二：mcache.alloc分配</a></li><li><a href=#4223-步骤三mheapmcentral分配>4.2.2.3 步骤三：mheap.mcentral分配</a></li><li><a href=#4224-步骤四mheappagealloc分配>4.2.2.4 步骤四：mheap.pageAlloc分配</a></li><li><a href=#4225-步骤五mheapsysalloc分配>4.2.2.5 步骤五：mheap.sysAlloc分配</a></li></ul></li></ul></li></ul></li><li><a href=#5-对象的位图标记>5 对象的位图标记</a><ul><li><a href=#treap>treap</a></li><li><a href=#nextfreeindex>nextfreeindex</a></li><li><a href=#p>P</a></li><li><a href=#areahint>areaHint</a></li><li><a href=#areas>areas</a></li><li><a href=#nextfreefast>nextFreeFast</a></li><li><a href=#arm64>arm64</a></li><li><a href=#结构>结构</a></li></ul></li></ul></nav></div></aside></main></body></html><script type=text/javascript src=https://cdn.bootcss.com/viz.js/1.8.2/viz.js></script><script type=text/javascript>(function(){var e="language-viz-";Array.prototype.forEach.call(document.querySelectorAll("[class^="+e+"]"),function(t){console.log(t),t.getAttribute("class").split(" ").forEach(function(t){t.startsWith(e)&&(s=t.substr(e.length))}),console.log("------------MIDDLE--------");var s,o=Viz(t.innerText,{format:"svg",engine:s}),n=(new DOMParser).parseFromString(o,"image/svg+xml");n.documentElement.setAttribute("style","max-width:100%; max-height:100%;"),t.parentNode.insertBefore(n.documentElement,t),t.style.display="none",t.parentNode.style.backgroundColor="white",t.style.width=n.documentElement.getAttribute("width")+"px",t.style.height=n.documentElement.getAttribute("height")+"px",console.log("--------------END------")})})()</script>