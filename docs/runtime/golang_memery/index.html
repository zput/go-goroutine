<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="内存分配器 # //go:notinheap type mheap struct { //... // arenas is the heap arena map. It points to the metadata for // the heap for every arena frame of the entire usable virtual // address space. // // Use arenaIndex to compute indexes into this array. // // For regions of the address space that are not backed by the // Go heap, the arena map contains nil. // // Modifications are protected by mheap_."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="内存分配器"><meta property="og:description" content="内存分配器 # //go:notinheap type mheap struct { //... // arenas is the heap arena map. It points to the metadata for // the heap for every arena frame of the entire usable virtual // address space. // // Use arenaIndex to compute indexes into this array. // // For regions of the address space that are not backed by the // Go heap, the arena map contains nil. // // Modifications are protected by mheap_."><meta property="og:type" content="article"><meta property="og:url" content="https://zput.github.io/go-goroutine/docs/runtime/golang_memery/"><meta property="article:section" content="docs"><title>内存分配器 | go调度源码分析</title><link rel=manifest href=/go-goroutine/manifest.json><link rel=icon href=/go-goroutine/favicon.png type=image/x-icon><link rel=stylesheet href=/go-goroutine/book.min.76f6dbe75c94e688c018dd8b54e7f880916b14ab4cf3881b81f75d6bb916603c.css integrity="sha256-dvbb51yU5ojAGN2LVOf4gJFrFKtM84gbgfdda7kWYDw=" crossorigin=anonymous><script defer src=/go-goroutine/flexsearch.min.js></script>
<script defer src=/go-goroutine/en.search.min.c282ec4e193a9e68f93a9e4cfe4ce8b40f3f33d292675901d4e6b3e426acb499.js integrity="sha256-woLsThk6nmj5Op5M/kzotA8/M9KSZ1kB1Oaz5CastJk=" crossorigin=anonymous></script>
<script defer src=/go-goroutine/sw.min.ec96d6e09af3075a94dd4de723a2edddf2ef138381c7e1e5b5a1f2c0578ee8bd.js integrity="sha256-7JbW4JrzB1qU3U3nI6Lt3fLvE4OBx+HltaHywFeO6L0=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/go-goroutine/><span>go调度源码分析</span></a></h2><div class=magic><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><div class=book-switch><label class=switch><input id=dark-mode-checkbox type=checkbox onchange=darkmode()>
<span class=slider></span></label></div></div><ul><li><a href=https://zput.github.io target=_blank rel=noopener>Zput博客</a></li><li><a href=https://github.com/zput target=_blank rel=noopener>GitHub</a></li></ul><hr><ul><li><span>基础知识</span><ul><li><a href=/go-goroutine/docs/foundation/golang_basic/>基本用法</a></li><li><a href=/go-goroutine/docs/foundation/slice/>slice</a></li><li><a href=/go-goroutine/docs/foundation/map/>map</a></li><li><a href=/go-goroutine/docs/foundation/sort/>sort</a></li><li><a href=/go-goroutine/docs/foundation/directory/>Directory</a></li></ul></li><li><span>鲁棒和性能</span><ul><li><a href=/go-goroutine/docs/robustness_and_performance/golang_test/>测试相关函数</a></li></ul></li><li><span>运行时</span><ul><li><a href=/go-goroutine/docs/runtime/golang_gmp/>GMP</a></li><li><a href=/go-goroutine/docs/runtime/golang_memery/ class=active>内存分配器</a></li><li><a href=/go-goroutine/docs/runtime/golang_gc/>垃圾回收</a></li><li><a href=/go-goroutine/docs/runtime/schedule/>调度</a><ul><li><span>前置知识</span><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/memory/>内存大小端</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/register_functionstack/>伪寄存器与函数栈帧</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/similar_assemble/>类汇编</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/go_underlying_struct/>底层重要结构</a></li></ul></li><li><a href=/go-goroutine/docs/runtime/schedule/2_init_before_enter_main_function/>初始化</a></li><li><a href=/go-goroutine/docs/runtime/schedule/3_exit_goroutine/>退出</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/>调度挑选策略</a><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/take_goroutine_from_globalorlocal_p/>从全局/本P队列</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/steal_goroutine_from_other_p/>从其他P队列</a></li></ul></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/>调度到达时机</a><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/active_scheduling/>主动调度</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/passive_scheduling/>被动调度</a></li><li><input type=checkbox id=section-99f41010918d678e89a7af90330cabe1 class=toggle>
<label for=section-99f41010918d678e89a7af90330cabe1 class="flex justify-between"><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/>剥夺调度</a></label><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/start_sysmon/>开启系统监控</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/user_code_preemption/>代码执行过久</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/system_call_preemption/>陷入系统调用</a></li></ul></li></ul></li></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script><script src=/go-goroutine/magic.js></script>
<script src=/go-goroutine/dark.js></script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/go-goroutine/svg/menu.svg class=book-icon alt=Menu></label>
<strong>内存分配器</strong>
<label for=toc-control><img src=/go-goroutine/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#内存分配器>内存分配器</a><ul><li><a href=#heaparena>heapArena</a></li><li><a href=#span>span</a></li></ul></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h3 id=内存分配器>内存分配器
<a class=anchor href=#%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%99%a8>#</a></h3><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210408201124.png alt=20210408201124></p><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/gc_heap.png alt=gc_heap></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>//go:notinheap
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>mheap</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span><span style=color:#75715e>//...    
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// arenas is the heap arena map. It points to the metadata for
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// the heap for every arena frame of the entire usable virtual
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// address space.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Use arenaIndex to compute indexes into this array.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// For regions of the address space that are not backed by the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Go heap, the arena map contains nil.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Modifications are protected by mheap_.lock. Reads can be
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// performed without locking; however, a given entry can
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// transition from nil to non-nil at any time when the lock
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// isn&#39;t held. (Entries never transitions back to nil.)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// In general, this is a two-level mapping consisting of an L1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// map and possibly many L2 maps. This saves space when there
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// are a huge number of arena frames. However, on many
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// platforms (even 64-bit), arenaL1Bits is 0, making this
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// effectively a single-level map. In this case, arenas[0]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// will never be nil.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>arenas</span> [<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#a6e22e>arenaL1Bits</span>]<span style=color:#f92672>*</span>[<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#a6e22e>arenaL2Bits</span>]<span style=color:#f92672>*</span><span style=color:#a6e22e>heapArena</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//A heapArena stores metadata for a heap arena.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 每一个heapArena管理一个heap arena.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>heapArena</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bitmap</span> [<span style=color:#a6e22e>heapArenaBitmapBytes</span>]<span style=color:#66d9ef>byte</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>spans</span> [<span style=color:#a6e22e>pagesPerArena</span>]<span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pageInUse</span> [<span style=color:#a6e22e>pagesPerArena</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>8</span>]<span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pageMarks</span> [<span style=color:#a6e22e>pagesPerArena</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>8</span>]<span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>zeroedBase</span> <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>mspan</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>next</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>prev</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>startAddr</span> <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// 起始地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>npages</span>    <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// 页数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>freeindex</span> <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>allocBits</span>  <span style=color:#f92672>*</span><span style=color:#a6e22e>gcBits</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>gcmarkBits</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gcBits</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>allocCache</span> <span style=color:#66d9ef>uint64</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    <span style=color:#75715e>//startAddr 和 npages — 确定该结构体管理的多个页所在的内存，每个页的大小都是 8KB；
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	    <span style=color:#75715e>//freeindex — 扫描页中空闲对象的初始索引；
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	    <span style=color:#75715e>//allocBits 和 gcmarkBits — 分别用于标记内存的占用和回收情况；
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	    <span style=color:#75715e>//allocCache — allocBits 的补码，可以用于快速查找内存中未被使用的内存；
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span></code></pre></div><p><a href=https://github.com/golang/go/blob/e7f9e17b7927cad7a93c5785e864799e8d9b4381/src/runtime/mheap.go#L152>mheap</a></p><p><a href=https://github.com/golang/go/blob/e7f9e17b7927cad7a93c5785e864799e8d9b4381/src/runtime/mheap.go#L217>heapArena</a></p><h4 id=heaparena>heapArena
<a class=anchor href=#heaparena>#</a></h4><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210120104547.png alt=20210120104547></p><ul><li>mheap中每个arena对应一个HeapArena，记录arena的元数据信息。HeapArena中有一个<strong>bitmap和一个spans</strong>字段。<ul><li>1.bitmap<ul><li>bitmap中每两个bit对应标记arena中一个指针大小的word，也就是说bitmap中<strong>一个byte</strong>可以标记<strong>arena中连续四个指针大小</strong>的内存。<ul><li>每个word对应的两个bit中，<strong>低位bit用于标记是否为指针</strong>，0为非指针，1为指针；<strong>高位bit用于标记是否要继续扫描</strong>，<code>高位bit为1</code>就代表扫描完当前word并不能完成当前数据对象的扫描。</li></ul></li></ul></li><li>2.spans<ul><li>spans是一个*mspan类型的数组，用于记录当前arena中每一页对应到哪一个mspan。(看这个mspan的结构可以知道，它有startAddr与npages,说明一个mspan管理多个page)</li></ul></li></ul></li></ul><blockquote><p>基于HeapArena记录的元数据信息，我们只要知道一个对象的地址，</p><blockquote><p>就可以根据HeapArena.bitmap信息扫描它内部是否含有指针；
也可以根据对象地址计算出它在哪一页，然后通过HeapArena.spans信息查到该对象存在哪一个mspan中。</p></blockquote></blockquote><h4 id=span>span
<a class=anchor href=#span>#</a></h4><ul><li>而每个span都对应两个位图标记：mspan.allocBits和mspan.gcmarkBits。<ul><li>（1）allocBits中每一位用于标记一个对象存储单元是否已分配。<ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210113202836.png alt=20210113202836></li></ul></li><li>（2）<code>gcmarkBits</code>中每一位用于标记<strong>一个对象是否存活</strong>。<ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210113202858.png alt=20210113202858></li></ul></li></ul></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><script src=https://giscus.app/client.js data-repo=zput/utterances-comments data-repo-id=R_kgDOHhATGQ data-category=Announcements data-category-id=DIC_kwDOHhATGc4CPxca data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=1 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#内存分配器>内存分配器</a><ul><li><a href=#heaparena>heapArena</a></li><li><a href=#span>span</a></li></ul></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>