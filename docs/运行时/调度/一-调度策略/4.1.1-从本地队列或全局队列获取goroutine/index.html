<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="从本地队列或全局队列获取goroutine # 分析schedule函数 # src/runtime/proc.go
// One round of scheduler: find a runnable goroutine and execute it. // Never returns. func schedule() { _g_ := getg() //... top: //... var gp *g var inheritTime bool //... if gp == nil { // Check the global runnable queue once in a while to ensure fairness. // Otherwise two goroutines can completely occupy the local runqueue // by constantly respawning each other."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="从队列获取goroutine"><meta property="og:description" content="从本地队列或全局队列获取goroutine # 分析schedule函数 # src/runtime/proc.go
// One round of scheduler: find a runnable goroutine and execute it. // Never returns. func schedule() { _g_ := getg() //... top: //... var gp *g var inheritTime bool //... if gp == nil { // Check the global runnable queue once in a while to ensure fairness. // Otherwise two goroutines can completely occupy the local runqueue // by constantly respawning each other."><meta property="og:type" content="article"><meta property="og:url" content="https://zput.github.io/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/%E4%B8%80-%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/4.1.1-%E4%BB%8E%E6%9C%AC%E5%9C%B0%E9%98%9F%E5%88%97%E6%88%96%E5%85%A8%E5%B1%80%E9%98%9F%E5%88%97%E8%8E%B7%E5%8F%96goroutine/"><meta property="article:section" content="docs"><meta property="article:published_time" content="2020-03-02T13:03:00+00:00"><meta property="article:modified_time" content="2020-03-02T13:03:00+00:00"><title>从队列获取goroutine | go调度源码分析</title><link rel=manifest href=/go-goroutine/manifest.json><link rel=icon href=/go-goroutine/favicon.png type=image/x-icon><link rel=stylesheet href=/go-goroutine/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css integrity="sha256-gsXb0jRHzuC0wqo+0Izglh+qQOH6Nw7uT4yfAuDUa18=" crossorigin=anonymous><script defer src=/go-goroutine/flexsearch.min.js></script>
<script defer src=/go-goroutine/en.search.min.b4fe7742fccb260d00a3ac1cdf65747d5bf890031d0792ed5e26577f357557a8.js integrity="sha256-tP53QvzLJg0Ao6wc32V0fVv4kAMdB5LtXiZXfzV1V6g=" crossorigin=anonymous></script>
<script defer src=/go-goroutine/sw.min.ec96d6e09af3075a94dd4de723a2edddf2ef138381c7e1e5b5a1f2c0578ee8bd.js integrity="sha256-7JbW4JrzB1qU3U3nI6Lt3fLvE4OBx+HltaHywFeO6L0=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/go-goroutine/><span>go调度源码分析</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://zput.github.io target=_blank rel=noopener>Zput博客</a></li><li><a href=https://github.com/zput target=_blank rel=noopener>GitHub</a></li></ul><hr><ul><li><span>基础知识</span><ul><li><a href=/go-goroutine/docs/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/golang_basic/>基本用法</a></li></ul></li><li><span>健壮与性能</span><ul><li><a href=/go-goroutine/docs/%E5%81%A5%E5%A3%AE%E4%B8%8E%E6%80%A7%E8%83%BD/golang_test/>测试相关函数</a></li></ul></li><li><span>运行时</span><ul><li><a href=/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/golang_gmp/>GMP</a></li><li><a href=/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/golang_gc/>垃圾回收</a></li><li><a href=/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/>调度</a><ul><li><span>前置知识</span><ul><li><a href=/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/preknowledge/memory/>内存大小端</a></li><li><a href=/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/preknowledge/register_functionstack/>伪寄存器</a></li><li><a href=/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/preknowledge/similar_assemble/>类汇编函数</a></li><li><a href=/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/preknowledge/global_g_queue/>全局G队列</a></li></ul></li><li><a href=/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/2_init_before_enter_main_function/>初始化</a></li><li><input type=checkbox id=section-4ad8a00adbec3893f6c5db43a3f2fc72 class=toggle checked>
<label for=section-4ad8a00adbec3893f6c5db43a3f2fc72 class="flex justify-between"><a role=button>调度策略</a></label><ul><li><a href=/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/%E4%B8%80-%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/4.1.2-%E7%9B%97%E5%8F%96goroutine%E4%BB%8E%E5%85%B6%E4%BB%96%E9%98%9F%E5%88%97/>盗取goroutine</a></li><li><a href=/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/%E4%B8%80-%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/4.1.1-%E4%BB%8E%E6%9C%AC%E5%9C%B0%E9%98%9F%E5%88%97%E6%88%96%E5%85%A8%E5%B1%80%E9%98%9F%E5%88%97%E8%8E%B7%E5%8F%96goroutine/ class=active>从队列获取goroutine</a></li></ul></li><li><input type=checkbox id=section-da1a4198fe20413d9888e739425b5df0 class=toggle>
<label for=section-da1a4198fe20413d9888e739425b5df0 class="flex justify-between"><a href=/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/%E4%BA%8C-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA/>调度时机</a></label><ul><li><a href=/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/%E4%BA%8C-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA/4.2.1-%E4%B8%BB%E5%8A%A8%E8%B0%83%E5%BA%A6/>主动调度</a></li><li><a href=/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/%E4%BA%8C-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA/4.2.2-%E8%A2%AB%E5%8A%A8%E8%B0%83%E5%BA%A6/>被动调度</a></li><li><input type=checkbox id=section-5fa1bc00e046d2c14caea8c58f1b9628 class=toggle>
<label for=section-5fa1bc00e046d2c14caea8c58f1b9628 class="flex justify-between"><a role=button>剥夺调度</a></label><ul><li><a href=/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/%E4%BA%8C-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA/4.2.3-%E5%89%A5%E5%A4%BA%E8%B0%83%E5%BA%A6/4.2.3.1-%E8%BF%90%E8%A1%8C%E7%94%A8%E6%88%B7%E4%BB%A3%E7%A0%81%E6%97%B6%E9%97%B4%E8%BF%87%E9%95%BF%E8%B0%83%E5%BA%A6/>运行用户代码时间过长调度</a></li><li><a href=/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/%E4%BA%8C-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA/4.2.3-%E5%89%A5%E5%A4%BA%E8%B0%83%E5%BA%A6/4.2.3.2-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%94%B6%E5%B0%BE%E5%A6%82%E6%9E%9C%E4%BB%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%BF%94%E5%9B%9E%E5%A6%82%E4%BD%95%E9%87%8D%E6%96%B0%E5%BE%97%E5%88%B0P/>系统调用收尾,如从系统调用返回,如何重新得到P</a></li></ul></li></ul></li><li><input type=checkbox id=section-1d9ef7158540fca01ab9b01e7778b8a4 class=toggle>
<label for=section-1d9ef7158540fca01ab9b01e7778b8a4 class="flex justify-between"><a role=button>调度循环</a></label><ul><li><a href=/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/%E4%B8%89-%E8%B0%83%E5%BA%A6%E5%BE%AA%E7%8E%AF/4.3.1-%E8%B0%83%E5%BA%A6%E5%BE%AA%E7%8E%AF/>调度循环</a></li></ul></li><li><a href=/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/3_exit_goroutine/>退出</a></li></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/go-goroutine/svg/menu.svg class=book-icon alt=Menu></label>
<strong>从队列获取goroutine</strong>
<label for=toc-control><img src=/go-goroutine/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#从本地队列或全局队列获取goroutine>从本地队列或全局队列获取goroutine</a><ul><li><a href=#分析schedule函数>分析schedule函数</a><ul><li><a href=#全局运行队列中获取goroutine>全局运行队列中获取goroutine</a></li><li><a href=#本地运行队列当前线程中获取goroutine>本地运行队列(当前线程)中获取Goroutine</a></li><li><a href=#p的本地队列是怎么构成的>P的本地队列是怎么构成的</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=从本地队列或全局队列获取goroutine>从本地队列或全局队列获取goroutine
<a class=anchor href=#%e4%bb%8e%e6%9c%ac%e5%9c%b0%e9%98%9f%e5%88%97%e6%88%96%e5%85%a8%e5%b1%80%e9%98%9f%e5%88%97%e8%8e%b7%e5%8f%96goroutine>#</a></h1><h2 id=分析schedule函数>分析schedule函数
<a class=anchor href=#%e5%88%86%e6%9e%90schedule%e5%87%bd%e6%95%b0>#</a></h2><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/schedule%28%29%E5%87%BD%E6%95%B0.png alt=schedule()函数></p><p><a href=/go-goroutine/>src/runtime/proc.go</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// One round of scheduler: find a runnable goroutine and execute it.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Never returns.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>schedule</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_g_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>top</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>gp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>inheritTime</span> <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gp</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Check the global runnable queue once in a while to ensure fairness.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// Otherwise two goroutines can completely occupy the local runqueue
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// by constantly respawning each other.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>().<span style=color:#a6e22e>schedtick</span><span style=color:#f92672>%</span><span style=color:#ae81ff>61</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>runqsize</span> &gt; <span style=color:#ae81ff>0</span> { <span style=color:#75715e>//schedtick就是调度次数,如果能被61整除且全局的Goroutine队列不为空就尝试获取
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>gp</span> = <span style=color:#a6e22e>globrunqget</span>(<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>(), <span style=color:#ae81ff>1</span>)     <span style=color:#75715e>//全局运行队列中获取goroutine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gp</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>inheritTime</span> = <span style=color:#a6e22e>runqget</span>(<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>())  <span style=color:#75715e>//本地运行队列(当前线程)中获取goroutine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gp</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>spinning</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;schedule: spinning with local work&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gp</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>         则调用findrunnable函数从其它工作线程的运行队列中偷取，如果偷取不到，则当前工作线程进入睡眠,
</span></span></span><span style=display:flex><span><span style=color:#75715e>         直到获取到需要运行的goroutine之后findrunnable函数才会返回.
</span></span></span><span style=display:flex><span><span style=color:#75715e>        */</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>inheritTime</span> = <span style=color:#a6e22e>findrunnable</span>() <span style=color:#75715e>// blocks until work is available
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// This thread is going to run a goroutine and is not spinning anymore,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// so if it was marked as spinning we need to reset it now and potentially
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// start a new spinning M.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>spinning</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>resetspinning</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>execute</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>inheritTime</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>schedule函数按顺序分三步分别来获取可运行的Goroutine: 全局队列，本地G队列和其他P上面的G队列<ul><li>第一步:从全局运行G队列中寻找Goroutine。<ul><li>因为全局上面拿Goroutine是需要加锁的,尽量少从上面拿;</li><li>所以当一个P调度了61次之后且全局的Goroutine队列不为空，为了保证调度能运行全局G队列，所以尝试调度一下。</li></ul></li><li>第二步:从工作线程本地运行队列[其实就是当前线程关联的P上面的运行G队列，因为一个P在同一时刻只能与一个M关联，此时就不需要加锁]中寻找Goroutine。</li><li>第三步:从P的运行队列中偷取Goroutine。如果上一步也没有，则调用findrunnable从其他工作线程的运行队列中偷取Goroutine，在偷取之前,findrunnable函数会再次尝试从全局运行G队列和当前P运行G队列中查找需要运行的Goroutine。</li></ul></li></ul><h3 id=全局运行队列中获取goroutine>全局运行队列中获取goroutine
<a class=anchor href=#%e5%85%a8%e5%b1%80%e8%bf%90%e8%a1%8c%e9%98%9f%e5%88%97%e4%b8%ad%e8%8e%b7%e5%8f%96goroutine>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Try get a batch of G&#39;s from the global runnable queue.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Sched must be locked.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>globrunqget</span>(<span style=color:#a6e22e>_p_</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>max</span> <span style=color:#66d9ef>int32</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>runqsize</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {  <span style=color:#75715e>//如果全局的G队列为空,直接返回nil
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>        - 如果gomaxprocs==1;sched.runqsize==1;
</span></span></span><span style=display:flex><span><span style=color:#75715e>        - 导致(n==2)&gt;sched.runqsize[全局的队列长度1];
</span></span></span><span style=display:flex><span><span style=color:#75715e>        - 需要判断下，取两者少的数;
</span></span></span><span style=display:flex><span><span style=color:#75715e>    */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>runqsize</span><span style=color:#f92672>/</span><span style=color:#a6e22e>gomaxprocs</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#75715e>//按照P的数量平分全局队列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span> &gt; <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>runqsize</span> { <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>n</span> = <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>runqsize</span> <span style=color:#75715e>//取两者少的数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>max</span> &gt; <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>n</span> &gt; <span style=color:#a6e22e>max</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>n</span> = <span style=color:#a6e22e>max</span> <span style=color:#75715e>//取两者少的数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span> &gt; int32(len(<span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runq</span>))<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span> {  <span style=color:#75715e>//取本地队列的一半长最多
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>n</span> = int32(len(<span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runq</span>)) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>runqsize</span> <span style=color:#f92672>-=</span> <span style=color:#a6e22e>n</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>runq</span>.<span style=color:#a6e22e>pop</span>() <span style=color:#75715e>//返回第一个,其他放入本地队列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>n</span><span style=color:#f92672>--</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> ; <span style=color:#a6e22e>n</span> &gt; <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>n</span><span style=color:#f92672>--</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>gp1</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>runq</span>.<span style=color:#a6e22e>pop</span>()
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>runqput</span>(<span style=color:#a6e22e>_p_</span>, <span style=color:#a6e22e>gp1</span>, <span style=color:#66d9ef>false</span>) <span style=color:#75715e>//-------------------------here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>        这里如果put G到本地满了,它又会put到全局.
</span></span></span><span style=display:flex><span><span style=color:#75715e>        If the run queue is full, runnext puts g on the global queue.
</span></span></span><span style=display:flex><span><span style=color:#75715e>        */</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>gp</span>
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>从上面的注释很容易看懂,只有一个需要注意,<code>-------------------------here</code></p><ul><li><strong>取本地队列的一半长最多</strong><ul><li>如果本身本地队列就是快满了,后面for循环继续加就会导致本地队列满了;</li><li>所以<code>runqput</code>函数又会把<code>Goroutine</code>加到全局里面去.</li></ul></li></ul><h5 id=runqput>runqput
<a class=anchor href=#runqput>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>- runqput尝试将g放在本地可运行队列中。
</span></span></span><span style=display:flex><span><span style=color:#75715e>  1. &gt;如果 next 为 false，runqput 将 g 加到可运行队列的尾部。
</span></span></span><span style=display:flex><span><span style=color:#75715e>  2. 如果 next 为真，runqput 将 g 放在 _p_.runnext 槽中。
</span></span></span><span style=display:flex><span><span style=color:#75715e>  3. 如果运行队列满了，runnext就把g放到全局队列中。
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>runqput</span>(<span style=color:#a6e22e>_p_</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>gp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>next</span> <span style=color:#66d9ef>bool</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>randomizeScheduler</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>next</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>fastrand</span>()<span style=color:#f92672>%</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>next</span> = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>next</span> { <span style=color:#75715e>//第二步所说的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>retryNext</span>:
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>oldnext</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runnext</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runnext</span>.<span style=color:#a6e22e>cas</span>(<span style=color:#a6e22e>oldnext</span>, <span style=color:#a6e22e>guintptr</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>gp</span>))) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>retryNext</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>oldnext</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Kick the old runnext out to the regular run queue.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>gp</span> = <span style=color:#a6e22e>oldnext</span>.<span style=color:#a6e22e>ptr</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>retry</span>:
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>h</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>LoadAcq</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runqhead</span>) <span style=color:#75715e>// load-acquire, synchronize with consumers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runqtail</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span><span style=color:#f92672>-</span><span style=color:#a6e22e>h</span> &lt; uint32(len(<span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runq</span>)) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runq</span>[<span style=color:#a6e22e>t</span><span style=color:#f92672>%</span>uint32(len(<span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runq</span>))].<span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>gp</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>StoreRel</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runqtail</span>, <span style=color:#a6e22e>t</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>) <span style=color:#75715e>// store-release, makes the item available for consumption
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>runqputslow</span>(<span style=color:#a6e22e>_p_</span>, <span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>h</span>, <span style=color:#a6e22e>t</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// the queue is not full, now the put above must succeed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>retry</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=本地运行队列当前线程中获取goroutine>本地运行队列(当前线程)中获取Goroutine
<a class=anchor href=#%e6%9c%ac%e5%9c%b0%e8%bf%90%e8%a1%8c%e9%98%9f%e5%88%97%e5%bd%93%e5%89%8d%e7%ba%bf%e7%a8%8b%e4%b8%ad%e8%8e%b7%e5%8f%96goroutine>#</a></h3><ul><li>本地运行队列其实分为两个部分:<ul><li>一部分是由P的<code>runq</code>、<code>runqhead</code>和<code>runqtail</code>这三个成员组成的一个<strong>无锁循环队列</strong>，该队列最多可包含256个<code>Goroutine</code>;</li><li>另一部分是P的<code>runnext</code>成员，它是一个指向g结构体对象的指针，它最多只包含一个<code>Goroutine</code>.</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>p</span> <span style=color:#66d9ef>struct</span>{
</span></span><span style=display:flex><span>	<span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>runqhead</span> <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>runqtail</span> <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>runq</span>     [<span style=color:#ae81ff>256</span>]<span style=color:#a6e22e>guintptr</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// runnext, if non-nil, is a runnable G that was ready&#39;d by
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// the current G and should be run next instead of what&#39;s in
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// runq if there&#39;s time remaining in the running G&#39;s time
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// slice. It will inherit the time left in the current time
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// slice. If a set of goroutines is locked in a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// communicate-and-wait pattern, this schedules that set as a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// unit and eliminates the (potentially large) scheduling
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// latency that otherwise arises from adding the ready&#39;d
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// goroutines to the end of the run queue.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>runnext</span> <span style=color:#a6e22e>guintptr</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h5 id=runqget>runqget
<a class=anchor href=#runqget>#</a></h5><ul><li>实现是由<code>runqget</code>函数完成的:<ul><li>首先查看<code>runnext</code>成员是否为空，如果不为空则返回<code>runnext</code>所指的<code>Goroutine</code>，并把<code>runnext</code>成员清零;</li><li>如果<code>runnext</code>为空，则继续从本地循环队列中查找<code>Goroutine</code>.</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Get g from local runnable queue.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// If inheritTime is true, gp should inherit the remaining time in the
</span></span></span><span style=display:flex><span><span style=color:#75715e>// current time slice. Otherwise, it should start a new time slice.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Executed only by the owner P.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>runqget</span>(<span style=color:#a6e22e>_p_</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>p</span>) (<span style=color:#a6e22e>gp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>inheritTime</span> <span style=color:#66d9ef>bool</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// If there&#39;s a runnext, it&#39;s the next G to run.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>next</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runnext</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>next</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> { <span style=color:#75715e>// runnext是空的,break for loop,然后从队列里面拿
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runnext</span>.<span style=color:#a6e22e>cas</span>(<span style=color:#a6e22e>next</span>, <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>next</span>.<span style=color:#a6e22e>ptr</span>(), <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>h</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>LoadAcq</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runqhead</span>) <span style=color:#75715e>// load-acquire, synchronize with other consumers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runqtail</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>h</span> { <span style=color:#75715e>// 如果头等于尾，证明是队列是空的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runq</span>[<span style=color:#a6e22e>h</span><span style=color:#f92672>%</span>uint32(len(<span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runq</span>))].<span style=color:#a6e22e>ptr</span>()
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>CasRel</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runqhead</span>, <span style=color:#a6e22e>h</span>, <span style=color:#a6e22e>h</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>) { <span style=color:#75715e>// cas-release, commits consume
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>gp</span>, <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=p的本地队列是怎么构成的>P的本地队列是怎么构成的
<a class=anchor href=#p%e7%9a%84%e6%9c%ac%e5%9c%b0%e9%98%9f%e5%88%97%e6%98%af%e6%80%8e%e4%b9%88%e6%9e%84%e6%88%90%e7%9a%84>#</a></h3><blockquote><p>从上面已经知道本地运行G队列是由这三个field组成的，那么他们是怎么组织的？</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>p</span> <span style=color:#66d9ef>struct</span>{
</span></span><span style=display:flex><span>	<span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>runqhead</span> <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>runqtail</span> <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>runq</span>     [<span style=color:#ae81ff>256</span>]<span style=color:#a6e22e>guintptr</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// runnext, if non-nil, is a runnable G that was ready&#39;d by
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// the current G and should be run next instead of what&#39;s in
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// runq if there&#39;s time remaining in the running G&#39;s time
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// slice. It will inherit the time left in the current time
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// slice. If a set of goroutines is locked in a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// communicate-and-wait pattern, this schedules that set as a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// unit and eliminates the (potentially large) scheduling
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// latency that otherwise arises from adding the ready&#39;d
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// goroutines to the end of the run queue.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>runnext</span> <span style=color:#a6e22e>guintptr</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>通过这两个函数:runqget与runqput,来看下它们是怎么运作的,我们先列出入队和出队的代码,来看一下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>/* 
</span></span></span><span style=display:flex><span><span style=color:#75715e>----------------here:  这里是入队，把Goroutine放入本地运行队列
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>h</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>LoadAcq</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runqhead</span>) <span style=color:#75715e>// load-acquire, synchronize with consumers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runqtail</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span><span style=color:#f92672>-</span><span style=color:#a6e22e>h</span> &lt; uint32(len(<span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runq</span>)) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runq</span>[<span style=color:#a6e22e>t</span><span style=color:#f92672>%</span>uint32(len(<span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runq</span>))].<span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>gp</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>StoreRel</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runqtail</span>, <span style=color:#a6e22e>t</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>) <span style=color:#75715e>// store-release, makes the item available for consumption,runqhead不动,runqtail加一.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//----------------------------------------------------------------------------------------------------------
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>h</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>LoadAcq</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runqhead</span>) <span style=color:#75715e>// load-acquire, synchronize with other consumers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runqtail</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>h</span> { <span style=color:#75715e>// 如果头等于尾，证明是队列是空的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runq</span>[<span style=color:#a6e22e>h</span><span style=color:#f92672>%</span>uint32(len(<span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runq</span>))].<span style=color:#a6e22e>ptr</span>()
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>CasRel</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runqhead</span>, <span style=color:#a6e22e>h</span>, <span style=color:#a6e22e>h</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>) { <span style=color:#75715e>// cas-release, commits consume,runqhead加一,runqtail不动.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>gp</span>, <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><ul><li>入队<ul><li>runqhead不动,runqtail加一</li></ul></li><li>出队<ul><li>runqhead加一,runqtail不动.</li></ul></li></ul><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/goroutine%E8%B0%83%E5%BA%A6%20%281%29.png alt=P本地运行队列></p><h4 id=为什么要用len>为什么要用len
<a class=anchor href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8len>#</a></h4><p>它的那个<code>gp := _p_.runq[h%uint32(len(_p_.runq))].ptr()</code>为什么不直接用256，而需要用到<code>len(_p_.runq)</code>,如果是为了以后的扩展，那么可以定义一个常量来替代就行了.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>lenghtForQueue</span> = <span style=color:#ae81ff>256</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>lenghtForQueueVar</span> = <span style=color:#ae81ff>256</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#75715e>//var runq     [lenghtForQueue]uintptr
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>runq</span>     [<span style=color:#a6e22e>lenghtForQueueVar</span>]<span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(len(<span style=color:#a6e22e>runq</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>不能使用变量,只能使用常量：<code>gdb/main.go:23:15: non-constant array bound lenghtForQueueVar</code>.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><script src=https://giscus.app/client.js data-repo=zput/utterances-comments data-repo-id=R_kgDOHhATGQ data-category=Announcements data-category-id=DIC_kwDOHhATGc4CPxca data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=1 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#从本地队列或全局队列获取goroutine>从本地队列或全局队列获取goroutine</a><ul><li><a href=#分析schedule函数>分析schedule函数</a><ul><li><a href=#全局运行队列中获取goroutine>全局运行队列中获取goroutine</a></li><li><a href=#本地运行队列当前线程中获取goroutine>本地运行队列(当前线程)中获取Goroutine</a></li><li><a href=#p的本地队列是怎么构成的>P的本地队列是怎么构成的</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>