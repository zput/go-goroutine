<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>调度中断恢复 on go调度源码分析</title><link>https://zput.github.io/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/%E4%BA%8C-%E8%B0%83%E5%BA%A6%E4%B8%AD%E6%96%AD%E6%81%A2%E5%A4%8D/</link><description>Recent content in 调度中断恢复 on go调度源码分析</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Thu, 02 Apr 2020 11:03:00 +0000</lastBuildDate><atom:link href="https://zput.github.io/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/%E4%BA%8C-%E8%B0%83%E5%BA%A6%E4%B8%AD%E6%96%AD%E6%81%A2%E5%A4%8D/index.xml" rel="self" type="application/rss+xml"/><item><title>主动中断调度</title><link>https://zput.github.io/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/%E4%BA%8C-%E8%B0%83%E5%BA%A6%E4%B8%AD%E6%96%AD%E6%81%A2%E5%A4%8D/4.2.1-%E4%B8%BB%E5%8A%A8%E8%B0%83%E5%BA%A6/</link><pubDate>Thu, 02 Apr 2020 11:03:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/%E4%BA%8C-%E8%B0%83%E5%BA%A6%E4%B8%AD%E6%96%AD%E6%81%A2%E5%A4%8D/4.2.1-%E4%B8%BB%E5%8A%A8%E8%B0%83%E5%BA%A6/</guid><description>goroutine主动中断调度 # 探寻runtime.Gosched() # goroutine主动调度就是调用runtime.Gosched()函数, 此函数会主动放弃与M的关联,并把自身(G)放入全局空闲G队列.当前的goroutine并不会退出,它进入全局G队列后可能会再次被调度运行.
src/runtime/proc.go:267
// Gosched yields the processor, allowing other goroutines to run. It does not // suspend the current goroutine, so execution resumes automatically. func Gosched() { checkTimeouts() mcall(gosched_m) } 在go1.14前,编译器不会插入抢占点,用户代码可能会陷入CPU计算循环(即使代码中有函数调用),它可能会一直霸占CPU,这时候可能需要runtime.Gosched, 在go1.14,编译器会在函数前加入自动抢占点.所以对于go1.14+，无需手动调用它。
gdb主动调度 # main.go
package main import ( &amp;#34;runtime&amp;#34; &amp;#34;sync/atomic&amp;#34; ) var existFlag int32 = 2 // the function&amp;#39;s body is empty func addAssemble(x, y int64) int64 func add(a int64){ addAssemble(a, a) atomic.AddInt32(&amp;amp;existFlag, -1) } func main() { runtime.</description></item><item><title>被动中断</title><link>https://zput.github.io/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/%E4%BA%8C-%E8%B0%83%E5%BA%A6%E4%B8%AD%E6%96%AD%E6%81%A2%E5%A4%8D/4.2.2-%E8%A2%AB%E5%8A%A8%E8%B0%83%E5%BA%A6/</link><pubDate>Wed, 15 Apr 2020 11:33:07 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/%E4%BA%8C-%E8%B0%83%E5%BA%A6%E4%B8%AD%E6%96%AD%E6%81%A2%E5%A4%8D/4.2.2-%E8%A2%AB%E5%8A%A8%E8%B0%83%E5%BA%A6/</guid><description>goroutine被动中断 # 什么是被动调度: goroutine执行某个操作因条件不满足需要等待而发生的调度； goroutine进入睡眠[比如是Goroutine N发送数据到无缓冲chan上面,当没有其他Goroutine从chan上面读数据的时候,Goroutine N阻塞在chan上面. 此刻睡眠含义:进入chan的缓存读取队列(goroutine链表)]; 重新运行schedule() 唤醒睡眠中的goroutine; 唤醒空闲的P和唤醒创建工作线程; goroutine(被创建出来后/创建运行了一段时间后)如何放入运行队列[P中]; 探寻被动中断,如何进入睡眠 # goroutine因某个条件而阻塞 chan waitGroup 等这些都会发生阻塞 定义程序 # 先来看一个例子,
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;runtime&amp;#34; &amp;#34;sync&amp;#34; &amp;#34;sync/atomic&amp;#34; ) func main() { var n int32 var wg sync.WaitGroup runtime.GOMAXPROCS(2) wg.Add(1) go func() { wg.Done() for{ atomic.AddInt32(&amp;amp;n, 1) } }() wg.Wait() fmt.Println(atomic.LoadInt32(&amp;amp;n)) // 1 } gdb调试前准备 # 编译程序 # 编译一下源代码: go build -gcflags &amp;quot;-N -l&amp;quot; -o test ..
准备mcall函数断点的文件 # 进入wg.</description></item></channel></rss>