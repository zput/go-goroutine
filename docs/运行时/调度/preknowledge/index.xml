<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>前置知识 on go调度源码分析</title><link>https://zput.github.io/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/preknowledge/</link><description>Recent content in 前置知识 on go调度源码分析</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Thu, 28 Feb 2019 15:03:00 +0000</lastBuildDate><atom:link href="https://zput.github.io/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/preknowledge/index.xml" rel="self" type="application/rss+xml"/><item><title>内存大小端</title><link>https://zput.github.io/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/preknowledge/memory/</link><pubDate>Sun, 20 Jan 2019 09:03:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/preknowledge/memory/</guid><description>内存大小端 # 对于这两种存储方式，如果联系下我们常用 “异或” 操作，就能得到一个很好的记忆规则。总结来说就是：
低地址存储低字节即为小端存储；高地址存储高字节即为小端存储； 低地址存储高字节即为大端存储；高地址存储低字节即为大端存储； 我们把 “低” 、“小” 认作 “0”， 把 “高”、“大” 认作 “1”，这样就可以利用 “异或” 的结果来加强记忆了。
内存 字节 大端/小端 低地址 低字节 小端存储 0 0 0 高地址 高字节 小端存储 1 1 0 低地址 高字节 大端存储 0 1 1 高地址 低字节 大端存储 1 0 1 intel 存储字节的顺序是小端优先：即低有效字节存储在低内存地址中。写值是从低地址向高地址写入，如SP指向0xf000，往栈中写入一个字（8字节），占用0xf000到0xf007的8个字节。</description></item><item><title>伪寄存器</title><link>https://zput.github.io/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/preknowledge/register_functionstack/</link><pubDate>Thu, 28 Feb 2019 15:03:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/preknowledge/register_functionstack/</guid><description>伪寄存器 &amp;amp; 函数栈 # 伪寄存器 # 伪寄存器常用的一般是下面的四个:
FP: Frame pointer: arguments and locals. PC: Program counter: jumps and branches. SB: Static base pointer: global symbols. SP: Stack pointer: top of stack. 下面我们来翻译一下 官网1的对他们的解释，然后做一个总结,方便理解。
FP # FP伪寄存器是一个用于引用函数参数的虚拟帧指针。编译器维护一个虚拟帧指针，并将堆栈上的参数引用为该伪寄存器的偏移量。因此0(FP)是函数的第一个参数，8(FP)是第二个参数(在64位机器上)，以此类推。但是，当以这种方式引用一个函数参数时，有必要将名称放在开头，如first_arg+0(FP)和second_arg+8(FP)。(偏移量的含义(从帧指针出发的偏移量)与它在SB中的使用不同，在SB中，它是从符号出发的偏移量。) 汇编器强制执行这个约定，拒绝普通的0(FP)和8(FP)。实际的名称在语义上是不相关的，但应该用来记录参数的名称。值得强调的是，FP始终是一个伪寄存器，而不是硬件寄存器，即使在具有硬件帧指针的架构上也是如此。
The FP pseudo-register is a virtual frame pointer used to refer to function arguments. The compilers maintain a virtual frame pointer and refer to the arguments on the stack as offsets from that pseudo-register.</description></item><item><title>类汇编</title><link>https://zput.github.io/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/preknowledge/similar_assemble/</link><pubDate>Thu, 28 Feb 2019 15:03:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/preknowledge/similar_assemble/</guid><description>golang类汇编指令 # 寻址模式 # (DI)(BX2): The location at address DI plus BX2. 64(DI)(BX2): The location at address DI plus BX2 plus 64. These modes accept only 1, 2, 4, and 8 as scale factors. 结构体+寄存器 # 类似这种:
# (m_morebuf+gobuf_pc)(REGISTER) MOVQ 8(SP), AX # f&amp;#39;s caller&amp;#39;s PC MOVQ AX, (m_morebuf+gobuf_pc)(BX) type m struct { g0 *g // goroutine with scheduling stack morebuf gobuf // gobuf arg to morestack //-----------morebuf-------------// divmod uint32 // div/mod denominator for arm - known to liblink //.</description></item><item><title>全局G队列</title><link>https://zput.github.io/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/preknowledge/global_g_queue/</link><pubDate>Sun, 20 Jan 2019 09:03:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/preknowledge/global_g_queue/</guid><description>golang全局Goroutine队列 # 全局运行队列(Global runnable queue),指队列里面的Goroutine的状态都是_Grunnable,可以运行,随时可运行,只要能被调度起来,调度起来就变成了运行中_Grunning.
var ( allglen uintptr allm *m allp []*p // len(allp) == gomaxprocs; may change at safe points, otherwise immutable allpLock mutex // Protects P-less reads of allp and all writes gomaxprocs int32 ncpu int32 sched schedt //... ) type schedt struct { //... // Global runnable queue. 全局运行队列 runq gQueue runqsize int32 //... } // A gQueue is a dequeue of Gs linked through g.</description></item></channel></rss>