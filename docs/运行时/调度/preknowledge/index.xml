<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>前置知识 on go调度源码分析</title><link>https://zput.github.io/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/preknowledge/</link><description>Recent content in 前置知识 on go调度源码分析</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Thu, 28 Feb 2019 15:03:00 +0000</lastBuildDate><atom:link href="https://zput.github.io/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/preknowledge/index.xml" rel="self" type="application/rss+xml"/><item><title>内存大小端</title><link>https://zput.github.io/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/preknowledge/memory/</link><pubDate>Sun, 20 Jan 2019 09:03:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/preknowledge/memory/</guid><description> 内存大小端 # 对于这两种存储方式，如果联系下我们常用 “异或” 操作，就能得到一个很好的记忆规则。总结来说就是：
低地址存储低字节即为小端存储；高地址存储高字节即为小端存储； 低地址存储高字节即为大端存储；高地址存储低字节即为大端存储； 我们把 “低” 、“小” 认作 “0”， 把 “高”、“大” 认作 “1”，这样就可以利用 “异或” 的结果来加强记忆了。
内存 字节 大端/小端 低地址 低字节 小端存储 0 0 0 高地址 高字节 小端存储 1 1 0 低地址 高字节 大端存储 0 1 1 高地址 低字节 大端存储 1 0 1</description></item><item><title>类汇编函数</title><link>https://zput.github.io/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/preknowledge/similar_assemble/</link><pubDate>Thu, 28 Feb 2019 15:03:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/preknowledge/similar_assemble/</guid><description>类汇编函数 # go汇编 # gdb golang assamble non-split; sp bp 会更新吗?
main function enter BP is useful ? schedule
dropg()函数 # dropg() //解除g和m之间的关系; func dropg() { _g_ := getg() setMNoWB(&amp;amp;_g_.m.curg.m, nil) setGNoWB(&amp;amp;_g_.m.curg, nil) } park_m函数 # 通过mcall从gN转到g0; stack转移了, jmp跳转到park_m(*g)函数, # gN&amp;ndash;&amp;gt;m &amp;mdash;&amp;gt; gN mcall怎么保证g0的m指向了m的?
// park continuation on g0. func park_m(gp *g) { _g_ := getg() if trace.enabled { traceGoPark(_g_.m.waittraceev, _g_.m.waittraceskip) } casgstatus(gp, _Grunning, _Gwaiting) dropg() //解除g和m之间的关系 ...... schedule() } get_tls函数 # TEXT runtime·rt0_go(SB),NOSPLIT,$0 //.</description></item><item><title>全局G队列</title><link>https://zput.github.io/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/preknowledge/global_g_queue/</link><pubDate>Sun, 20 Jan 2019 09:03:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/preknowledge/global_g_queue/</guid><description>golang全局Goroutine队列 # 全局运行队列(Global runnable queue),指队列里面的Goroutine的状态都是_Grunnable,可以运行,随时可运行,只要能被调度起来,调度起来就变成了运行中_Grunning.
var ( allglen uintptr allm *m allp []*p // len(allp) == gomaxprocs; may change at safe points, otherwise immutable allpLock mutex // Protects P-less reads of allp and all writes gomaxprocs int32 ncpu int32 sched schedt //... ) type schedt struct { //... // Global runnable queue. 全局运行队列 runq gQueue runqsize int32 //... } // A gQueue is a dequeue of Gs linked through g.</description></item></channel></rss>