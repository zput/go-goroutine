<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="伪寄存器 & 函数栈 # 伪寄存器 # 伪寄存器常用的一般是下面的四个:
FP: Frame pointer: arguments and locals. PC: Program counter: jumps and branches. SB: Static base pointer: global symbols. SP: Stack pointer: top of stack. 下面我们来翻译一下 官网1的对他们的解释，然后做一个总结,方便理解。
FP # FP伪寄存器是一个用于引用函数参数的虚拟帧指针。编译器维护一个虚拟帧指针，并将堆栈上的参数引用为该伪寄存器的偏移量。因此0(FP)是函数的第一个参数，8(FP)是第二个参数(在64位机器上)，以此类推。但是，当以这种方式引用一个函数参数时，有必要将名称放在开头，如first_arg+0(FP)和second_arg+8(FP)。(偏移量的含义(从帧指针出发的偏移量)与它在SB中的使用不同，在SB中，它是从符号出发的偏移量。) 汇编器强制执行这个约定，拒绝普通的0(FP)和8(FP)。实际的名称在语义上是不相关的，但应该用来记录参数的名称。值得强调的是，FP始终是一个伪寄存器，而不是硬件寄存器，即使在具有硬件帧指针的架构上也是如此。
The FP pseudo-register is a virtual frame pointer used to refer to function arguments. The compilers maintain a virtual frame pointer and refer to the arguments on the stack as offsets from that pseudo-register."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="伪寄存器"><meta property="og:description" content="伪寄存器 & 函数栈 # 伪寄存器 # 伪寄存器常用的一般是下面的四个:
FP: Frame pointer: arguments and locals. PC: Program counter: jumps and branches. SB: Static base pointer: global symbols. SP: Stack pointer: top of stack. 下面我们来翻译一下 官网1的对他们的解释，然后做一个总结,方便理解。
FP # FP伪寄存器是一个用于引用函数参数的虚拟帧指针。编译器维护一个虚拟帧指针，并将堆栈上的参数引用为该伪寄存器的偏移量。因此0(FP)是函数的第一个参数，8(FP)是第二个参数(在64位机器上)，以此类推。但是，当以这种方式引用一个函数参数时，有必要将名称放在开头，如first_arg+0(FP)和second_arg+8(FP)。(偏移量的含义(从帧指针出发的偏移量)与它在SB中的使用不同，在SB中，它是从符号出发的偏移量。) 汇编器强制执行这个约定，拒绝普通的0(FP)和8(FP)。实际的名称在语义上是不相关的，但应该用来记录参数的名称。值得强调的是，FP始终是一个伪寄存器，而不是硬件寄存器，即使在具有硬件帧指针的架构上也是如此。
The FP pseudo-register is a virtual frame pointer used to refer to function arguments. The compilers maintain a virtual frame pointer and refer to the arguments on the stack as offsets from that pseudo-register."><meta property="og:type" content="article"><meta property="og:url" content="https://zput.github.io/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/preknowledge/register_functionstack/"><meta property="article:section" content="docs"><meta property="article:published_time" content="2019-02-28T15:03:00+00:00"><meta property="article:modified_time" content="2019-02-28T15:03:00+00:00"><title>伪寄存器 | go调度源码分析</title><link rel=manifest href=/go-goroutine/manifest.json><link rel=icon href=/go-goroutine/favicon.png type=image/x-icon><link rel=stylesheet href=/go-goroutine/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css integrity="sha256-gsXb0jRHzuC0wqo+0Izglh+qQOH6Nw7uT4yfAuDUa18=" crossorigin=anonymous><script defer src=/go-goroutine/flexsearch.min.js></script>
<script defer src=/go-goroutine/en.search.min.b4fe7742fccb260d00a3ac1cdf65747d5bf890031d0792ed5e26577f357557a8.js integrity="sha256-tP53QvzLJg0Ao6wc32V0fVv4kAMdB5LtXiZXfzV1V6g=" crossorigin=anonymous></script>
<script defer src=/go-goroutine/sw.min.ec96d6e09af3075a94dd4de723a2edddf2ef138381c7e1e5b5a1f2c0578ee8bd.js integrity="sha256-7JbW4JrzB1qU3U3nI6Lt3fLvE4OBx+HltaHywFeO6L0=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/go-goroutine/><span>go调度源码分析</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://zput.github.io target=_blank rel=noopener>Zput博客</a></li><li><a href=https://github.com/zput target=_blank rel=noopener>GitHub</a></li></ul><hr><ul><li><span>基础知识</span><ul><li><a href=/go-goroutine/docs/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/golang_basic/>基本用法</a></li></ul></li><li><span>健壮与性能</span><ul><li><a href=/go-goroutine/docs/%E5%81%A5%E5%A3%AE%E4%B8%8E%E6%80%A7%E8%83%BD/golang_test/>测试相关函数</a></li></ul></li><li><span>运行时</span><ul><li><a href=/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/golang_gmp/>GMP</a></li><li><a href=/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/golang_gc/>垃圾回收</a></li><li><a href=/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/>调度</a><ul><li><span>前置知识</span><ul><li><a href=/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/preknowledge/memory/>内存大小端</a></li><li><a href=/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/preknowledge/register_functionstack/ class=active>伪寄存器</a></li><li><a href=/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/preknowledge/similar_assemble/>类汇编函数</a></li><li><a href=/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/preknowledge/global_g_queue/>全局G队列</a></li></ul></li><li><a href=/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/2_init_before_enter_main_function/>初始化</a></li><li><input type=checkbox id=section-4ad8a00adbec3893f6c5db43a3f2fc72 class=toggle>
<label for=section-4ad8a00adbec3893f6c5db43a3f2fc72 class="flex justify-between"><a role=button>调度策略</a></label><ul><li><a href=/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/%E4%B8%80-%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/4.1.2-%E7%9B%97%E5%8F%96goroutine%E4%BB%8E%E5%85%B6%E4%BB%96%E9%98%9F%E5%88%97/>盗取goroutine</a></li><li><a href=/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/%E4%B8%80-%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/4.1.1-%E4%BB%8E%E6%9C%AC%E5%9C%B0%E9%98%9F%E5%88%97%E6%88%96%E5%85%A8%E5%B1%80%E9%98%9F%E5%88%97%E8%8E%B7%E5%8F%96goroutine/>从队列获取goroutine</a></li></ul></li><li><input type=checkbox id=section-da1a4198fe20413d9888e739425b5df0 class=toggle>
<label for=section-da1a4198fe20413d9888e739425b5df0 class="flex justify-between"><a href=/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/%E4%BA%8C-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA/>调度时机</a></label><ul><li><a href=/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/%E4%BA%8C-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA/4.2.1-%E4%B8%BB%E5%8A%A8%E8%B0%83%E5%BA%A6/>主动调度</a></li><li><a href=/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/%E4%BA%8C-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA/4.2.2-%E8%A2%AB%E5%8A%A8%E8%B0%83%E5%BA%A6/>被动调度</a></li><li><input type=checkbox id=section-5fa1bc00e046d2c14caea8c58f1b9628 class=toggle>
<label for=section-5fa1bc00e046d2c14caea8c58f1b9628 class="flex justify-between"><a role=button>剥夺调度</a></label><ul><li><a href=/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/%E4%BA%8C-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA/4.2.3-%E5%89%A5%E5%A4%BA%E8%B0%83%E5%BA%A6/4.2.3.1-%E8%BF%90%E8%A1%8C%E7%94%A8%E6%88%B7%E4%BB%A3%E7%A0%81%E6%97%B6%E9%97%B4%E8%BF%87%E9%95%BF%E8%B0%83%E5%BA%A6/>运行用户代码时间过长调度</a></li><li><a href=/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/%E4%BA%8C-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA/4.2.3-%E5%89%A5%E5%A4%BA%E8%B0%83%E5%BA%A6/4.2.3.2-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%94%B6%E5%B0%BE%E5%A6%82%E6%9E%9C%E4%BB%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%BF%94%E5%9B%9E%E5%A6%82%E4%BD%95%E9%87%8D%E6%96%B0%E5%BE%97%E5%88%B0P/>系统调用收尾,如从系统调用返回,如何重新得到P</a></li></ul></li></ul></li><li><input type=checkbox id=section-1d9ef7158540fca01ab9b01e7778b8a4 class=toggle>
<label for=section-1d9ef7158540fca01ab9b01e7778b8a4 class="flex justify-between"><a role=button>调度循环</a></label><ul><li><a href=/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/%E4%B8%89-%E8%B0%83%E5%BA%A6%E5%BE%AA%E7%8E%AF/4.3.1-%E8%B0%83%E5%BA%A6%E5%BE%AA%E7%8E%AF/>调度循环</a></li></ul></li><li><a href=/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/3_exit_goroutine/>退出</a></li></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/go-goroutine/svg/menu.svg class=book-icon alt=Menu></label>
<strong>伪寄存器</strong>
<label for=toc-control><img src=/go-goroutine/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#伪寄存器--函数栈>伪寄存器 & 函数栈</a><ul><li><a href=#伪寄存器>伪寄存器</a><ul><li><a href=#fp>FP</a></li><li><a href=#sp>SP</a></li><li><a href=#总结>总结</a></li></ul></li><li><a href=#函数调用>函数调用</a><ul><li><a href=#例子>例子</a></li></ul></li><li><a href=#gdb过程>gdb过程</a><ul><li><a href=#扩展>扩展</a></li></ul></li><li><a href=#添加汇编>添加汇编</a></li><li><a href=#例子-1>例子</a><ul><li><a href=#main-goroutine得不到执行>main goroutine得不到执行</a></li><li><a href=#一些汇编需要的常见的指令>一些汇编需要的常见的指令</a></li></ul></li><li><a href=#附录>附录</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=伪寄存器--函数栈>伪寄存器 & 函数栈
<a class=anchor href=#%e4%bc%aa%e5%af%84%e5%ad%98%e5%99%a8--%e5%87%bd%e6%95%b0%e6%a0%88>#</a></h1><h2 id=伪寄存器>伪寄存器
<a class=anchor href=#%e4%bc%aa%e5%af%84%e5%ad%98%e5%99%a8>#</a></h2><p>伪寄存器常用的一般是下面的四个:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>FP</span>: <span style=color:#a6e22e>Frame</span> <span style=color:#a6e22e>pointer</span>: <span style=color:#a6e22e>arguments</span> <span style=color:#a6e22e>and</span> <span style=color:#a6e22e>locals</span>.
</span></span><span style=display:flex><span><span style=color:#a6e22e>PC</span>: <span style=color:#a6e22e>Program</span> <span style=color:#a6e22e>counter</span>: <span style=color:#a6e22e>jumps</span> <span style=color:#a6e22e>and</span> <span style=color:#a6e22e>branches</span>.
</span></span><span style=display:flex><span><span style=color:#a6e22e>SB</span>: <span style=color:#a6e22e>Static</span> <span style=color:#a6e22e>base</span> <span style=color:#a6e22e>pointer</span>: <span style=color:#a6e22e>global</span> <span style=color:#a6e22e>symbols</span>.
</span></span><span style=display:flex><span><span style=color:#a6e22e>SP</span>: <span style=color:#a6e22e>Stack</span> <span style=color:#a6e22e>pointer</span>: <span style=color:#a6e22e>top</span> <span style=color:#a6e22e>of</span> <span style=color:#a6e22e>stack</span>.
</span></span></code></pre></div><p>下面我们来翻译一下
<a href=https://golang.org/doc/asm#symbols>官网<sup>1</sup></a>的对他们的解释，然后做一个总结,方便理解。</p><h3 id=fp>FP
<a class=anchor href=#fp>#</a></h3><blockquote><p>FP伪寄存器是一个用于引用<strong>函数参数</strong>的虚拟帧指针。编译器维护一个虚拟帧指针，并将堆栈上的参数引用为该伪寄存器的偏移量。因此0(FP)是函数的第一个参数，8(FP)是第二个参数(在64位机器上)，以此类推。但是，当以这种方式引用一个函数参数时，有必要将名称放在开头，如first_arg+0(FP)和second_arg+8(FP)。(偏移量的含义(从帧指针出发的偏移量)与它在SB中的使用不同，在SB中，它是从符号出发的偏移量。) 汇编器强制执行这个约定，拒绝普通的0(FP)和8(FP)。实际的名称在语义上是不相关的，但应该用来记录参数的名称。值得强调的是，FP始终是一个伪寄存器，而不是硬件寄存器，即使在具有硬件帧指针的架构上也是如此。</p></blockquote><blockquote><p>The FP pseudo-register is a virtual frame pointer used to refer to function arguments. The compilers maintain a virtual frame pointer and refer to the arguments on the stack as offsets from that pseudo-register. Thus 0(FP) is the first argument to the function, 8(FP) is the second (on a 64-bit machine), and so on. However, when referring to a function argument this way, it is necessary to place a name at the beginning, as in first_arg+0(FP) and second_arg+8(FP). (The meaning of the offset—offset from the frame pointer—distinct from its use with SB, where it is an offset from the symbol.) The assembler enforces this convention, rejecting plain 0(FP) and 8(FP). The actual name is semantically irrelevant but should be used to document the argument&rsquo;s name. It is worth stressing that FP is always a pseudo-register, not a hardware register, even on architectures with a hardware frame pointer.</p></blockquote><blockquote><p>对于带有Go原型的汇编函数，go vet会检查参数名和偏移量是否匹配。在32位系统上，64位值的低位和高位32位是通过在名称中添加一个_lo或_hi后缀来区分的，如arg_lo+0(FP)或arg_hi+4(FP)。如果一个Go原型没有给它的结果命名，那么预期的汇编名是ret。</p></blockquote><blockquote><p>For assembly functions with Go prototypes, go vet will check that the argument names and offsets match. On 32-bit systems, the low and high 32 bits of a 64-bit value are distinguished by adding a _lo or _hi suffix to the name, as in arg_lo+0(FP) or arg_hi+4(FP). If a Go prototype does not name its result, the expected assembly name is ret.</p></blockquote><h3 id=sp>SP
<a class=anchor href=#sp>#</a></h3><blockquote><p>SP伪寄存器是一个虚拟栈指针，用于引用帧本地变量和为函数调用准备的参数。它指向本地栈帧的顶部，所以引用时应使用负偏移量，范围为[-framesize，0)：x-8(SP)，y-4(SP)，以此类推。</p></blockquote><blockquote><p>The SP pseudo-register is a virtual stack pointer used to refer to frame-local variables and the arguments being prepared for function calls. It points to the top of the local stack frame, so references should use negative offsets in the range [−framesize, 0): x-8(SP), y-4(SP), and so on.</p></blockquote><blockquote><p>在具有名为SP的硬件寄存器的架构上，名称前缀可以区分对虚拟栈指针的引用和对架构SP寄存器的引用，即x-8(SP)，y-4(SP)，以此类推。也就是说，<code>x-8(SP)</code>和<code>-8(SP)</code>是不同的内存位置：第一个是指虚拟栈指针伪寄存器，而第二个是指硬件的SP寄存器。</p></blockquote><blockquote><p>On architectures with a hardware register named SP, the name prefix distinguishes references to the virtual stack pointer from references to the architectural SP register. That is, x-8(SP) and -8(SP) are different memory locations: the first refers to the virtual stack pointer pseudo-register, while the second refers to the hardware&rsquo;s SP register.</p></blockquote><h3 id=总结>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93>#</a></h3><ul><li>如何理解伪寄存器FP和SP呢？其实伪寄存器FP和SP相当于plan9伪汇编中的一个助记符，他们是根据当前函数栈空间计算出来的一个相对于物理寄存器SP的一个偏移量坐标。</li><li>伪SP和FP的相对位置是会变的，所以不应该尝试用伪SP寄存器去找那些本用FP+offset来引用的值，例如函数的入参和返回值。</li><li>官方文档中说的伪SP指向栈的top，是有问题的。其指向的局部变量位置实际上是整个栈的栈底（除caller BP 之外），所以说bottom更合适一些。</li><li><code>MOVQ 0(SP), AX</code>,这种前面没有flags的，它相当于<strong>实际的寄存器</strong>的值，<strong>不是</strong>伪寄存器了。</li></ul><h2 id=函数调用>函数调用
<a class=anchor href=#%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8>#</a></h2><p>函数调用栈的知识(为方便起见，在函数A1中调用函数A2,我们称A1是caller,A2是callee); 栈指每个进程/线程/goroutine都有自己的调用栈，参数和返回值的传递，函数的局部变量存储通常是通过栈来完成的。和数据结构中的栈一样，内存栈也是后进先出的，地址从高地址开始增长到低地址。栈帧也称为帧,每一帧对应一个尚未返回的函数调用，帧本身以栈的形式存储数据。栈由许多帧组成，它描述函数之间的调用关系.</p><p>如下图所示:内存中的栈从高地址空间向低地址空间增长，栈顶小于栈底，分配栈空间对应sp值减小。</p><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220622230646.png alt=20220622230646></p><p>其中caller与callee的关系在go1.17以下是下图所示，go1.17以上返回参数已使用
<a href=https://github.com/golang/go/issues/40724>寄存器方式传递</a></p><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220622204818.png alt=20220622204818></p><h3 id=例子>例子
<a class=anchor href=#%e4%be%8b%e5%ad%90>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Sub</span>(<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//go:noinline
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Sub</span>(<span style=color:#a6e22e>a</span> , <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>d</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>b</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>d</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>{{ <expand>}}</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#75715e># disass $pc,+40 </span>
</span></span></code></pre></div><p>{{</expand> }}</p><p>下面来一步一步来看下调用的过程:</p><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220622193033.png alt=20220622193033></p><hr><h2 id=gdb过程>gdb过程
<a class=anchor href=#gdb%e8%bf%87%e7%a8%8b>#</a></h2><ul><li>下面来做下实验。<ul><li>确认伪FP， SP相对于真实存在的寄存器的位置点<ul><li>我们伪FP应该在caller&rsquo;s next pc + 8byte</li><li>伪SP应该在caller&rsquo;s BP</li></ul></li></ul></li></ul><blockquote><p>main.go</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>test_FP_SP</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int64</span>)(<span style=color:#a6e22e>first</span> <span style=color:#66d9ef>uintptr</span>, <span style=color:#a6e22e>second</span> <span style=color:#66d9ef>uintptr</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>first</span>, <span style=color:#a6e22e>second</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mock</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>first</span> <span style=color:#f92672>-=</span> <span style=color:#a6e22e>second</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>first</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>mock</span>(<span style=color:#a6e22e>m1</span>, <span style=color:#a6e22e>m2</span> <span style=color:#66d9ef>int64</span>)(<span style=color:#a6e22e>r1</span> <span style=color:#66d9ef>uintptr</span>, <span style=color:#a6e22e>r2</span> <span style=color:#66d9ef>uintptr</span>){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>test_FP_SP</span>(<span style=color:#a6e22e>m1</span>, <span style=color:#a6e22e>m2</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>test_FP_SP.s</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// func test_FP_SP(a, b int64)(first uintptr, second uintptr)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>TEXT</span> <span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>test_FP_SP</span>(<span style=color:#a6e22e>SB</span>),<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>4112</span><span style=color:#f92672>-</span><span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>LEAQ</span> <span style=color:#a6e22e>x</span><span style=color:#f92672>-</span><span style=color:#ae81ff>0</span>(<span style=color:#a6e22e>SP</span>), <span style=color:#a6e22e>DI</span>         <span style=color:#75715e>// 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>MOVQ</span> <span style=color:#a6e22e>DI</span>, <span style=color:#a6e22e>first</span><span style=color:#f92672>+</span><span style=color:#ae81ff>16</span>(<span style=color:#a6e22e>FP</span>)    <span style=color:#75715e>// 将原伪寄存器SP偏移量存入返回值first
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>MOVQ</span>    <span style=color:#a6e22e>SP</span>, <span style=color:#a6e22e>BP</span>           <span style=color:#75715e>// 存储物理SP偏移量到BP寄存器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>ADDQ</span>    <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>4096</span>, <span style=color:#a6e22e>SP</span>        <span style=color:#75715e>// 将物理SP偏移增加4K
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>LEAQ</span> <span style=color:#a6e22e>x</span><span style=color:#f92672>-</span><span style=color:#ae81ff>0</span>(<span style=color:#a6e22e>SP</span>), <span style=color:#a6e22e>SI</span>         <span style=color:#75715e>// 在上面中只改变了一个值就是SP这个寄存器，然后再次一模一样的把x-0(SP)给到了SI.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* 第一个 MOVQ    BP, SP */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>MOVQ</span>    <span style=color:#a6e22e>BP</span>, <span style=color:#a6e22e>SP</span>           <span style=color:#75715e>// 恢复物理SP，因为修改物理SP后，伪寄存器FP/SP随之改变，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                 <span style=color:#75715e>// 为了正确访问FP，先恢复物理SP
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>MOVQ</span> <span style=color:#a6e22e>SI</span>, <span style=color:#a6e22e>second</span><span style=color:#f92672>+</span><span style=color:#ae81ff>24</span>(<span style=color:#a6e22e>FP</span>)   <span style=color:#75715e>// 将偏移后的伪寄存器SP偏移量存入返回值second
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* 第二个 MOVQ    BP, SP */</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//MOVQ    BP, SP         
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>RET</span>					    <span style=color:#75715e>// 从输出的second-first来看，正好相差4K
</span></span></span></code></pre></div><p>编译一下源代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># linux</span>
</span></span><span style=display:flex><span>go build -gcflags <span style=color:#e6db74>&#34;-N -l&#34;</span> -o test .
</span></span><span style=display:flex><span><span style=color:#75715e># or </span>
</span></span><span style=display:flex><span>go build -gcflags <span style=color:#e6db74>&#34;all=-N -l&#34;</span> -o test .
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># xos:</span>
</span></span><span style=display:flex><span>go build -gcflags <span style=color:#e6db74>&#34;all=-N -l&#34;</span> -ldflags<span style=color:#f92672>=</span>-compressdwarf<span style=color:#f92672>=</span>false   -o test .
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># result</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZf8z14idfp0rwhiicngwqZ FP_SP<span style=color:#f92672>]</span><span style=color:#75715e># tree .</span>
</span></span><span style=display:flex><span>.
</span></span><span style=display:flex><span>├── main.go
</span></span><span style=display:flex><span>├── test
</span></span><span style=display:flex><span>└── test_FP_SP.s
</span></span></code></pre></div><p>我们用到的gdb命令:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>
</span></span><span style=display:flex><span>gdb ./test
</span></span><span style=display:flex><span>list
</span></span><span style=display:flex><span>b <span style=color:#ae81ff>6</span>
</span></span><span style=display:flex><span>display /25i $pc-8
</span></span><span style=display:flex><span>si
</span></span><span style=display:flex><span>si
</span></span><span style=display:flex><span>si
</span></span></code></pre></div><p>si: To execute one line of code, type &ldquo;step&rdquo; or &ldquo;s&rdquo;. If the line to be executed is a function call, gdb will step into that function and start executing its code one line at a time</p><p>n: If you want to execute the entire function with one keypress, type &ldquo;next&rdquo; or &ldquo;n&rdquo;</p><p>define rr
info threads
info register rbp rsp pc
end</p><p>set pagination off</p><p>(gdb) help x
Examine memory: x/FMT ADDRESS.
ADDRESS is an expression for the memory address to examine.
FMT is a repeat count followed by a format letter and a size letter.
Format letters are o(octal), x(hex), d(decimal), u(unsigned decimal),
t(binary), f(float), a(address), i(instruction), c(char) and s(string),
T(OSType), A(floating point values in hex).
Size letters are b(byte), h(halfword), w(word), g(giant, 8 bytes).
The specified number of objects of the specified size are printed
according to the format.</p><p>x/10og 0xc000032738</p><p>x/40xg</p><p>打印变量的值
p first
p &first</p><p>help disass
<del>disass $pc-1,+100</del>
disass $pc,+40
<strong>disass会从你指定的位置解析，如果当前指定的值是在某个指令的中间，那么它的后面会错误的解析</strong>
So, for example, if you want to disassemble function bar in file foo.c
you must type &ldquo;disassemble &lsquo;foo.c&rsquo;::bar&rdquo; and not &ldquo;disassemble foo.c:bar&rdquo;.</p><pre tabindex=0><code>(gdb) display /2i $pc
3: x/2i $pc
=&gt; 0x44c16d &lt;main.main+29&gt;:	movq   $0x1,(%rsp)
   0x44c175 &lt;main.main+37&gt;:	movq   $0x2,0x8(%rsp)
(gdb) display /3i $pc
4: x/3i $pc
=&gt; 0x44c16d &lt;main.main+29&gt;:	movq   $0x1,(%rsp)
   0x44c175 &lt;main.main+37&gt;:	movq   $0x2,0x8(%rsp)
   0x44c17e &lt;main.main+46&gt;:	callq  0x44c250 &lt;main.test_FP_SP&gt;
(gdb) display /3i $pc-1
5: x/3i $pc-1
   0x44c16c &lt;main.main+28&gt;:	rex.W
=&gt; 0x44c16d &lt;main.main+29&gt;:	movq   $0x1,(%rsp)
   0x44c175 &lt;main.main+37&gt;:	movq   $0x2,0x8(%rsp)
(gdb) display /3i $pc-2
6: x/3i $pc-2
   0x44c16b &lt;main.main+27&gt;:	and    $0x48,%al
=&gt; 0x44c16d &lt;main.main+29&gt;:	movq   $0x1,(%rsp)
   0x44c175 &lt;main.main+37&gt;:	movq   $0x2,0x8(%rsp)
(gdb) display /3i $pc-3
7: x/3i $pc-3
   0x44c16a &lt;main.main+26&gt;:	insb   (%dx),%es:(%rdi)
   0x44c16b &lt;main.main+27&gt;:	and    $0x48,%al
=&gt; 0x44c16d &lt;main.main+29&gt;:	movq   $0x1,(%rsp)
</code></pre><p><a href=https://docs.google.com/document/d/1wAaf1rYoM4S4gtnPh0zOlGzWtrZFQ5suE8qr2sD8uWQ/pub>https://docs.google.com/document/d/1wAaf1rYoM4S4gtnPh0zOlGzWtrZFQ5suE8qr2sD8uWQ/pub</a></p><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210129195940.png alt=20210129195940></p><p>从上面的图中可以看出，go assemble中的<code>x-0(SP)</code>与<code>first+16(FP)</code>,其实都是与SP寄存器关联的，其中SP，伪FP，与伪SP的位置，在下图中已经标识出来了;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>+------------------------+                                  
</span></span><span style=display:flex><span>|                        |                                  
</span></span><span style=display:flex><span>|                        |                                  
</span></span><span style=display:flex><span>|         second         |                                  
</span></span><span style=display:flex><span>|                        |                                  
</span></span><span style=display:flex><span>|-------------------------                                  
</span></span><span style=display:flex><span>|                        |                                  
</span></span><span style=display:flex><span>|                        |                                  
</span></span><span style=display:flex><span>|         first          |                                  
</span></span><span style=display:flex><span>|                        |                                  
</span></span><span style=display:flex><span>|------------------------|                                  
</span></span><span style=display:flex><span>|                        |                                  
</span></span><span style=display:flex><span>|                        |                                  
</span></span><span style=display:flex><span>|         b              |                                  
</span></span><span style=display:flex><span>|                        |                                  
</span></span><span style=display:flex><span>|------------------------|                                  
</span></span><span style=display:flex><span>|                        |                                  
</span></span><span style=display:flex><span>|                        |                                  
</span></span><span style=display:flex><span>|         a              |                                  
</span></span><span style=display:flex><span>|                        |                                  
</span></span><span style=display:flex><span>+------------------------+ &lt;-------- 伪FP!!!                      
</span></span><span style=display:flex><span>|                        |                                  
</span></span><span style=display:flex><span>|                        |                                  
</span></span><span style=display:flex><span>|     caller<span style=color:#e6db74>&#39;s pc        |                                  
</span></span></span><span style=display:flex><span><span style=color:#e6db74>|                        |                                  
</span></span></span><span style=display:flex><span><span style=color:#e6db74>+------------------------+                                  
</span></span></span><span style=display:flex><span><span style=color:#e6db74>|                        |                                  
</span></span></span><span style=display:flex><span><span style=color:#e6db74>|                        |                                  
</span></span></span><span style=display:flex><span><span style=color:#e6db74>|     caller&#39;</span>s BP        |                                  
</span></span><span style=display:flex><span>|                        |                                  
</span></span><span style=display:flex><span>|------------------------| &lt;-------- callee<span style=color:#e6db74>&#39;s BP &lt;=== 伪SP!!!
</span></span></span><span style=display:flex><span><span style=color:#e6db74>|                        |                                  
</span></span></span><span style=display:flex><span><span style=color:#e6db74>|                        |                                  
</span></span></span><span style=display:flex><span><span style=color:#e6db74>|        ...             |                                  
</span></span></span><span style=display:flex><span><span style=color:#e6db74>|                        |                                  
</span></span></span><span style=display:flex><span><span style=color:#e6db74>|                        |                                  
</span></span></span><span style=display:flex><span><span style=color:#e6db74>+------------------------+ &lt;-------- 真实寄存器SP等于
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                     caller&#39;</span>s SP - caller<span style=color:#e6db74>&#39;s next CP(8) - callee&#39;</span>s stack size
</span></span><span style=display:flex><span>                     上图已标识
</span></span></code></pre></div><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210129211423.png alt="MOVQ	0(SP), AX // f&amp;rsquo;s PC"></p><h3 id=扩展>扩展
<a class=anchor href=#%e6%89%a9%e5%b1%95>#</a></h3><p>当我们把<code>/* 第一个 MOVQ BP, SP */</code>下面的注释掉，执行的话会panic，是因为PC寄存器读取错误，而不是注释掉的下一行导致的。</p><p>可以实验下:我们把<code>/* 第二个 MOVQ BP, SP */</code>取消注释，它就正常执行，只是返回值不对而已。</p><h2 id=添加汇编>添加汇编
<a class=anchor href=#%e6%b7%bb%e5%8a%a0%e6%b1%87%e7%bc%96>#</a></h2><p>go编译器加的函数头的部分</p><pre tabindex=0><code>=&gt; 0x459240 &lt;main.test_FP_SP&gt;:	mov    %fs:0xfffffffffffffff8,%rcx
   0x459249 &lt;main.test_FP_SP+9&gt;:	mov    0x10(%rcx),%rsi
   0x45924d &lt;main.test_FP_SP+13&gt;:	cmp    $0xfffffffffffffade,%rsi
   0x459254 &lt;main.test_FP_SP+20&gt;:	je     0x4592bd &lt;main.test_FP_SP+125&gt;
   0x459256 &lt;main.test_FP_SP+22&gt;:	lea    0x370(%rsp),%rax
   0x45925e &lt;main.test_FP_SP+30&gt;:	sub    %rsi,%rax
   0x459261 &lt;main.test_FP_SP+33&gt;:	cmp    $0x1308,%rax
   0x459267 &lt;main.test_FP_SP+39&gt;:	jbe    0x4592bd &lt;main.test_FP_SP+125&gt;
   0x459269 &lt;main.test_FP_SP+41&gt;:	sub    $0x1018,%rsp
   0x459270 &lt;main.test_FP_SP+48&gt;:	mov    %rbp,0x1010(%rsp)
   0x459278 &lt;main.test_FP_SP+56&gt;:	lea    0x1010(%rsp),%rbp
   0x459280 &lt;main.test_FP_SP+64&gt;:	lea    0x1010(%rsp),%rdi
   0x459288 &lt;main.test_FP_SP+72&gt;:	mov    %rdi,0x1030(%rsp)
   0x459290 &lt;main.test_FP_SP+80&gt;:	mov    %rsp,%rbp
   0x459293 &lt;main.test_FP_SP+83&gt;:	add    $0x1000,%rsp
   0x45929a &lt;main.test_FP_SP+90&gt;:	lea    0x1010(%rsp),%rsi
   0x4592a2 &lt;main.test_FP_SP+98&gt;:	mov    %rbp,%rsp
   0x4592a5 &lt;main.test_FP_SP+101&gt;:	mov    %rsi,0x1038(%rsp)
   0x4592ad &lt;main.test_FP_SP+109&gt;:	mov    0x1010(%rsp),%rbp
   0x4592b5 &lt;main.test_FP_SP+117&gt;:	add    $0x1018,%rsp
   0x4592bc &lt;main.test_FP_SP+124&gt;:	retq
   0x4592bd &lt;main.test_FP_SP+125&gt;:	callq  0x450c70 &lt;runtime.morestack_noctxt&gt;
   0x4592c2 &lt;main.test_FP_SP+130&gt;:	jmpq   0x459240 &lt;main.test_FP_SP&gt;
   0x4592c7:	add    %al,(%rax)
   0x4592c9:	add    %al,(%rax)
</code></pre><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210201140600.png alt=以上面的例子来看></p><ul><li>在头和尾部加上了其他跳转代码。<ul><li><code>0x10(%rcx)</code></li><li><code>$0xfffffffffffffade</code></li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>stack</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>lo</span> <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>hi</span> <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>g</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Stack parameters.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// stack describes the actual stack memory: [stack.lo, stack.hi).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// stackguard0 is the stack pointer compared in the Go stack growth prologue.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// stackguard1 is the stack pointer compared in the C stack growth prologue.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// It is stack.lo+StackGuard on g0 and gsignal stacks.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>stack</span>       <span style=color:#a6e22e>stack</span>   <span style=color:#75715e>// offset known to runtime/cgo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>stackguard0</span> <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// offset known to liblink
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>stackguard1</span> <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// offset known to liblink
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//...
</span></span></span></code></pre></div><p>其中rcx是g的地址，所以<code>0x10(%rcx)</code>是就是跳过stack得到stackguard0(它是go栈增长的序章，开始的地方,值是：stack.lo+StackGuard)
<a href=https://github.com/golang/go/blob/0e85fd7561de869add933801c531bf25dee9561c/src/cmd/internal/objabi/stack.go#L21>var StackGuard = 928*stackGuardMultiplier() + StackSystem</a></p><p>当被抢占的时候，它是:
<a href=https://github.com/golang/go/blob/0e85fd7561de869add933801c531bf25dee9561c/src/cmd/internal/objabi/stack.go#L17>StackPreempt = -1314 // 0xfff&mldr;fade</a></p><table><thead><tr><th>order</th><th>explainment</th></tr></thead><tbody><tr><td>je</td><td>Jumps if equal</td></tr><tr><td>jbe</td><td>Jumps if below or equal</td></tr></tbody></table><h2 id=例子-1>例子
<a class=anchor href=#%e4%be%8b%e5%ad%90-1>#</a></h2><h3 id=main-goroutine得不到执行>main goroutine得不到执行
<a class=anchor href=#main-goroutine%e5%be%97%e4%b8%8d%e5%88%b0%e6%89%a7%e8%a1%8c>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;runtime&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>g2</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sum</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>sum</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>GOMAXPROCS</span>(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>g2</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>Gosched</span>()
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;main is scheduled!&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>将不会打印[&ldquo;main is scheduled!&rdquo;]</li></ul><h3 id=一些汇编需要的常见的指令>一些汇编需要的常见的指令
<a class=anchor href=#%e4%b8%80%e4%ba%9b%e6%b1%87%e7%bc%96%e9%9c%80%e8%a6%81%e7%9a%84%e5%b8%b8%e8%a7%81%e7%9a%84%e6%8c%87%e4%bb%a4>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>go build  -gcflags <span style=color:#e6db74>&#34;-N -l&#34;</span> -o test .
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>info files 
</span></span><span style=display:flex><span>info registers sp bp
</span></span><span style=display:flex><span>info breakpoint
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>x/10x
</span></span><span style=display:flex><span>help x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>x/16xb 0x7fffffffe470
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>https://visualgdb.com/gdbreference/commands/x<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>info register rbp rsp pc
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>display /20i $pc
</span></span></code></pre></div><p><a href=https://blog.csdn.net/counsellor/article/details/100034080>https://blog.csdn.net/counsellor/article/details/100034080</a></p><h2 id=附录>附录
<a class=anchor href=#%e9%99%84%e5%bd%95>#</a></h2><p><a href=https://lrita.github.io/2017/12/12/golang-asm/#interface>https://lrita.github.io/2017/12/12/golang-asm/#interface</a></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><script src=https://giscus.app/client.js data-repo=zput/utterances-comments data-repo-id=R_kgDOHhATGQ data-category=Announcements data-category-id=DIC_kwDOHhATGc4CPxca data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=1 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#伪寄存器--函数栈>伪寄存器 & 函数栈</a><ul><li><a href=#伪寄存器>伪寄存器</a><ul><li><a href=#fp>FP</a></li><li><a href=#sp>SP</a></li><li><a href=#总结>总结</a></li></ul></li><li><a href=#函数调用>函数调用</a><ul><li><a href=#例子>例子</a></li></ul></li><li><a href=#gdb过程>gdb过程</a><ul><li><a href=#扩展>扩展</a></li></ul></li><li><a href=#添加汇编>添加汇编</a></li><li><a href=#例子-1>例子</a><ul><li><a href=#main-goroutine得不到执行>main goroutine得不到执行</a></li><li><a href=#一些汇编需要的常见的指令>一些汇编需要的常见的指令</a></li></ul></li><li><a href=#附录>附录</a></li></ul></li></ul></nav></div></aside></main></body></html>