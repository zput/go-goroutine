<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>调度 on go调度源码分析</title><link>https://zput.github.io/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/</link><description>Recent content in 调度 on go调度源码分析</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Tue, 23 Jun 2020 20:50:00 +0000</lastBuildDate><atom:link href="https://zput.github.io/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/index.xml" rel="self" type="application/rss+xml"/><item><title>初始化</title><link>https://zput.github.io/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/2_init_before_enter_main_function/</link><pubDate>Mon, 20 Jan 2020 10:03:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/2_init_before_enter_main_function/</guid><description>进入main函数前的初始化 # 例子 # 我们首先来gdb调试一下这个程序
main.go
package main import &amp;#34;fmt&amp;#34; // the function&amp;#39;s body is empty func add(x, y int64) int64 func main() { gg:=add(2, 3) fmt.Println(gg) } add_amd.s
TEXT ·add(SB),$0-24 MOVQ x+0(FP), BX MOVQ y+8(FP), BP ADDQ BP, BX MOVQ BX, ret+16(FP) RET 编译一下源代码: go build -gcflags &amp;quot;-N -l&amp;quot; -o test ..
程序加载到内存入口 # (gdb) info files Symbols from &amp;#34;/tmp/kubernets/test&amp;#34;. Local exec file: `/tmp/kubernets/test&amp;#39;, file type elf64-x86-64. Entry point: 0x454e00 0x0000000000401000 - 0x000000000048cfd3 is .</description></item><item><title>goroutine退出</title><link>https://zput.github.io/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/3_exit_goroutine/</link><pubDate>Mon, 10 Feb 2020 10:09:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/%E8%BF%90%E8%A1%8C%E6%97%B6/%E8%B0%83%E5%BA%A6/3_exit_goroutine/</guid><description>goroutine退出过程 # 退出 # 非main goroutine 最后会运行goexit() main goroutine 虽然也定义了goexit(),模拟好像是是goexit函数调用的,但是这个main goroutine在src/runtime/proc.go文件里,这个函数返回到上一层. exit(0),就会退出. 如果上面没有退出,下面的for循环会再次保证程序将不会到上一层再继续执行. // The main goroutine. func main() { //... exit(0) for { var x *int32 *x = 0 } } 例子 # 我们首先来gdb调试一下这个程序
main.go
package main import &amp;#34;time&amp;#34; // the function&amp;#39;s body is empty func add(x, y int64) int64 func main() { go add(2, 3) time.Sleep(time.Minute) } add_amd.s
TEXT ·add(SB),$0-24 MOVQ x+0(FP), BX MOVQ y+8(FP), BP ADDQ BP, BX MOVQ BX, ret+16(FP) RET 编译一下源代码: go build -gcflags &amp;quot;-N -l&amp;quot; -o test .</description></item></channel></rss>