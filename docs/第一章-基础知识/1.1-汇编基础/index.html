<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="go汇编 # gdb golang assamble non-split; sp bp 会更新吗?
main function enter BP is useful ? schedule
dropg()函数 # dropg() //解除g和m之间的关系; func dropg() { _g_ := getg() setMNoWB(&_g_.m.curg.m, nil) setGNoWB(&_g_.m.curg, nil) } park_m函数 # 通过mcall从gN转到g0; stack转移了, jmp跳转到park_m(*g)函数, # gN&ndash;>m &mdash;> gN mcall怎么保证g0的m指向了m的?
// park continuation on g0. func park_m(gp *g) { _g_ := getg() if trace.enabled { traceGoPark(_g_.m.waittraceev, _g_.m.waittraceskip) } casgstatus(gp, _Grunning, _Gwaiting) dropg() //解除g和m之间的关系 ...... schedule() } get_tls函数 # TEXT runtime·rt0_go(SB),NOSPLIT,$0 //."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="1.1 底层类汇编函数"><meta property="og:description" content="go汇编 # gdb golang assamble non-split; sp bp 会更新吗?
main function enter BP is useful ? schedule
dropg()函数 # dropg() //解除g和m之间的关系; func dropg() { _g_ := getg() setMNoWB(&_g_.m.curg.m, nil) setGNoWB(&_g_.m.curg, nil) } park_m函数 # 通过mcall从gN转到g0; stack转移了, jmp跳转到park_m(*g)函数, # gN&ndash;>m &mdash;> gN mcall怎么保证g0的m指向了m的?
// park continuation on g0. func park_m(gp *g) { _g_ := getg() if trace.enabled { traceGoPark(_g_.m.waittraceev, _g_.m.waittraceskip) } casgstatus(gp, _Grunning, _Gwaiting) dropg() //解除g和m之间的关系 ...... schedule() } get_tls函数 # TEXT runtime·rt0_go(SB),NOSPLIT,$0 //."><meta property="og:type" content="article"><meta property="og:url" content="https://example.com/docs/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.1-%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/"><meta property="article:section" content="docs"><meta property="article:published_time" content="2019-02-28T15:03:00+00:00"><meta property="article:modified_time" content="2019-02-28T15:03:00+00:00"><title>1.1 底层类汇编函数 | go调度源码分析</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css integrity="sha256-gsXb0jRHzuC0wqo+0Izglh+qQOH6Nw7uT4yfAuDUa18=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.3d89b421e6b838a0994a918daaecd083aefa9523faabd023944479b99694353b.js integrity="sha256-PYm0Iea4OKCZSpGNquzQg676lSP6q9AjlER5uZaUNTs=" crossorigin=anonymous></script>
<script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>go调度源码分析</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><span>第一章 基础知识</span><ul><li><a href=/docs/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.1-%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/ class=active>1.1 底层类汇编函数</a></li><li><a href=/docs/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.2-%E5%86%85%E5%AD%98/>1.2 内存大小端概念</a></li></ul></li><li><span>第二章 进入main函数之前的初始化</span><ul><li><a href=/docs/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E5%85%A5main%E5%87%BD%E6%95%B0%E4%B9%8B%E5%89%8D%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/2.1-%E8%BF%9B%E5%85%A5main%E5%87%BD%E6%95%B0%E4%B9%8B%E5%89%8D%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/>2.1 进入main函数之前的初始化</a></li></ul></li><li><span>第三章 退出goroutine</span><ul><li><a href=/docs/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E9%80%80%E5%87%BAgoroutine/3.1-%E9%80%80%E5%87%BAgoroutine/>3.1 goroutine退出过程</a></li></ul></li><li><span>第四章 调度</span><ul><li><span>一 调度策略</span><ul><li><a href=/docs/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%B0%83%E5%BA%A6/%E4%B8%80-%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/4.1.2-%E7%9B%97%E5%8F%96goroutine%E4%BB%8E%E5%85%B6%E4%BB%96%E9%98%9F%E5%88%97/>4.1.2 盗取goroutine从其他队列</a></li><li><a href=/docs/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%B0%83%E5%BA%A6/%E4%B8%80-%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/4.1.1-%E4%BB%8E%E6%9C%AC%E5%9C%B0%E9%98%9F%E5%88%97%E6%88%96%E5%85%A8%E5%B1%80%E9%98%9F%E5%88%97%E8%8E%B7%E5%8F%96goroutine/>4.1.1 从本地队列或全局队列获取goroutine</a></li></ul></li><li><a href=/docs/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%B0%83%E5%BA%A6/%E4%BA%8C-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA/>二 调度的时机</a><ul><li><a href=/docs/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%B0%83%E5%BA%A6/%E4%BA%8C-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA/4.2.1-%E4%B8%BB%E5%8A%A8%E8%B0%83%E5%BA%A6/>4.2.1 goroutine主动调度</a></li><li><a href=/docs/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%B0%83%E5%BA%A6/%E4%BA%8C-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA/4.2.2-%E8%A2%AB%E5%8A%A8%E8%B0%83%E5%BA%A6/>4.2.2 goroutine被动调度</a></li><li><span>4.2.3 剥夺调度</span><ul><li><a href=/docs/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%B0%83%E5%BA%A6/%E4%BA%8C-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA/4.2.3-%E5%89%A5%E5%A4%BA%E8%B0%83%E5%BA%A6/4.2.3.1-%E8%BF%90%E8%A1%8C%E7%94%A8%E6%88%B7%E4%BB%A3%E7%A0%81%E6%97%B6%E9%97%B4%E8%BF%87%E9%95%BF%E8%B0%83%E5%BA%A6/>4.2.3.1 运行用户代码时间过长调度</a></li><li><a href=/docs/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%B0%83%E5%BA%A6/%E4%BA%8C-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA/4.2.3-%E5%89%A5%E5%A4%BA%E8%B0%83%E5%BA%A6/4.2.3.2-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%94%B6%E5%B0%BE%E5%A6%82%E6%9E%9C%E4%BB%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%BF%94%E5%9B%9E%E5%A6%82%E4%BD%95%E9%87%8D%E6%96%B0%E5%BE%97%E5%88%B0P/>4.2.3.2 系统调用收尾,如从系统调用返回,如何重新得到P</a></li></ul></li></ul></li><li><span>三 调度循环</span><ul><li><a href=/docs/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%B0%83%E5%BA%A6/%E4%B8%89-%E8%B0%83%E5%BA%A6%E5%BE%AA%E7%8E%AF/4.3.1-%E8%B0%83%E5%BA%A6%E5%BE%AA%E7%8E%AF/>4.3.1 调度循环</a></li></ul></li></ul></li></ul><ul><li><a href=https://github.com/zput target=_blank rel=noopener>Github</a></li><li><a href=https://zput.github.io target=_blank rel=noopener>blog</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>1.1 底层类汇编函数</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#go汇编>go汇编</a><ul><li><a href=#dropg函数>dropg()函数</a></li><li><a href=#park_m函数>park_m函数</a></li></ul></li><li><a href=#通过mcall从gn转到g0-stack转移了-jmp跳转到park_mg函数>通过mcall从gN转到g0; stack转移了, jmp跳转到park_m(*g)函数,</a></li><li><a href=#get_tls函数>get_tls函数</a><ul><li></li><li><a href=#参考>参考</a></li></ul></li><li><a href=#m_morebufgobuf_pcregister>(m_morebuf+gobuf_pc)(REGISTER)</a></li><li><a href=#伪寄存器>伪寄存器</a><ul><li></li><li><a href=#扩展>扩展</a></li></ul></li><li><a href=#go编译器加的函数头的部分>go编译器加的函数头的部分</a></li><li><a href=#例子>例子</a><ul><li><a href=#main-goroutine得不到执行>main goroutine得不到执行</a></li><li><a href=#一些汇编需要的常见的指令>一些汇编需要的常见的指令</a></li></ul></li><li><a href=#附录>附录</a></li></ul></li></ul></nav></aside></header><article class=markdown><h2 id=go汇编>go汇编
<a class=anchor href=#go%e6%b1%87%e7%bc%96>#</a></h2><p>gdb golang assamble
non-split; sp bp 会更新吗?</p><p>main function enter BP is useful ? schedule</p><h3 id=dropg函数>dropg()函数
<a class=anchor href=#dropg%e5%87%bd%e6%95%b0>#</a></h3><ul><li>dropg() //解除g和m之间的关系;</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>dropg</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_g_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>setMNoWB</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>curg</span>.<span style=color:#a6e22e>m</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>setGNoWB</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>curg</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=park_m函数>park_m函数
<a class=anchor href=#park_m%e5%87%bd%e6%95%b0>#</a></h3><h2 id=通过mcall从gn转到g0-stack转移了-jmp跳转到park_mg函数>通过mcall从gN转到g0; stack转移了, jmp跳转到park_m(*g)函数,
<a class=anchor href=#%e9%80%9a%e8%bf%87mcall%e4%bb%8egn%e8%bd%ac%e5%88%b0g0-stack%e8%bd%ac%e7%a7%bb%e4%ba%86-jmp%e8%b7%b3%e8%bd%ac%e5%88%b0park_mg%e5%87%bd%e6%95%b0>#</a></h2><p>gN&ndash;>m &mdash;> gN
mcall怎么保证g0的m指向了m的?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// park continuation on g0.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>park_m</span>(<span style=color:#a6e22e>gp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>_g_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>trace</span>.<span style=color:#a6e22e>enabled</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>traceGoPark</span>(<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>waittraceev</span>, <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>waittraceskip</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>casgstatus</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>_Grunning</span>, <span style=color:#a6e22e>_Gwaiting</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dropg</span>()  <span style=color:#75715e>//解除g和m之间的关系
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>......</span>
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>schedule</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=get_tls函数>get_tls函数
<a class=anchor href=#get_tls%e5%87%bd%e6%95%b0>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>TEXT</span> <span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>rt0_go</span>(<span style=color:#a6e22e>SB</span>),<span style=color:#a6e22e>NOSPLIT</span>,<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>LEAQ</span>	<span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>m0</span><span style=color:#f92672>+</span><span style=color:#a6e22e>m_tls</span>(<span style=color:#a6e22e>SB</span>), <span style=color:#a6e22e>DI</span>  <span style=color:#75715e>// //DI = &amp;m0.tls，取m0的tls成员的地址到DI寄存器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>CALL</span>	<span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>settls</span>(<span style=color:#a6e22e>SB</span>)        <span style=color:#75715e>// 调用settls设置线程本地存储，settls函数的参数在DI寄存器中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// store through it, to make sure it works // 可以看做是测试;测试刚刚那个绑定是否成功。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>get_tls</span>(<span style=color:#a6e22e>BX</span>)    <span style=color:#75715e>// 把TLS地址放入BX寄存器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0x123</span>, <span style=color:#a6e22e>g</span>(<span style=color:#a6e22e>BX</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>m0</span><span style=color:#f92672>+</span><span style=color:#a6e22e>m_tls</span>(<span style=color:#a6e22e>SB</span>), <span style=color:#a6e22e>AX</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>CMPQ</span>	<span style=color:#a6e22e>AX</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0x123</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>JEQ</span> <span style=color:#ae81ff>2</span>(<span style=color:#a6e22e>PC</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>CALL</span>	<span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>abort</span>(<span style=color:#a6e22e>SB</span>)
</span></span></code></pre></div><h4 id=settls>settls
<a class=anchor href=#settls>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// set tls base to DI
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>TEXT</span> <span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>settls</span>(<span style=color:#a6e22e>SB</span>),<span style=color:#a6e22e>NOSPLIT</span>,<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ADDQ</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>8</span>, <span style=color:#a6e22e>DI</span>	<span style=color:#75715e>// ELF wants to use -8(FS) //因为后面要-8,所以先加+8
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>DI</span>, <span style=color:#a6e22e>SI</span>  <span style=color:#75715e>// is SI parameter?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0x1002</span>, <span style=color:#a6e22e>DI</span>	<span style=color:#75715e>// ARCH_SET_FS
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#a6e22e>SYS_arch_prctl</span>, <span style=color:#a6e22e>AX</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>SYSCALL</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>CMPQ</span>	<span style=color:#a6e22e>AX</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0xfffffffffffff001</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>JLS</span>	<span style=color:#ae81ff>2</span>(<span style=color:#a6e22e>PC</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVL</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0xf1</span>, <span style=color:#ae81ff>0xf1</span>  <span style=color:#75715e>// crash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>RET</span>
</span></span></code></pre></div><p><a href=https://www.man7.org/linux/man-pages/man2/arch_prctl.2.html>arch_prctl</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>arch_prctl</span>(<span style=color:#66d9ef>int</span> code, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> addr);
</span></span><span style=display:flex><span><span style=color:#75715e>// arch_prctl() sets architecture-specific process or thread state. code selects a subfunction and passes argument addr to it;
</span></span></span></code></pre></div><p>其中：<code>ARCH_SET_FS</code>: Set the 64-bit base for the FS register to addr.</p><blockquote><p>现在知道就是把m0.tls[0]传给FS寄存器</p></blockquote><h4 id=get_tlsbx与gbx>get_tls(BX)与g(BX)
<a class=anchor href=#get_tlsbx%e4%b8%8egbx>#</a></h4><p>这个<code>get_tls(BX)</code>与<code>g()</code>其实都是宏定义：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>ifdef</span> <span style=color:#a6e22e>GOARCH_amd64</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>define</span>	<span style=color:#a6e22e>get_tls</span>(<span style=color:#a6e22e>r</span>)	<span style=color:#a6e22e>MOVQ</span> <span style=color:#a6e22e>TLS</span>, <span style=color:#a6e22e>r</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>define</span>	<span style=color:#a6e22e>g</span>(<span style=color:#a6e22e>r</span>)	<span style=color:#ae81ff>0</span>(<span style=color:#a6e22e>r</span>)(<span style=color:#a6e22e>TLS</span><span style=color:#f92672>*</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>endif</span>
</span></span></code></pre></div><p>可以得到</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span> <span style=color:#a6e22e>TLS</span>, <span style=color:#a6e22e>BX</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0</span>(<span style=color:#a6e22e>BX</span>)(<span style=color:#a6e22e>TLS</span><span style=color:#f92672>*</span><span style=color:#ae81ff>1</span>)
</span></span></code></pre></div><p>有两个疑问，
第一个是TLS是代表什么?
第二个是0(BX)(TLS*1)是能转换为什么地址？</p><pre tabindex=0><code>	// Thread-local storage references use the TLS pseudo-register.
	// As a register, TLS refers to the thread-local storage base, and it
	// can only be loaded into another register:
	//
	//         MOVQ TLS, AX
	//
	// An offset from the thread-local storage base is written off(reg)(TLS*1).
	// Semantically it is off(reg), but the (TLS*1) annotation marks this as
	// indexing from the loaded TLS base. This emits a relocation so that
	// if the linker needs to adjust the offset, it can. For example:
	//
	//         MOVQ TLS, AX
	//         MOVQ 0(AX)(TLS*1), CX // load g into CX
	//
	// On systems that support direct access to the TLS memory, this
	// pair of instructions can be reduced to a direct TLS memory reference:
	//
	//         MOVQ 0(TLS), CX // load g into CX
	//
	// The 2-instruction and 1-instruction forms correspond to the two code
	// sequences for loading a TLS variable in the local exec model given in &#34;ELF
	// Handling For Thread-Local Storage&#34;.
</code></pre><blockquote><p>这里总结就是:</p><blockquote><p>TLS代表的是伪寄存器，是线程本地存储的基地址。
语义上<code>off(reg)(TLS*1)== off(reg)</code>. 而这个<code>(TLS*1)</code>说明是从线程本地存储的基地址上进行索引。</p></blockquote></blockquote><h3 id=参考>参考
<a class=anchor href=#%e5%8f%82%e8%80%83>#</a></h3><p><a href=https://www.zhihu.com/question/284288720>https://www.zhihu.com/question/284288720</a>
<a href=https://segmentfault.com/a/1190000038626134>https://segmentfault.com/a/1190000038626134</a>
<a href=https://www.altoros.com/blog/golang-internals-part-5-the-runtime-bootstrap-process/>https://www.altoros.com/blog/golang-internals-part-5-the-runtime-bootstrap-process/</a></p><p><a href=https://segmentfault.com/a/1190000010984538>gid</a></p><ul><li>Addressing modes:<ul><li>(DI)(BX<em>2): The location at address DI plus BX</em>2.</li><li>64(DI)(BX<em>2): The location at address DI plus BX</em>2 plus 64. These modes accept only 1, 2, 4, and 8 as scale factors.</li></ul></li></ul><p><a href=https://golang.org/doc/asm#directives>https://golang.org/doc/asm#directives</a></p><p><a href=https://lrita.github.io/2017/12/12/golang-asm/#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E>https://lrita.github.io/2017/12/12/golang-asm/#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E</a></p><p><a href=https://github.com/go-internals-cn/go-internals>https://github.com/go-internals-cn/go-internals</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// When building for inclusion into a shared library, an instruction of the form
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//     MOV off(CX)(TLS*1), AX
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// becomes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//     mov %fs:off(%rcx), %rax
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// which assumes that the correct TLS offset has been loaded into %rcx (today
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// there is only one TLS variable -- g -- so this is OK). When not building for
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// a shared library the instruction does not require a prefix.
</span></span></span></code></pre></div><h2 id=m_morebufgobuf_pcregister>(m_morebuf+gobuf_pc)(REGISTER)
<a class=anchor href=#m_morebufgobuf_pcregister>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#ae81ff>8</span>(<span style=color:#a6e22e>SP</span>), <span style=color:#a6e22e>AX</span>	<span style=color:#75715e>// f&#39;s caller&#39;s PC
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>AX</span>, (<span style=color:#a6e22e>m_morebuf</span><span style=color:#f92672>+</span><span style=color:#a6e22e>gobuf_pc</span>)(<span style=color:#a6e22e>BX</span>)
</span></span></code></pre></div><p><a href=https://github.com/zput/go/blob/5622128a77b4af5e5dc02edf53ecac545e3af730/src/runtime/runtime2.go#L452>runtime.m</a>
<a href=https://github.com/zput/go/blob/5622128a77b4af5e5dc02edf53ecac545e3af730/src/runtime/runtime2.go#L302>runtime.gobuf</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>m</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>g0</span>      <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>     <span style=color:#75715e>// goroutine with scheduling stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>morebuf</span> <span style=color:#a6e22e>gobuf</span>  <span style=color:#75715e>// gobuf arg to morestack   //-----------morebuf-------------//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>divmod</span>  <span style=color:#66d9ef>uint32</span> <span style=color:#75715e>// div/mod denominator for arm - known to liblink
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>gobuf</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// The offsets of sp, pc, and g are known to (hard-coded in) libmach.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// ctxt is unusual with respect to GC: it may be a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// heap-allocated funcval, so GC needs to track it, but it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// needs to be set and cleared from assembly, where it&#39;s
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// difficult to have write barriers. However, ctxt is really a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// saved, live register, and we only ever exchange it between
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// the real register and the gobuf. Hence, we treat it as a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// root during stack scanning, which means assembly that saves
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// and restores it doesn&#39;t need write barriers. It&#39;s still
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// typed as a pointer so that any other writes from Go get
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// write barriers.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>sp</span>   <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pc</span>   <span style=color:#66d9ef>uintptr</span>   <span style=color:#75715e>// &lt;&lt;&lt;--- 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>g</span>    <span style=color:#a6e22e>guintptr</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ctxt</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ret</span>  <span style=color:#a6e22e>sys</span>.<span style=color:#a6e22e>Uintreg</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>lr</span>   <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bp</span>   <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// for GOEXPERIMENT=framepointer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>我们从这个<code>m_morebuf+gobuf_pc</code>就知道指的是这个m结构体中的morebuf结构体字段中的pc值。</p><p><a href=https://github.com/zput/go/blob/5622128a77b4af5e5dc02edf53ecac545e3af730/src/runtime/runtime2.go#L387>runtime.g</a></p><h2 id=伪寄存器>伪寄存器
<a class=anchor href=#%e4%bc%aa%e5%af%84%e5%ad%98%e5%99%a8>#</a></h2><p><a href=https://golang.org/doc/asm#symbols>A Quick Guide to Go&rsquo;s Assembler</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>FP</span>: <span style=color:#a6e22e>Frame</span> <span style=color:#a6e22e>pointer</span>: <span style=color:#a6e22e>arguments</span> <span style=color:#a6e22e>and</span> <span style=color:#a6e22e>locals</span>.
</span></span><span style=display:flex><span><span style=color:#a6e22e>PC</span>: <span style=color:#a6e22e>Program</span> <span style=color:#a6e22e>counter</span>: <span style=color:#a6e22e>jumps</span> <span style=color:#a6e22e>and</span> <span style=color:#a6e22e>branches</span>.
</span></span><span style=display:flex><span><span style=color:#a6e22e>SB</span>: <span style=color:#a6e22e>Static</span> <span style=color:#a6e22e>base</span> <span style=color:#a6e22e>pointer</span>: <span style=color:#a6e22e>global</span> <span style=color:#a6e22e>symbols</span>.
</span></span><span style=display:flex><span><span style=color:#a6e22e>SP</span>: <span style=color:#a6e22e>Stack</span> <span style=color:#a6e22e>pointer</span>: <span style=color:#a6e22e>top</span> <span style=color:#a6e22e>of</span> <span style=color:#a6e22e>stack</span>.
</span></span></code></pre></div><h4 id=fp>FP
<a class=anchor href=#fp>#</a></h4><blockquote><p>FP伪寄存器是一个用于引用函数参数的虚拟帧指针。编译器维护一个虚拟帧指针，并将堆栈上的参数引用为该伪寄存器的偏移量。因此0(FP)是函数的第一个参数，8(FP)是第二个参数(在64位机器上)，以此类推。但是，当以这种方式引用一个函数参数时，有必要将名称放在开头，如first_arg+0(FP)和second_arg+8(FP)。(偏移量的含义&ndash;从帧指针出发的偏移量&ndash;与它在SB中的使用不同，在SB中，它是从符号出发的偏移量。) 汇编器强制执行这个约定，拒绝普通的0(FP)和8(FP)。实际的名称在语义上是不相关的，但应该用来记录参数的名称。值得强调的是，FP始终是一个伪寄存器，而不是硬件寄存器，即使在具有硬件帧指针的架构上也是如此。</p></blockquote><blockquote><p>The FP pseudo-register is a virtual frame pointer used to refer to function arguments. The compilers maintain a virtual frame pointer and refer to the arguments on the stack as offsets from that pseudo-register. Thus 0(FP) is the first argument to the function, 8(FP) is the second (on a 64-bit machine), and so on. However, when referring to a function argument this way, it is necessary to place a name at the beginning, as in first_arg+0(FP) and second_arg+8(FP). (The meaning of the offset—offset from the frame pointer—distinct from its use with SB, where it is an offset from the symbol.) The assembler enforces this convention, rejecting plain 0(FP) and 8(FP). The actual name is semantically irrelevant but should be used to document the argument&rsquo;s name. It is worth stressing that FP is always a pseudo-register, not a hardware register, even on architectures with a hardware frame pointer.</p></blockquote><blockquote><p>对于带有Go原型的汇编函数，go vet会检查参数名和偏移量是否匹配。在32位系统上，64位值的低位和高位32位是通过在名称中添加一个_lo或_hi后缀来区分的，如arg_lo+0(FP)或arg_hi+4(FP)。如果一个Go原型没有给它的结果命名，那么预期的汇编名是ret。</p></blockquote><blockquote><p>For assembly functions with Go prototypes, go vet will check that the argument names and offsets match. On 32-bit systems, the low and high 32 bits of a 64-bit value are distinguished by adding a _lo or _hi suffix to the name, as in arg_lo+0(FP) or arg_hi+4(FP). If a Go prototype does not name its result, the expected assembly name is ret.</p></blockquote><h4 id=sp>SP
<a class=anchor href=#sp>#</a></h4><blockquote><p>SP伪寄存器是一个虚拟栈指针，用于引用帧本地变量和为函数调用准备的参数。它指向本地栈帧的顶部，所以引用时应使用负偏移量，范围为[-framesize，0)：x-8(SP)，y-4(SP)，以此类推。</p></blockquote><blockquote><p>The SP pseudo-register is a virtual stack pointer used to refer to frame-local variables and the arguments being prepared for function calls. It points to the top of the local stack frame, so references should use negative offsets in the range [−framesize, 0): x-8(SP), y-4(SP), and so on.</p></blockquote><blockquote><p>在具有名为SP的硬件寄存器的架构上，名称前缀可以区分对虚拟栈指针的引用和对架构SP寄存器的引用，即x-8(SP)，y-4(SP)，以此类推。也就是说，x-8(SP)和-8(SP)是不同的内存位置：第一个是指虚拟栈指针伪寄存器，而第二个是指硬件的SP寄存器。</p></blockquote><blockquote><p>On architectures with a hardware register named SP, the name prefix distinguishes references to the virtual stack pointer from references to the architectural SP register. That is, x-8(SP) and -8(SP) are different memory locations: the first refers to the virtual stack pointer pseudo-register, while the second refers to the hardware&rsquo;s SP register.</p></blockquote><ul><li><p>总结下：</p><ul><li>如何理解伪寄存器FP和SP呢？其实伪寄存器FP和SP相当于plan9伪汇编中的一个助记符，他们是根据当前函数栈空间计算出来的一个相对于物理寄存器SP的一个偏移量坐标。</li><li>伪SP和FP的相对位置是会变的，所以不应该尝试用伪SP寄存器去找那些用FP+offset来引用的值，例如函数的入参和返回值。</li><li>官方文档中说的伪SP指向stack的top，是有问题的。其指向的局部变量位置实际上是整个栈的栈底（除caller BP 之外），所以说bottom更合适一些。</li><li><code>MOVQ 0(SP), AX // f's PC</code>,这种前面没有flags的，它相当于实际的寄存器的值，不是伪寄存器了。</li></ul></li><li><p>下面来做下实验。</p><ul><li>确认FP， SP相对于real register的位置点在那里。</li><li>我们 presudo FP应该在caller&rsquo;s next pc + 8byte</li><li>presudo SP应该在caller&rsquo;s BP</li></ul></li></ul><blockquote><p>main.go</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>test_FP_SP</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int64</span>)(<span style=color:#a6e22e>first</span> <span style=color:#66d9ef>uintptr</span>, <span style=color:#a6e22e>second</span> <span style=color:#66d9ef>uintptr</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>first</span>, <span style=color:#a6e22e>second</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>test_FP_SP</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>first</span> <span style=color:#f92672>-=</span> <span style=color:#a6e22e>second</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>first</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>test_FP_SP.s</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// func test_FP_SP(a, b int64)(first uintptr, second uintptr)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>TEXT</span> <span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>test_FP_SP</span>(<span style=color:#a6e22e>SB</span>),<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>4112</span><span style=color:#f92672>-</span><span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>LEAQ</span> <span style=color:#a6e22e>x</span><span style=color:#f92672>-</span><span style=color:#ae81ff>0</span>(<span style=color:#a6e22e>SP</span>), <span style=color:#a6e22e>DI</span>         <span style=color:#75715e>// 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>MOVQ</span> <span style=color:#a6e22e>DI</span>, <span style=color:#a6e22e>first</span><span style=color:#f92672>+</span><span style=color:#ae81ff>16</span>(<span style=color:#a6e22e>FP</span>)    <span style=color:#75715e>// 将原伪寄存器SP偏移量存入返回值first
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>MOVQ</span>    <span style=color:#a6e22e>SP</span>, <span style=color:#a6e22e>BP</span>           <span style=color:#75715e>// 存储物理SP偏移量到BP寄存器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>ADDQ</span>    <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>4096</span>, <span style=color:#a6e22e>SP</span>        <span style=color:#75715e>// 将物理SP偏移增加4K
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>LEAQ</span> <span style=color:#a6e22e>x</span><span style=color:#f92672>-</span><span style=color:#ae81ff>0</span>(<span style=color:#a6e22e>SP</span>), <span style=color:#a6e22e>SI</span>         <span style=color:#75715e>// 在上面中只改变了一个值就是SP这个寄存器，然后再次一模一样的把x-0(SP)给到了SI.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* 第一个 MOVQ    BP, SP */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>MOVQ</span>    <span style=color:#a6e22e>BP</span>, <span style=color:#a6e22e>SP</span>           <span style=color:#75715e>// 恢复物理SP，因为修改物理SP后，伪寄存器FP/SP随之改变，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                 <span style=color:#75715e>// 为了正确访问FP，先恢复物理SP
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>MOVQ</span> <span style=color:#a6e22e>SI</span>, <span style=color:#a6e22e>second</span><span style=color:#f92672>+</span><span style=color:#ae81ff>24</span>(<span style=color:#a6e22e>FP</span>)   <span style=color:#75715e>// 将偏移后的伪寄存器SP偏移量存入返回值second
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* 第二个 MOVQ    BP, SP */</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//MOVQ    BP, SP         
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>RET</span>					    <span style=color:#75715e>// 从输出的second-first来看，正好相差4K
</span></span></span></code></pre></div><p>编译一下源代码：<code>go build -gcflags "-N -l" -o test .</code> OR <code>go build -gcflags "all=-N -l" -o test .</code> OR <code>GOOS=linux GOARCH=amd64 go tool compile -S .</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#f92672>[</span>root@iZf8z14idfp0rwhiicngwqZ FP_SP<span style=color:#f92672>]</span><span style=color:#75715e># tree .</span>
</span></span><span style=display:flex><span>.
</span></span><span style=display:flex><span>├── main.go
</span></span><span style=display:flex><span>├── main.o
</span></span><span style=display:flex><span>├── test
</span></span><span style=display:flex><span>└── test_FP_SP.s
</span></span></code></pre></div><p>我们用到的gdb命令:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>
</span></span><span style=display:flex><span>gdb ./test
</span></span><span style=display:flex><span>list
</span></span><span style=display:flex><span>b <span style=color:#ae81ff>6</span>
</span></span><span style=display:flex><span>display /25i $pc-8
</span></span><span style=display:flex><span>si
</span></span><span style=display:flex><span>si
</span></span><span style=display:flex><span>si
</span></span></code></pre></div><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210129195940.png alt=20210129195940>
从上面的图中可以看出，go assemble中的<code>x-0(SP)</code>与<code>first+16(FP)</code>,其实都是与SP寄存器关联的，
其中SP，伪FP，与伪SP的位置，在下图中已经标识出来了;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>+------------------------+                                  
</span></span><span style=display:flex><span>|                        |                                  
</span></span><span style=display:flex><span>|                        |                                  
</span></span><span style=display:flex><span>|         second         |                                  
</span></span><span style=display:flex><span>|                        |                                  
</span></span><span style=display:flex><span>|-------------------------                                  
</span></span><span style=display:flex><span>|                        |                                  
</span></span><span style=display:flex><span>|                        |                                  
</span></span><span style=display:flex><span>|         first          |                                  
</span></span><span style=display:flex><span>|                        |                                  
</span></span><span style=display:flex><span>|------------------------|                                  
</span></span><span style=display:flex><span>|                        |                                  
</span></span><span style=display:flex><span>|                        |                                  
</span></span><span style=display:flex><span>|         b              |                                  
</span></span><span style=display:flex><span>|                        |                                  
</span></span><span style=display:flex><span>|------------------------|                                  
</span></span><span style=display:flex><span>|                        |                                  
</span></span><span style=display:flex><span>|                        |                                  
</span></span><span style=display:flex><span>|         a              |                                  
</span></span><span style=display:flex><span>|                        |                                  
</span></span><span style=display:flex><span>+------------------------+ &lt;-------- 伪FP!!!                      
</span></span><span style=display:flex><span>|                        |                                  
</span></span><span style=display:flex><span>|                        |                                  
</span></span><span style=display:flex><span>|     caller<span style=color:#e6db74>&#39;s pc        |                                  
</span></span></span><span style=display:flex><span><span style=color:#e6db74>|                        |                                  
</span></span></span><span style=display:flex><span><span style=color:#e6db74>+------------------------+                                  
</span></span></span><span style=display:flex><span><span style=color:#e6db74>|                        |                                  
</span></span></span><span style=display:flex><span><span style=color:#e6db74>|                        |                                  
</span></span></span><span style=display:flex><span><span style=color:#e6db74>|     caller&#39;</span>s BP        |                                  
</span></span><span style=display:flex><span>|                        |                                  
</span></span><span style=display:flex><span>|------------------------| &lt;-------- callee<span style=color:#e6db74>&#39;s BP &lt;===&gt; 伪SP!!!
</span></span></span><span style=display:flex><span><span style=color:#e6db74>|                        |                                  
</span></span></span><span style=display:flex><span><span style=color:#e6db74>|                        |                                  
</span></span></span><span style=display:flex><span><span style=color:#e6db74>|        ...             |                                  
</span></span></span><span style=display:flex><span><span style=color:#e6db74>|                        |                                  
</span></span></span><span style=display:flex><span><span style=color:#e6db74>|                        |                                  
</span></span></span><span style=display:flex><span><span style=color:#e6db74>+------------------------+ &lt;-------- 真实寄存器SP[它等于caller&#39;</span>s SP - caller<span style=color:#e6db74>&#39;s next CP(8) - callee&#39;</span>s stack size;上图已经标识了<span style=color:#f92672>]</span>                     
</span></span></code></pre></div><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210129211423.png alt="MOVQ	0(SP), AX // f&amp;rsquo;s PC"></p><h3 id=扩展>扩展
<a class=anchor href=#%e6%89%a9%e5%b1%95>#</a></h3><p>当我们把<code>/* 第一个 MOVQ BP, SP */</code>下面的注释掉，执行的话会panic，是因为PC寄存器读取错误，而不是注释掉的下一行导致的。</p><p>可以实验下:我们把<code>/* 第二个 MOVQ BP, SP */</code>取消注释，它就正常执行，只是返回值不对而已。</p><h2 id=go编译器加的函数头的部分>go编译器加的函数头的部分
<a class=anchor href=#go%e7%bc%96%e8%af%91%e5%99%a8%e5%8a%a0%e7%9a%84%e5%87%bd%e6%95%b0%e5%a4%b4%e7%9a%84%e9%83%a8%e5%88%86>#</a></h2><pre tabindex=0><code>=&gt; 0x459240 &lt;main.test_FP_SP&gt;:	mov    %fs:0xfffffffffffffff8,%rcx
   0x459249 &lt;main.test_FP_SP+9&gt;:	mov    0x10(%rcx),%rsi
   0x45924d &lt;main.test_FP_SP+13&gt;:	cmp    $0xfffffffffffffade,%rsi
   0x459254 &lt;main.test_FP_SP+20&gt;:	je     0x4592bd &lt;main.test_FP_SP+125&gt;
   0x459256 &lt;main.test_FP_SP+22&gt;:	lea    0x370(%rsp),%rax
   0x45925e &lt;main.test_FP_SP+30&gt;:	sub    %rsi,%rax
   0x459261 &lt;main.test_FP_SP+33&gt;:	cmp    $0x1308,%rax
   0x459267 &lt;main.test_FP_SP+39&gt;:	jbe    0x4592bd &lt;main.test_FP_SP+125&gt;
   0x459269 &lt;main.test_FP_SP+41&gt;:	sub    $0x1018,%rsp
   0x459270 &lt;main.test_FP_SP+48&gt;:	mov    %rbp,0x1010(%rsp)
   0x459278 &lt;main.test_FP_SP+56&gt;:	lea    0x1010(%rsp),%rbp
   0x459280 &lt;main.test_FP_SP+64&gt;:	lea    0x1010(%rsp),%rdi
   0x459288 &lt;main.test_FP_SP+72&gt;:	mov    %rdi,0x1030(%rsp)
   0x459290 &lt;main.test_FP_SP+80&gt;:	mov    %rsp,%rbp
   0x459293 &lt;main.test_FP_SP+83&gt;:	add    $0x1000,%rsp
   0x45929a &lt;main.test_FP_SP+90&gt;:	lea    0x1010(%rsp),%rsi
   0x4592a2 &lt;main.test_FP_SP+98&gt;:	mov    %rbp,%rsp
   0x4592a5 &lt;main.test_FP_SP+101&gt;:	mov    %rsi,0x1038(%rsp)
   0x4592ad &lt;main.test_FP_SP+109&gt;:	mov    0x1010(%rsp),%rbp
   0x4592b5 &lt;main.test_FP_SP+117&gt;:	add    $0x1018,%rsp
   0x4592bc &lt;main.test_FP_SP+124&gt;:	retq
   0x4592bd &lt;main.test_FP_SP+125&gt;:	callq  0x450c70 &lt;runtime.morestack_noctxt&gt;
   0x4592c2 &lt;main.test_FP_SP+130&gt;:	jmpq   0x459240 &lt;main.test_FP_SP&gt;
   0x4592c7:	add    %al,(%rax)
   0x4592c9:	add    %al,(%rax)
</code></pre><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210201140600.png alt=以上面的例子来看></p><ul><li>在头和尾部加上了其他跳转代码。<ul><li><code>0x10(%rcx)</code></li><li><code>$0xfffffffffffffade</code></li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>stack</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>lo</span> <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>hi</span> <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>g</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Stack parameters.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// stack describes the actual stack memory: [stack.lo, stack.hi).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// stackguard0 is the stack pointer compared in the Go stack growth prologue.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// stackguard1 is the stack pointer compared in the C stack growth prologue.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// It is stack.lo+StackGuard on g0 and gsignal stacks.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>stack</span>       <span style=color:#a6e22e>stack</span>   <span style=color:#75715e>// offset known to runtime/cgo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>stackguard0</span> <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// offset known to liblink
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>stackguard1</span> <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// offset known to liblink
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//...
</span></span></span></code></pre></div><p>其中rcx是g的地址，所以<code>0x10(%rcx)</code>是就是跳过stack得到stackguard0(它是go栈增长的序章，开始的地方,值是：stack.lo+StackGuard)
<a href=https://github.com/golang/go/blob/0e85fd7561de869add933801c531bf25dee9561c/src/cmd/internal/objabi/stack.go#L21>var StackGuard = 928*stackGuardMultiplier() + StackSystem</a></p><p>当被抢占的时候，它是:
<a href=https://github.com/golang/go/blob/0e85fd7561de869add933801c531bf25dee9561c/src/cmd/internal/objabi/stack.go#L17>StackPreempt = -1314 // 0xfff&mldr;fade</a></p><table><thead><tr><th>order</th><th>explainment</th></tr></thead><tbody><tr><td>je</td><td>Jumps if equal</td></tr><tr><td>jbe</td><td>Jumps if below or equal</td></tr></tbody></table><h2 id=例子>例子
<a class=anchor href=#%e4%be%8b%e5%ad%90>#</a></h2><h3 id=main-goroutine得不到执行>main goroutine得不到执行
<a class=anchor href=#main-goroutine%e5%be%97%e4%b8%8d%e5%88%b0%e6%89%a7%e8%a1%8c>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;runtime&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>g2</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sum</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>sum</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>GOMAXPROCS</span>(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>g2</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>Gosched</span>()
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;main is scheduled!&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>将不会打印[&ldquo;main is scheduled!&rdquo;]</li></ul><h3 id=一些汇编需要的常见的指令>一些汇编需要的常见的指令
<a class=anchor href=#%e4%b8%80%e4%ba%9b%e6%b1%87%e7%bc%96%e9%9c%80%e8%a6%81%e7%9a%84%e5%b8%b8%e8%a7%81%e7%9a%84%e6%8c%87%e4%bb%a4>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>go build  -gcflags <span style=color:#e6db74>&#34;-N -l&#34;</span> -o test .
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>info files 
</span></span><span style=display:flex><span>info registers sp bp
</span></span><span style=display:flex><span>info breakpoint
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>x/10x
</span></span><span style=display:flex><span>help x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>x/16xb 0x7fffffffe470
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>https://visualgdb.com/gdbreference/commands/x<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>info register rbp rsp pc
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>display /20i $pc
</span></span></code></pre></div><p><a href=https://blog.csdn.net/counsellor/article/details/100034080>https://blog.csdn.net/counsellor/article/details/100034080</a></p><h2 id=附录>附录
<a class=anchor href=#%e9%99%84%e5%bd%95>#</a></h2><p><a href=https://lrita.github.io/2017/12/12/golang-asm/#interface>https://lrita.github.io/2017/12/12/golang-asm/#interface</a></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/alex-shpak/hugo-book/edit/main/exampleSite/content/docs/%e7%ac%ac%e4%b8%80%e7%ab%a0%20%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86/1.1%20%e6%b1%87%e7%bc%96%e5%9f%ba%e7%a1%80.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#go汇编>go汇编</a><ul><li><a href=#dropg函数>dropg()函数</a></li><li><a href=#park_m函数>park_m函数</a></li></ul></li><li><a href=#通过mcall从gn转到g0-stack转移了-jmp跳转到park_mg函数>通过mcall从gN转到g0; stack转移了, jmp跳转到park_m(*g)函数,</a></li><li><a href=#get_tls函数>get_tls函数</a><ul><li></li><li><a href=#参考>参考</a></li></ul></li><li><a href=#m_morebufgobuf_pcregister>(m_morebuf+gobuf_pc)(REGISTER)</a></li><li><a href=#伪寄存器>伪寄存器</a><ul><li></li><li><a href=#扩展>扩展</a></li></ul></li><li><a href=#go编译器加的函数头的部分>go编译器加的函数头的部分</a></li><li><a href=#例子>例子</a><ul><li><a href=#main-goroutine得不到执行>main goroutine得不到执行</a></li><li><a href=#一些汇编需要的常见的指令>一些汇编需要的常见的指令</a></li></ul></li><li><a href=#附录>附录</a></li></ul></li></ul></nav></div></aside></main></body></html>