<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>go调度源码分析</title><link>https://zput.github.io/go-goroutine/docs/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link><description>Recent content on go调度源码分析</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Thu, 28 Feb 2019 15:03:00 +0000</lastBuildDate><atom:link href="https://zput.github.io/go-goroutine/docs/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.xml" rel="self" type="application/rss+xml"/><item><title>1.1 底层类汇编函数</title><link>https://zput.github.io/go-goroutine/docs/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.1-%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</link><pubDate>Thu, 28 Feb 2019 15:03:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.1-%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</guid><description>go汇编 # gdb golang assamble non-split; sp bp 会更新吗?
main function enter BP is useful ? schedule
dropg()函数 # dropg() //解除g和m之间的关系; func dropg() { _g_ := getg() setMNoWB(&amp;amp;_g_.m.curg.m, nil) setGNoWB(&amp;amp;_g_.m.curg, nil) } park_m函数 # 通过mcall从gN转到g0; stack转移了, jmp跳转到park_m(*g)函数, # gN&amp;ndash;&amp;gt;m &amp;mdash;&amp;gt; gN mcall怎么保证g0的m指向了m的?
// park continuation on g0. func park_m(gp *g) { _g_ := getg() if trace.enabled { traceGoPark(_g_.m.waittraceev, _g_.m.waittraceskip) } casgstatus(gp, _Grunning, _Gwaiting) dropg() //解除g和m之间的关系 ...... schedule() } get_tls函数 # TEXT runtime·rt0_go(SB),NOSPLIT,$0 //.</description></item><item><title>1.2 内存大小端概念</title><link>https://zput.github.io/go-goroutine/docs/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.2-%E5%86%85%E5%AD%98/</link><pubDate>Sun, 20 Jan 2019 09:03:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.2-%E5%86%85%E5%AD%98/</guid><description> https://blog.csdn.net/fy_lei/article/details/49813137
对于这两种存储方式，如果联系下我们常用 “异或” 操作，就能得到一个很好的记忆规则。总结来说就是： 低地址存储低字节即为小端存储；高地址存储高字节即为小端存储； 低地址存储高字节即为大端存储；高地址存储低字节即为大端存储； 我们把 “低” 、“小” 认作 “0”， 把 “高”、“大” 认作 “1”，这样就可以利用 “异或” 的结果来加强记忆了。
内存 字节 大端/小端 低地址 低字节 小端存储 0 0 0 高地址 高字节 小端存储 1 1 0 低地址 高字节 大端存储 0 1 1 高地址 低字节 大端存储 1 0 1</description></item></channel></rss>