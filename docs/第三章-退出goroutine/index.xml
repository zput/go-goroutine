<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>go调度源码分析</title><link>https://example.com/docs/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E9%80%80%E5%87%BAgoroutine/</link><description>Recent content on go调度源码分析</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 10 Feb 2020 10:09:00 +0000</lastBuildDate><atom:link href="https://example.com/docs/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E9%80%80%E5%87%BAgoroutine/index.xml" rel="self" type="application/rss+xml"/><item><title>3.1 goroutine退出过程</title><link>https://example.com/docs/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E9%80%80%E5%87%BAgoroutine/3.1-%E9%80%80%E5%87%BAgoroutine/</link><pubDate>Mon, 10 Feb 2020 10:09:00 +0000</pubDate><guid>https://example.com/docs/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E9%80%80%E5%87%BAgoroutine/3.1-%E9%80%80%E5%87%BAgoroutine/</guid><description>退出 # 非main goroutine 最后会运行goexit() main goroutine 虽然也定义了goexit(),模拟好像是是goexit函数调用的,但是这个main goroutine在src/runtime/proc.go文件里,这个函数返回到上一层. exit(0),就会退出. 如果上面没有退出,下面的for循环会再次保证程序将不会到上一层再继续执行. // The main goroutine. func main() { //... exit(0) for { var x *int32 *x = 0 } } 例子 # 我们首先来gdb调试一下这个程序
main.go
package main import &amp;#34;time&amp;#34; // the function&amp;#39;s body is empty func add(x, y int64) int64 func main() { go add(2, 3) time.Sleep(time.Minute) } add_amd.s
TEXT ·add(SB),$0-24 MOVQ x+0(FP), BX MOVQ y+8(FP), BP ADDQ BP, BX MOVQ BX, ret+16(FP) RET 编译一下源代码: go build -gcflags &amp;quot;-N -l&amp;quot; -o test .</description></item></channel></rss>