<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>基础知识 on go调度源码分析</title><link>https://zput.github.io/go-goroutine/docs/foundation/</link><description>Recent content in 基础知识 on go调度源码分析</description><generator>Hugo -- gohugo.io</generator><language>zh</language><atom:link href="https://zput.github.io/go-goroutine/docs/foundation/index.xml" rel="self" type="application/rss+xml"/><item><title>基本用法</title><link>https://zput.github.io/go-goroutine/docs/foundation/golang_basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/foundation/golang_basic/</guid><description>Golang基本用法 # Golang基本用法 数据结构 引用 string 单引号 slice和数组的异同 slice的自动扩容后的大小是多少? 延伸 map 哈希扩容 扩容规则 struct和内存对齐 chan error.Unwrap 跟类型相关 类型系统 底层类型结构 基本数据结构底层表示 自定义数据结构底层表示 跟函数定义的结构相关 函数调用栈细节 闭包 方法(method) defer三阶段 before 1.13 测试题 1.13 1.14 panic AND recover 测验 跟interface相关 c++多态 接口 eface iface 类型断言 reflect reflect.Type reflect.Value 运行时: 并发编程 同步原语 内存顺序保证 sync包 context(上下文) 内存管理 GC 逃逸分析 内存泄漏 附录 0.方法 new And make example 值类型和引用类型的区别 计算golang中类型的大小的方式 golang的chan archive 数据结构 # 这些数据结构的底层是怎么实现的,比如array,它就是一个指针,指向第一个元素的地址. 然后就是一个细节,如果要实现这个数据结构的一些功能,比如chan读写,map的添加删除等,它们是怎么利用数据结构里面底层的field来实现这些功能? 引用 # 通常意义上来说，引用就是某块内存的别名, 我们常常拿指针与引用进行比较, 那么看看引用在底层是怎么实现的:</description></item><item><title>slice</title><link>https://zput.github.io/go-goroutine/docs/foundation/slice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/foundation/slice/</guid><description> 使用slice # 使用slice的时候，如果能预先确定它的大小，最好先设置好它的容量，避免后期扩容拷贝。预先大小也可能为零，所以总担心初始化能不能先申明容量为零。
func testMakeSlice() { var ( a = make([]int, 0) b = make([]int, 0, 0) ) fmt.Printf(&amp;#34;a=%+v; b=%+v&amp;#34;, a, b) fmt.Println() fmt.Printf(&amp;#34;a&amp;#39;s Length=%+v; b&amp;#39;s Length=%+v&amp;#34;, len(a), len(b)) fmt.Println() fmt.Printf(&amp;#34;a&amp;#39;s Capacity=%+v; b&amp;#39;s Capacity=%+v&amp;#34;, cap(a), cap(b)) fmt.Println() if a == nil { fmt.Println(&amp;#34;a is nil&amp;#34;) } else { fmt.Println(&amp;#34;a is not nil&amp;#34;) } if b == nil { fmt.Println(&amp;#34;b is nil&amp;#34;) } else { fmt.Println(&amp;#34;b is not nil&amp;#34;) } } func main() { testMakeSlice() } a=[]; b=[] a&amp;#39;s Length=0; b&amp;#39;s Length=0 a&amp;#39;s Capacity=0; b&amp;#39;s Capacity=0 a is not nil b is not nil</description></item><item><title>map</title><link>https://zput.github.io/go-goroutine/docs/foundation/map/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/foundation/map/</guid><description>并发map # 设计一个并发的map,最简单的就是使用锁加普通map来实现。
type simpleConcurrentMap struct{ mu sync.Mutex m map[interface{}]interface{} } 上面情形，不管是读还是写都需要先加锁，性能太低，假设我们要设计一个高并发的map呢？我们按读写操作来分一下类：
读多写少 读少写多 读写平衡 可以分为上述三类。 读多写少场景 # 可以让它们读写分离,分成两个map（readMap与writeMap）, 类似mysql的读写分离吗? 那么插入/更新(删除)的时候怎么从writeMap同步到readMap呢？不可能实时同步，否则readMap也转变为了writeMap,也需要加锁!!! 这么看读写分离就没有必要了，徒增复杂度。
那么可以设计成类似缓存的cacheMap(不加锁，原子锁)与持久化的persistentMap(加锁)？且把真实的value保存在第三方，自己保留的是第三方的句柄(handle), 类似下图的结构:
cacheMap: nil key---&amp;gt;ValuePtr(第三方句柄) / \ / \ / ---&amp;gt;valuePtr/-----&amp;gt;value(真实的值) / 可理解为第三方的唯一键 persistentMap: / key---&amp;gt;valuePtr(第三方句柄) 当删除的时候，如果在cacheMap中存在，就把对应的ValuePtr设置为nil(代表删除) 当更新的的时候，如果在cacheMap中存在，就把对应的ValuePtr所指向的value改为newValue(这样persistentMap也更新了) 当查询的时候，先去cacheMap查(如果key存在，valuePtr为nil则说明删除了，但是没有同步到persistentMap)，再去persistentMap查 当插入新的key时候，操作persistentMap。但是这也会遇到什么时候同步到cacheMap中去的问题，因为如果一直不同步，会导致查询的时候都会到persistentMap中去，也是要加锁的。
一个补偿措施是: 加一个计数器misses，在查询的时候，如果只有在persistentMap中才查到则misses++，到了一定条件，我们把persistentMap安全地同步到cacheMap中，并且清空persistentMap。
cacheMap是 persistentMap的一个只读拷贝，禁止自行增加新key，只能读或者改。
golang中的sync.Map就是一种适合读多写少的并发map; 把我们的 persistentMap 叫做了 dirtyMap，把persistentMap 同步到 cacheMap 叫做了promote（升级）。
读取 Map.Load
if is exist readMap[key] 读取返回 ret lock() if is exist readMap[key] // double-checking 读取返回 else if is exist dirtyMap[key] 读到了，在dirtyMap存在，但是在readMap中不存在 misses++ // 未命中自增 if misses &amp;gt;= len(dirtyMap) // 判断是否需要把dirtyMap提升级为readMap readMap = dirtyMap dirtyMap = nil // dirtyMap置空 else key is not exist unlock() 写入 Map.</description></item><item><title>sort</title><link>https://zput.github.io/go-goroutine/docs/foundation/sort/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/foundation/sort/</guid><description>在实际开发中，我们如何利用sort包，进行快速排序呢。
首先我们来看一下sort中最重要的一个接口:
sort # type Interface interface { // Len is the number of elements in the collection. Len() int // Less reports whether the element with // index i should sort before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) } // 内部实现的四种排序算法 // 插入排序 func insertionSort(data Interface, a, b int) // 堆排序 func heapSort(data Interface, a, b int) // 快速排序 func quickSort(data Interface, a, b, maxDepth int) // 归并排序 func symMerge(data Interface, a, m, b int) 一般我们利用下面三种方式进行排序:</description></item><item><title/><link>https://zput.github.io/go-goroutine/docs/foundation/directory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/foundation/directory/</guid><description>func executeDir() string { ex, err := os.Executable() if err != nil { panic(err) } exPath := filepath.Dir(ex) fmt.Println(exPath) return exPath } func getwd() string { // using the function mydir, err := os.Getwd() if err != nil { fmt.Println(err) } fmt.Println(mydir) return mydir }</description></item></channel></rss>