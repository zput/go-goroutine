<!doctype html><html lang=zh dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='在实际开发中，我们如何利用sort包，进行快速排序呢。
首先我们来看一下sort中最重要的一个接口:

  sort
  #

type Interface interface {
    // Len is the number of elements in the collection.
    Len() int
    // Less reports whether the element with
    // index i should sort before the element with index j.
    Less(i, j int) bool
    // Swap swaps the elements with indexes i and j.
    Swap(i, j int)
}

// 内部实现的四种排序算法
// 插入排序
func insertionSort(data Interface, a, b int)
// 堆排序
func heapSort(data Interface, a, b int)
// 快速排序
func quickSort(data Interface, a, b, maxDepth int)
// 归并排序
func symMerge(data Interface, a, m, b int)
一般我们利用下面三种方式进行排序:

  定义一种类型实现sort.Interface
  #

// https://leetcode.cn/problems/non-overlapping-intervals/

import "sort"

func eraseOverlapIntervals(intervals [][]int) int {
    arr := _sort(intervals)
    tmp := arr[0]
    var ret int
    for i:=1; i< len(arr); i++{
        if tmp[1] > arr[i][0]{
            ret++
        }else{
            tmp = arr[i]
        }
    }
    return ret
}

func _sort(s [][]int)[][]int{
    sort.Sort(slice(s))
    return s
}

type slice [][]int
func (s slice)Len()int{
    return len(s) 
}

func (s slice)Swap(i, j int){
    s[i], s[j] = s[j], s[i]
}

func (s slice)Less(i, j int)bool{
   if s[i][1] < s[j][1]{
       return true
   }
   return false
}

  预先定义好的函数
  #

sort.Strings()
sort.Ints()
package main

import (
    "fmt"
    "sort"
)

func main() {

    strs := []string{"c", "a", "b"}
    sort.Strings(strs)
    fmt.Println("Strings:", strs)

    ints := []int{7, 2, 4}
    sort.Ints(ints)
    fmt.Println("Ints:   ", ints)

    s := sort.IntsAreSorted(ints)
    fmt.Println("Sorted: ", s)
}

  使用Slice函数
  #

sort.Slice(x any, less func(i, j int)bool)
Slice根据所提供的less函数对Slice x进行排序。如果x不是切片，它就会惊慌。
排序不保证是稳定的:相等的元素可以从它们原来的顺序颠倒过来。对于稳定排序，请使用SliceStable。
less函数必须满足与接口类型的less方法相同的要求。'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://zput.github.io/go-goroutine/docs/foundation/sort/"><meta property="og:site_name" content="go调度源码分析"><meta property="og:title" content="sort"><meta property="og:description" content='在实际开发中，我们如何利用sort包，进行快速排序呢。
首先我们来看一下sort中最重要的一个接口:
sort # type Interface interface { // Len is the number of elements in the collection. Len() int // Less reports whether the element with // index i should sort before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) } // 内部实现的四种排序算法 // 插入排序 func insertionSort(data Interface, a, b int) // 堆排序 func heapSort(data Interface, a, b int) // 快速排序 func quickSort(data Interface, a, b, maxDepth int) // 归并排序 func symMerge(data Interface, a, m, b int) 一般我们利用下面三种方式进行排序:
定义一种类型实现sort.Interface # // https://leetcode.cn/problems/non-overlapping-intervals/ import "sort" func eraseOverlapIntervals(intervals [][]int) int { arr := _sort(intervals) tmp := arr[0] var ret int for i:=1; i< len(arr); i++{ if tmp[1] > arr[i][0]{ ret++ }else{ tmp = arr[i] } } return ret } func _sort(s [][]int)[][]int{ sort.Sort(slice(s)) return s } type slice [][]int func (s slice)Len()int{ return len(s) } func (s slice)Swap(i, j int){ s[i], s[j] = s[j], s[i] } func (s slice)Less(i, j int)bool{ if s[i][1] < s[j][1]{ return true } return false } 预先定义好的函数 # sort.Strings() sort.Ints() package main import ( "fmt" "sort" ) func main() { strs := []string{"c", "a", "b"} sort.Strings(strs) fmt.Println("Strings:", strs) ints := []int{7, 2, 4} sort.Ints(ints) fmt.Println("Ints: ", ints) s := sort.IntsAreSorted(ints) fmt.Println("Sorted: ", s) } 使用Slice函数 # sort.Slice(x any, less func(i, j int)bool) Slice根据所提供的less函数对Slice x进行排序。如果x不是切片，它就会惊慌。 排序不保证是稳定的:相等的元素可以从它们原来的顺序颠倒过来。对于稳定排序，请使用SliceStable。 less函数必须满足与接口类型的less方法相同的要求。'><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>sort | go调度源码分析</title>
<link rel=manifest href=/go-goroutine/manifest.json><link rel=icon href=/go-goroutine/favicon.png><link rel=stylesheet href=/go-goroutine/book.min.a7d3a43391e1f7eb43ae94bcae6354b739c49cba56473620924ec707afe0864d.css integrity="sha256-p9OkM5Hh9+tDrpS8rmNUtznEnLpWRzYgkk7HB6/ghk0=" crossorigin=anonymous><script defer src=/go-goroutine/flexsearch.min.js></script><script defer src=/go-goroutine/en.search.min.757062fa50ab1c55395e9a4323f8da7af02f1400835167bc45473bc356a004a4.js integrity="sha256-dXBi+lCrHFU5XppDI/jaevAvFACDUWe8RUc7w1agBKQ=" crossorigin=anonymous></script><script defer src=/go-goroutine/sw.min.ec96d6e09af3075a94dd4de723a2edddf2ef138381c7e1e5b5a1f2c0578ee8bd.js integrity="sha256-7JbW4JrzB1qU3U3nI6Lt3fLvE4OBx+HltaHywFeO6L0=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/go-goroutine/><span>go调度源码分析</span></a></h2><div class=magic><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><div class=book-switch><label class=switch><input id=dark-mode-checkbox type=checkbox onchange=darkmode()>
<span class=slider></span></label></div></div><ul><li><a href=https://zput.github.io target=_blank rel=noopener>Zput博客</a></li><li><a href=https://github.com/zput target=_blank rel=noopener>GitHub</a></li></ul><hr><ul><li><span>基础知识</span><ul><li><a href=/go-goroutine/docs/foundation/golang_basic/>基本用法</a></li><li><a href=/go-goroutine/docs/foundation/slice/>slice</a></li><li><a href=/go-goroutine/docs/foundation/map/>map</a></li><li><a href=/go-goroutine/docs/foundation/sort/ class=active>sort</a></li><li><a href=/go-goroutine/docs/foundation/directory/>Directory</a></li></ul></li><li><span>鲁棒和性能</span><ul><li><a href=/go-goroutine/docs/robustness_and_performance/golang_test/>测试相关函数</a></li></ul></li><li><span>运行时</span><ul><li><a href=/go-goroutine/docs/runtime/golang_gmp/>GMP模型结构体</a></li><li><span>堆分配原理</span><ul><li><a href=/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/1_summarize/>概述</a></li><li><a href=/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_big_object/>分配大对象</a></li><li><a href=/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_middle_object/>概述</a></li><li><a href=/go-goroutine/docs/runtime/heap/ch0_prespective_of_uses/alloc_small_object/>概述</a></li></ul></li><li><a href=/go-goroutine/docs/runtime/golang_memery/>内存分配器</a></li><li><a href=/go-goroutine/docs/runtime/golang_gc/>垃圾回收</a></li><li><a href=/go-goroutine/docs/runtime/schedule/>调度</a><ul><li><span>前置知识</span><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/register_functionstack/>伪寄存器与函数栈帧</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/similar_assemble/>类汇编</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/go_underlying_struct/>底层重要结构</a></li></ul></li><li><a href=/go-goroutine/docs/runtime/schedule/2_init_before_enter_main_function/>初始化</a></li><li><a href=/go-goroutine/docs/runtime/schedule/3_exit_goroutine/>退出</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/>调度挑选策略</a><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/take_goroutine_from_globalorlocal_p/>从全局/本P队列</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/steal_goroutine_from_other_p/>从其他P队列</a></li></ul></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/>调度到达时机</a><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/active_scheduling/>主动调度</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/passive_scheduling/>被动调度</a></li><li><input type=checkbox id=section-740657f38f0c4de9a986bda642ff0388 class=toggle>
<label for=section-740657f38f0c4de9a986bda642ff0388 class="flex justify-between"><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/>剥夺调度</a></label><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/start_sysmon/>开启系统监控</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/user_code_preemption/>代码执行过久</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/system_call_preemption/>陷入系统调用</a></li></ul></li></ul></li></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script><script src=/go-goroutine/magic.js></script><script src=/go-goroutine/dark.js></script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/go-goroutine/svg/menu.svg class=book-icon alt=Menu>
</label><strong>sort</strong>
<label for=toc-control><img src=/go-goroutine/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#sort>sort</a><ul><li><a href=#定义一种类型实现sortinterface>定义一种类型实现sort.Interface</a></li><li><a href=#预先定义好的函数>预先定义好的函数</a></li><li><a href=#使用slice函数>使用Slice函数</a></li></ul></li></ul></nav></aside></header><article class=markdown><p>在实际开发中，我们如何利用sort包，进行快速排序呢。</p><p>首先我们来看一下sort中最重要的一个接口:</p><h1 id=sort>sort
<a class=anchor href=#sort>#</a></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Interface</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Len is the number of elements in the collection.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>Len</span>() <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Less reports whether the element with
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// index i should sort before the element with index j.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>Less</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Swap swaps the elements with indexes i and j.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>Swap</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 内部实现的四种排序算法
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 插入排序
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>insertionSort</span>(<span style=color:#a6e22e>data</span> <span style=color:#a6e22e>Interface</span>, <span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>// 堆排序
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>heapSort</span>(<span style=color:#a6e22e>data</span> <span style=color:#a6e22e>Interface</span>, <span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>// 快速排序
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>quickSort</span>(<span style=color:#a6e22e>data</span> <span style=color:#a6e22e>Interface</span>, <span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>maxDepth</span> <span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>// 归并排序
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>symMerge</span>(<span style=color:#a6e22e>data</span> <span style=color:#a6e22e>Interface</span>, <span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>m</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>)
</span></span></code></pre></div><p>一般我们利用下面三种方式进行排序:</p><h2 id=定义一种类型实现sortinterface>定义一种类型实现sort.Interface
<a class=anchor href=#%e5%ae%9a%e4%b9%89%e4%b8%80%e7%a7%8d%e7%b1%bb%e5%9e%8b%e5%ae%9e%e7%8e%b0sortinterface>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// https://leetcode.cn/problems/non-overlapping-intervals/
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;sort&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>eraseOverlapIntervals</span>(<span style=color:#a6e22e>intervals</span> [][]<span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>arr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>_sort</span>(<span style=color:#a6e22e>intervals</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>tmp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>arr</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ret</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span><span style=color:#f92672>:=</span><span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>i</span>&lt; len(<span style=color:#a6e22e>arr</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>tmp</span>[<span style=color:#ae81ff>1</span>] &gt; <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>i</span>][<span style=color:#ae81ff>0</span>]{
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>ret</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>        }<span style=color:#66d9ef>else</span>{
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>tmp</span> = <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>i</span>]
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ret</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>_sort</span>(<span style=color:#a6e22e>s</span> [][]<span style=color:#66d9ef>int</span>)[][]<span style=color:#66d9ef>int</span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sort</span>.<span style=color:#a6e22e>Sort</span>(<span style=color:#a6e22e>slice</span>(<span style=color:#a6e22e>s</span>))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>slice</span> [][]<span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#a6e22e>slice</span>)<span style=color:#a6e22e>Len</span>()<span style=color:#66d9ef>int</span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> len(<span style=color:#a6e22e>s</span>) 
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#a6e22e>slice</span>)<span style=color:#a6e22e>Swap</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>){
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span>[<span style=color:#a6e22e>i</span>], <span style=color:#a6e22e>s</span>[<span style=color:#a6e22e>j</span>] = <span style=color:#a6e22e>s</span>[<span style=color:#a6e22e>j</span>], <span style=color:#a6e22e>s</span>[<span style=color:#a6e22e>i</span>]
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#a6e22e>slice</span>)<span style=color:#a6e22e>Less</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>)<span style=color:#66d9ef>bool</span>{
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>[<span style=color:#a6e22e>i</span>][<span style=color:#ae81ff>1</span>] &lt; <span style=color:#a6e22e>s</span>[<span style=color:#a6e22e>j</span>][<span style=color:#ae81ff>1</span>]{
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=预先定义好的函数>预先定义好的函数
<a class=anchor href=#%e9%a2%84%e5%85%88%e5%ae%9a%e4%b9%89%e5%a5%bd%e7%9a%84%e5%87%bd%e6%95%b0>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>sort</span>.<span style=color:#a6e22e>Strings</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>sort</span>.<span style=color:#a6e22e>Ints</span>()
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;sort&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>strs</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>string</span>{<span style=color:#e6db74>&#34;c&#34;</span>, <span style=color:#e6db74>&#34;a&#34;</span>, <span style=color:#e6db74>&#34;b&#34;</span>}
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sort</span>.<span style=color:#a6e22e>Strings</span>(<span style=color:#a6e22e>strs</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Strings:&#34;</span>, <span style=color:#a6e22e>strs</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ints</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>4</span>}
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sort</span>.<span style=color:#a6e22e>Ints</span>(<span style=color:#a6e22e>ints</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Ints:   &#34;</span>, <span style=color:#a6e22e>ints</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sort</span>.<span style=color:#a6e22e>IntsAreSorted</span>(<span style=color:#a6e22e>ints</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Sorted: &#34;</span>, <span style=color:#a6e22e>s</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=使用slice函数>使用Slice函数
<a class=anchor href=#%e4%bd%bf%e7%94%a8slice%e5%87%bd%e6%95%b0>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>sort</span>.<span style=color:#a6e22e>Slice</span>(<span style=color:#a6e22e>x</span> <span style=color:#a6e22e>any</span>, <span style=color:#a6e22e>less</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>)<span style=color:#66d9ef>bool</span>)
</span></span></code></pre></div><p>Slice根据所提供的less函数对Slice x进行排序。如果x不是切片，它就会惊慌。
排序不保证是稳定的:相等的元素可以从它们原来的顺序颠倒过来。对于稳定排序，请使用SliceStable。
less函数必须满足与接口类型的less方法相同的要求。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>eraseOverlapIntervals</span>(<span style=color:#a6e22e>intervals</span> [][]<span style=color:#66d9ef>int</span>) (<span style=color:#a6e22e>res</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sort</span>.<span style=color:#a6e22e>Slice</span>(<span style=color:#a6e22e>intervals</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>intervals</span>[<span style=color:#a6e22e>i</span>][<span style=color:#ae81ff>1</span>] &lt; <span style=color:#a6e22e>intervals</span>[<span style=color:#a6e22e>j</span>][<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>curMax</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>intervals</span>[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>intervals</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>intervals</span>[<span style=color:#a6e22e>i</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>curMax</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>curMax</span> = <span style=color:#a6e22e>intervals</span>[<span style=color:#a6e22e>i</span>][<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>res</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>intervals</span>[<span style=color:#a6e22e>i</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>curMax</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>curMax</span> = <span style=color:#a6e22e>intervals</span>[<span style=color:#a6e22e>i</span>][<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><script src=https://giscus.app/client.js data-repo=zput/utterances-comments data-repo-id=R_kgDOHhATGQ data-category=Announcements data-category-id=DIC_kwDOHhATGc4CPxca data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=1 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#sort>sort</a><ul><li><a href=#定义一种类型实现sortinterface>定义一种类型实现sort.Interface</a></li><li><a href=#预先定义好的函数>预先定义好的函数</a></li><li><a href=#使用slice函数>使用Slice函数</a></li></ul></li></ul></nav></div></aside></main></body></html><script type=text/javascript src=https://cdn.bootcss.com/viz.js/1.8.2/viz.js></script><script type=text/javascript>(function(){var e="language-viz-";Array.prototype.forEach.call(document.querySelectorAll("[class^="+e+"]"),function(t){console.log(t),t.getAttribute("class").split(" ").forEach(function(t){t.startsWith(e)&&(s=t.substr(e.length))}),console.log("------------MIDDLE--------");var s,o=Viz(t.innerText,{format:"svg",engine:s}),n=(new DOMParser).parseFromString(o,"image/svg+xml");n.documentElement.setAttribute("style","max-width:100%; max-height:100%;"),t.parentNode.insertBefore(n.documentElement,t),t.style.display="none",t.parentNode.style.backgroundColor="white",t.style.width=n.documentElement.getAttribute("width")+"px",t.style.height=n.documentElement.getAttribute("height")+"px",console.log("--------------END------")})})()</script>